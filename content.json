{"pages":[],"posts":[{"title":"算法学习总结","text":"1、什么是算法？算法就是计算或者解决问题的步骤。我们可以把它想象成食谱。要想做出特定的料理，就要遵循食谱上的步骤；同理，要想用计算机解决特定的问题，就要遵循算法。这里所说的特定问题多种多样，比如“将随意排列的数字按从小到大的顺序重新排列”“寻找出发点到目的地的最短路径”，等等。食谱和算法之间最大的区别就在于算法是严密的。食谱上经常会有描述得比较模糊的部分，而算法的步骤都是用数学方式来描述的，所以十分明确。算法和程序有些相似，区别在于程序是以计算机能够理解的编程语言编写而成的，可以在计算机上运行，而算法是以人类能够理解的方式描述的，用于编写程序之前。不过，在这个过程中到哪里为止是算法、从哪里开始是程序，并没有明确的界限。就算使用同一个算法，编程语言不同，写出来的程序也不同；即便使用相同的编程语言，写程序的人不同，那么写出来的程序也是不同的。 摘录自《我的第一本算法》，这本书特别适合新手学习，以图形的方式来讲解，易于理解。 2、数据结构什么是数据结构？ 答：数据存储于内存中，决定了数据顺序和位置关系的便是“数据结构”。 数组（Array） 数据按顺序存储在内存的连续空间内。 链表（Linked List） 是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 栈（Stack） 栈也是一种数据呈线性排列的数据结构，遵循后进先出原则 队列（Queue） 普通队列：队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作。 双端队列（Deque）：入口和出口都可以入队和出队 优先队列（PriorityQueue）：根据优先级出队 哈希表（Hash table） 哈希表（Hash table），也叫散列表，是根据关键码值（Key value）而直接进行访问的数据结构。 树（Tree） 一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。 特点： 每个节点都只有有限个子节点或无子节点 没有父节点的节点称为根节点 每一个非根节点有且仅有一个父节点 除了根节点外，每个子节点可以分为多个不相交的子树 树中没有环路 堆（Heap） 可以迅速找到一堆数中的最大或者最小值的数据结构。将根节点最大的堆叫做大顶堆或大根堆，根节点最小的堆叫做小顶堆或小根堆。常见的堆有二叉堆、斐波那契堆等。 满足下列性质： 堆中任意节点的值总是&gt;=或&lt;=其子节点的值 堆总是一颗完全二叉树 图（Graph） 图结构也是一种非线性数据结构，并且每个数据元素之间可以任意关联。 一个典型的图结构包括如下两个部分： 顶点（Vertex）：图中的数据元素 边（Edge）：图中连接这些顶点的线 存储方法：邻接矩阵、邻接表 邻接矩阵 邻接表 关于数据结构总结脑图附件 数据结构和算法-思维导图.pdf 3、算法 递归（Recursion） 递归也是一种循环，不过是通过函数体自己调用自己来进行的循环 简单示例：计算 n！ 12345// n！= 1*2*3*...*ndef Factorial(n): if n&lt;=1: return 1 return n*Factorial(n-1) 代码模板（Java） 123456789101112public void recur(int level , int param){ // terminator if (level &gt; MAX_LEVEL){ // process result retutn; } // process current logic process(level,param); // drill down recur(level+1,newParam); // restore current status} 爬楼梯（阿里巴巴、腾讯、字节跳动在半年内面试常考） 常规写法： 123456public int climbStairs(int n) { if(n &lt;= 2){ return n; } return climbStairs(n-1) + climbStairs(n-2);} 升级版本： 123456789public int climbStairs(int n) { int f1 = 1, f2 = 2, f3 = 0; for (int i = 3; i &lt;= n; i++) { f3 = f1 + f2; f1 = f2; f2 = f3; } return f3;} 括号生成(字节跳动在半年内面试中考过)123456789101112131415161718192021222324252627public List&lt;String&gt; generateParenthesis(int n) { List&lt;String&gt; res = new ArrayList&lt;&gt;(); if (n &lt; 1) { return res; } generate(0, 0, &quot;&quot;, res, n); return res;}public void generate(int left, int right, String s, List&lt;String&gt; res, int n) { // 1.递归终结条件 if (left == n &amp;&amp; right == n) { res.add(s); return; } // 2.处理当前层 // 右括号多余左括号，说明已经是无效括号组合 if (left &lt; right) { return; } // 3.下探下一层 // 如果左括号还能添加,右括号不变 if (left &lt; n) generate(left + 1, right, s + &quot;(&quot;, res, n); // 如果右括号还能添加，左括号不变 if (right &lt; n) generate(left, right + 1, s + &quot;)&quot;, res, n);} 翻转二叉树(谷歌、字节跳动、Facebook 在半年内面试中考过)12345678910public TreeNode invertTree(TreeNode root) { if (root == null) return null; TreeNode left = root.left; root.left = root.right; root.right = left; invertTree(root.left); invertTree(root.right); return root;} 验证二叉搜索树（亚马逊、微软、Facebook 在半年内面试中考过）1234567891011// 中序遍历访问，先遍历左子树，如果有当前节点值&lt;=前节点值，不满足条件private TreeNode per;public boolean isValidBST(TreeNode root) { if (root == null) return true; if (!isValidBST(root.left)) return false; if (per != null &amp;&amp; root.val &lt;= per.val) return false; per = root; if (!isValidBST(root.right)) return false; return true;} 二叉树的最大深度（亚马逊、微软、字节跳动在半年内面试中考过）123456class Solution { public int maxDepth(TreeNode root) { if(root == null) return 0; return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1; }} 二叉树的最小深度（Facebook、字节跳动、谷歌在半年内面试中考过）123456789class Solution { public int minDepth(TreeNode root) { if(root == null) return 0; if(root.left == null &amp;&amp; root.right ==null) return 1; if(root.left == null || root.right == null) return minDepth(root.left) + minDepth(root.right) + 1; return Math.min(minDepth(root.left),minDepth(root.right)) + 1; }} 二叉树的序列化与反序列化（Facebook、亚马逊在半年内面试常考）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */public class Codec { // Encodes a tree to a single string. public String serialize(TreeNode root) { StringBuilder str = new StringBuilder(); // BFS return traversTree(root,str); } // Decodes your encoded data to tree. public TreeNode deserialize(String data) { if(data.isEmpty() || data.equals(&quot;#&quot;)){ return null; } Queue&lt;TreeNode&gt; queue = new LinkedList(); String[] nodes = data.split(&quot;,&quot;); TreeNode root = new TreeNode(Integer.valueOf(nodes[0])); queue.add(root); for(int i = 1; i &lt; nodes.length ; i++){ TreeNode p = queue.poll(); if(!&quot;#&quot;.equals(nodes[i])){ TreeNode left = new TreeNode(Integer.valueOf(nodes[i])); p.left = left; queue.add(left); } if(!&quot;#&quot;.equals(nodes[++i])){ TreeNode right = new TreeNode(Integer.valueOf(nodes[i])); p.right = right; queue.add(right); } } return root; } public String traversTree(TreeNode root,StringBuilder str){ if(root == null) { return &quot;#&quot;; } Queue&lt;TreeNode&gt; queue = new LinkedList(); queue.add(root); while(!queue.isEmpty()){ TreeNode node = queue.poll(); if(node == null){ str.append(&quot;#&quot;+&quot;,&quot;); continue; } str.append(node.val+&quot;,&quot;); queue.add(node.left); queue.add(node.right); } return str.toString(); }}// Your Codec object will be instantiated and called as such:// Codec ser = new Codec();// Codec deser = new Codec();// TreeNode ans = deser.deserialize(ser.serialize(root)); 课后作业： 二叉树的最近公共祖先（Facebook 在半年内面试常考）123456789101112class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null || root == p || root == q) { return root; } TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if(left == null) return right; if(right == null) return left; return root; }} 从前序与中序遍历序列构造二叉树（字节跳动、亚马逊、微软在半年内面试中考过）123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { private Map&lt;Integer, Integer&gt; indexMap = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] preorder, int[] inorder) { if (preorder.length == 0 || inorder.length == 0) { return null; } int n = preorder.length; // 将中序遍历的数组保存在map中，以便快速查询节点对应的下标 for (int i = 0; i &lt; n; i++) { indexMap.put(inorder[i], i); } return buildTreeHelper(preorder, inorder, 0, n - 1, 0, n - 1); } private TreeNode buildTreeHelper(int[] preorder, int[] inorder, int preLeft, int preRight, int inLeft, int inRight) { // 递归结束条件，数组切分完为止 if (preLeft &gt; preRight) { return null; } // 前序遍历的第一个节点就是根节点 int perRoot = preLeft; // 查询根节点在中序遍历中的下标位置 int index_root = (int)indexMap.get(preorder[perRoot]); // 创建根节点 TreeNode root = new TreeNode(preorder[perRoot]); // 计算左子树中的节点数目，以index_root下标为中心将前序遍历数组inorder切分为左子树、右子树两部分 int left_size = index_root - inLeft; // 递归构造左子树 root.left = buildTreeHelper(preorder, inorder, preLeft + 1, preLeft + left_size, inLeft, index_root - 1); // 递归构造右子树 root.right = buildTreeHelper(preorder, inorder, preLeft + left_size + 1, preRight, index_root + 1, inRight); return root; }} 组合（微软、亚马逊、谷歌在半年内面试中考过）123456789101112131415161718class Solution { public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); dfs(n, k, 1, new ArrayList&lt;Integer&gt;(), res); return res; } private void dfs(int n, int k, int start, ArrayList&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; res) { if (k == 0) { res.add(new ArrayList&lt;&gt;(list)); return; } for (int i = start; i &lt;= n - k + 1; i++) { list.add(i); dfs9(n, k - 1, i + 1, list, res); list.remove(list.size() - 1); } }} 全排列（字节跳动在半年内面试常考）123456789101112131415161718192021222324class Solution { public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(); boolean[] used = new boolean[nums.length]; dfs(nums, 0, path, used, res); return res; } private void dfs(int[] nums, int level, Deque&lt;Integer&gt; path, boolean[] used, List&lt;List&lt;Integer&gt;&gt; res) { if (level == nums.length) { res.add(new ArrayList&lt;&gt;(path)); return; } for (int j = 0; j &lt; nums.length; j++) { if (!used[j]) { path.addLast(nums[j]); used[j] = true; dfs(nums, level + 1, path, used, res); used[j] = false; path.removeLast(); } } }} 全排列 II （亚马逊、字节跳动、Facebook 在半年内面试中考过）12345678910111213141516171819202122232425262728293031class Solution { public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(); boolean[] used = new boolean[nums.length]; // 排序（升序或者降序都可以），排序是剪枝的前提 Arrays.sort(nums); dfs(nums, 0, path, used, res); return res; } private void dfs(int[] nums, int level, Deque&lt;Integer&gt; path, boolean[] used, List&lt;List&lt;Integer&gt;&gt; res) { if (level == nums.length) { res.add(new ArrayList&lt;&gt;(path)); return; } for (int j = 0; j &lt; nums.length; j++) { if (used[j]) { continue; } // 剪枝，取掉重复的搜索结果 if (j &gt; 0 &amp;&amp; nums[j] == nums[j - 1] &amp;&amp; !used[j - 1]) { continue; } path.addLast(nums[j]); used[j] = true; dfs(nums, level + 1, path, used, res); used[j] = false; path.removeLast(); } }} 分治、回溯 分治代码模板1234567891011private static int divide_conquer(Problem problem, ) { if (problem == NULL) { int res = process_last_result(); return res; } subProblems = split_problem(problem) res0 = divide_conquer(subProblems[0]) res1 = divide_conquer(subProblems[1]) result = process_result(res0, res1); return result;} 50. Pow(x, n)12345678910class Solution { public double myPow(double x, int n) { if(n == 0) return 1; if(n == 1) return x; if(n == -1) return 1/x; double helf = myPow(x,n/2); double rest = myPow(x,n%2); return rest*helf*helf; }} 78. 子集123456789101112131415class Solution { public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); subsets(nums,0,new ArrayList(),result); return result; } public void subsets(int[] nums,int index ,List&lt;Integer&gt; list,List&lt;List&lt;Integer&gt;&gt; result){ result.add(new ArrayList&lt;&gt;(list)); for(int i = index;i&lt;nums.length;i++){ list.add(nums[i]); subsets(nums,i + 1,list,result); list.remove(list.size() - 1); } }} 169. 多数元素 思路：排序 123456class Solution { public int majorityElement(int[] nums) { Arrays.sort(nums); return nums[nums.length/2]; }} 思路：摩尔投票法相同的元素则 票数+1，遇到不同的则 票数-1 因为“多数元素”个数 &gt; n/2 ，则其余元素个数 &lt;= n/2 这样“多数元素”的票数就能抵消掉所有其余元素的票数，最终剩余的就是票数最多的元素。 1234567891011121314151617181920class Solution { public int majorityElement(int[] nums) { // 默认选中第一个元素为候选人，票数默认10 int count = 1; int choose = nums[0]; for (int i = 1; i &lt; nums.length; i++) { if (nums[i] == choose) { count++; } else { count--; } // 当票数为0时，需要更换候选人，票数也重置为1 ，开始重新投票 if (count == 0) { choose = nums[i]; count = 1; } } return choose; }} 17. 电话号码的字母组合 思路：dfs+回溯 123456789101112131415161718192021222324252627class Solution { public List&lt;String&gt; letterCombinations(String digits) { List&lt;String&gt; res = new ArrayList(); if (digits.length() == 0) return res; Map&lt;Character, String&gt; keyboard = new HashMap&lt;&gt;(); keyboard.put('2', &quot;abc&quot;); keyboard.put('3', &quot;def&quot;); keyboard.put('4', &quot;ghi&quot;); keyboard.put('5', &quot;jkl&quot;); keyboard.put('6', &quot;mno&quot;); keyboard.put('7', &quot;pqrs&quot;); keyboard.put('8', &quot;tuv&quot;); keyboard.put('9', &quot;wxyz&quot;); search(digits, 0, &quot;&quot;, res, keyboard); return res; } public void search(String digits, int level, String s, List&lt;String&gt; res, Map&lt;Character, String&gt; keyboard) { if (level == digits.length()) { res.add(s); return; } String letter = keyboard.get(digits.charAt(level)); for (int i = 0; i &lt; letter.length(); i++) { search(digits, level + 1, s + letter.charAt(i), res, keyboard); } }} 51. N 皇后12345678910111213141516171819202122232425262728```3. 深度优先搜索、广度优先搜索* DFS代码模板中序遍历```java//Javapublic List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; allResults = new ArrayList&lt;&gt;(); if(root==null){ return allResults; } travel(root,0,allResults); return allResults;}public void travel(TreeNode root,int level,List&lt;List&lt;Integer&gt;&gt; results){ if(results.size()==level){ results.add(new ArrayList&lt;&gt;()); } results.get(level).add(root.val); if(root.left!=null){ travel(root.left,level+1,results); } if(root.right!=null){ travel(root.right,level+1,results); }} BFS代码模板 层序遍历 123456789101112131415161718192021222324public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; allResults = new ArrayList&lt;&gt;(); if (root == null) { return allResults; } Queue&lt;TreeNode&gt; nodes = new LinkedList&lt;&gt;(); nodes.add(root); while (!nodes.isEmpty()) { int size = nodes.size(); List&lt;Integer&gt; results = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; size; i++) { TreeNode node = nodes.poll(); results.add(node.val); if (node.left != null) { nodes.add(node.left); } if (node.right != null) { nodes.add(node.right); } } allResults.add(results); } return allResults;} 102. 二叉树的层序遍历1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty()){ int size = queue.size(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i = 0 ; i &lt; size; i++){ TreeNode node = queue.poll(); list.add(node.val); if(node.left != null) queue.add(node.left); if(node.right != null) queue.add(node.right); } res.add(list); } return res; }} 515. 在每个树行中找最大值1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public List&lt;Integer&gt; largestValues(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty()){ int size = queue.size(); int max = Integer.MIN_VALUE; for(int i = 0;i &lt; size;i++){ TreeNode node = queue.poll(); max = Math.max(max,node.val); if(node.left != null) queue.add(node.left); if(node.right != null) queue.add(node.right); } res.add(max); } return res; }} 589. N叉树的前序遍历123456789101112131415161718192021222324252627282930313233/*// Definition for a Node.class Node { public int val; public List&lt;Node&gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&lt;Node&gt; _children) { val = _val; children = _children; }};*/class Solution { public List&lt;Integer&gt; preorder(Node root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; traverse(root,res); return res; } private void traverse(Node node,List&lt;Integer&gt; res){ if(node == null){ return; } res.add(node.val); List&lt;Node&gt; children = node.children; for(int i = 0 ; i &lt; children.size(); i++){ traverse(children.get(i),res); } }} 200. 岛屿数量12345678910111213141516171819202122232425class Solution { public int numIslands(char[][] grid) { if(grid.length == 0 &amp;&amp; grid[0].length == 0) return 0; int count = 0; for(int i = 0 ; i &lt; grid.length; i++){ for(int j = 0; j &lt; grid[i].length;j++){ if(grid[i][j] == '1'){ count++; dfs(grid,i,j); } } } return count; } private void dfs(char[][] grid , int i , int j){ if(i &lt; 0 || i &gt;= grid.length || j &lt; 0 || j &gt;= grid[0].length || grid[i][j] == '0'){ return; } grid[i][j] = '0'; dfs(grid,i+1,j);// rigth dfs(grid,i-1,j);// left dfs(grid,i,j+1);// top dfs(grid,i,j-1);// bottom }} 529. 扫雷游戏123456789101112131415161718192021222324252627282930313233```4. 贪心算法贪心算法是一种在每一步选择中都采取在当下状态下最好或最优（最有利）的选择，从而希望导致结果是全局最好或最优的算法。关于贪心算法推荐博客[贪心算法](https://mp.weixin.qq.com/s/O935TaoHE9Eexwe_vSbRAg)适用场景：问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。这种子问题最优解称为最优子结构。[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)贪心策略：每次兑换都从最大的零钱开始兑换，找最少硬币兑换个数，直至兑换完毕。```javaclass Solution { private int res = Integer.MAX_VALUE; public int coinChange(int[] coins, int amount) { if(amount == 0) return 0; Arrays.sort(coins); change(coins,amount,coins.length - 1,0); return res == Integer.MAX_VALUE ? -1 : res; } public void change(int[] coins, int amount , int coinIndex ,int count){ if(amount == 0){ res = Math.min(res,count); return; } if(coinIndex &lt; 0) return; for(int k = amount/coins[coinIndex];k&gt;=0 &amp;&amp; k + count&lt; res ; k--){ change(coins,amount-(k*coins[coinIndex]),coinIndex - 1,count + k); } }} 122. 买卖股票的最佳时机 II 贪心策略：低买高卖，所有上涨日都买卖，下跌日都不进行买卖，这样的收益是最大的 123456789101112class Solution { public int maxProfit(int[] prices) { int profit = 0; for (int i = 1; i &lt; prices.length; i++) { int temp = prices[i] - prices[i - 1]; if (temp &gt; 0) { profit += temp; } } return profit; }} 二分查找 33. 搜索旋转排序数组1234567891011121314151617181920212223class Solution { public int search(int[] nums, int target) { int left = 0,right = nums.length - 1,mid = 0; while(left &lt;= right){ mid = left + (right - left)/2; if(target == nums[mid]) return mid; if(nums[left] &lt;= nums[mid]){ if(target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) { right = mid - 1; }else { left = mid + 1; } }else { if(target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]){ left = mid + 1; }else { right = mid - 1; } } } return -1; } } 69. x 的平方根1234567891011121314151617class Solution { public int mySqrt(int x) { if (x == 0) { return x; } long left = 1, right = x/2, mid = 1; while(left &lt; right){ mid = (left + right + 1) &gt;&gt;&gt; 1; if(mid*mid &gt; x){ right = mid - 1; }else{ left = mid; } } return (int)left; }} 74. 搜索二维矩阵 思路：二分法 将二维数组转换为虚拟一维数组，长度= m*n，每次找中间值 matrix[mid / n][mid % n] 与 target 对比； 12345678910111213141516171819202122class Solution { public boolean searchMatrix(int[][] matrix, int target) { if (matrix.length == 0) return false; int m = matrix.length; int n = matrix[0].length; int left = 0, right = m * n - 1; int mid = 0, num = 0; while (left &lt;= right) { mid = left + (right - left) / 2; num = matrix[mid / n][mid % n]; if (target == num) { return true; } if (target &gt; num) { left = mid + 1; } else { right = mid - 1; } } return false; }} 动态规划 关键点：动态规划和递归或者分治没有根本上的区别（关键看有无最优的子结构） 共性：都是找到重复子问题 差异性：最优子结构、中途可以淘汰次优解 经典案例：剑指 Offer 10- I. 斐波那契数列 1）、常规递归法：12345class Solution { public int fib(int n) { return n &lt;= 1 ? n : fib(n-1) + fib(n-2); }} 2）、保存中间值递归法：123456789101112131415class Solution { private int[] num; public int fib(int n) { num = new int[n+1]; return fibonacci(n); } public int fibonacci(int n){ if(n &lt;= 1) return n; if(num[n] == 0){ num[n] = fibonacci(n-1) + fibonacci(n-2); num[n] %= 1000000007; } return num[n]; }} 3）、自底向上递推12345678910111213class Solution { public int fib(int n) { if(n &lt;= 1) return n; int[] num = new int[n+1]; num[0] = 0; num[1] = 1; for(int i = 2; i &lt;= n; i++){ num[i] = num[i-1] + num[i-2]; num[i] %= 1000000007; } return num[n]; }} 4）、动态规划123456789101112class Solution { public int fib(int n) { if(n &lt;= 1) return n; int f0 = 0,f1 = 1,f2 = 0; for(int i = 2; i &lt;= n; i++){ f2 = (f0 + f1) %1000000007; f0 = f1; f1 = f2; } return f2; }} 62. 不同路径 思路：使用二维数组表示机器人行走区域，（0，0）表示起点start，dp[i][j]表示机器人行走到（i，j）坐标的路径条数，那么最终答案就是求机器人行走至终点（m-1,n-1）对应的dp[m-1][n-1]的值；已知机器人只能向下或向右行走，那么当机器人行走至第一行或第一列任意位置的路径条数都为 1，也就是dp[0][j] == 1，dp[i][0] == 1；同样也可推导出机器人行走至（i，j）位置只能从（i-1，j）点或（i，j-1）点走过来，那么dp[i][j] == dp[i-1][j] + dp[i][j-1]; 1234567891011121314class Solution { public int uniquePaths(int m, int n) { if(m == 0 || n == 0) return 0; int[][] dp = new int[m][n]; for(int i = 0; i &lt; m; i++) dp[i][0] = 1; for(int j = 0; j &lt; n; j++) dp[0][j] = 1; for(int i = 1; i &lt; m;i++){ for(int j = 1; j &lt; n; j++){ dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } return dp[m-1][n-1]; }} 优化版： 12345678910111213141516class Solution { public int uniquePaths(int m, int n) { if(m == 0 || n == 0) return 0; int[][] dp = new int[m][n]; for(int i = 0; i &lt; m;i++){ for(int j = 0; j &lt; n; j++){ if (i == 0 || j == 0){ dp[i][j] = 1; }else{ dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } } return dp[m-1][n-1]; }} 进阶：63. 不同路径 II 思路：不同于62题，机器人在行走过程中会碰到障碍物阻挡。同样的思路我们只需要处理无障碍物的情况； 123456789101112131415class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length , n = obstacleGrid[0].length; int[][] dp = new int[m][n]; for(int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++) dp[i][0] = 1; for(int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; j++) dp[0][j] = 1; for(int i = 1; i &lt; m;i++){ for(int j = 1; j &lt; n; j++){ if(obstacleGrid[i][j] == 0) dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } return dp[m-1][n-1]; }} 内存优化版： 12345678910111213141516class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length , n = obstacleGrid[0].length; int[] dp = new int[n+1]; dp[1] = 1; for(int i = 0; i &lt; m;i++){ for(int j = 1; j &lt;= n; j++){ if(obstacleGrid[i][j-1] == 1) dp[j] = 0; else dp[j] += dp[j-1]; } } return dp[n]; }} 高阶：980. 不同路径 III12345678910111213141516171819202122232425262728293031323334353637class Solution { private int res = 0; public int uniquePathsIII(int[][] grid) { // 初始化起点坐标和总步数,grid[i][j] == 2 也算步数，所以初始化为 1 int startX = 0, startY = 0, stepNum = 1; for(int i = 0; i &lt; grid.length; i++){ for(int j = 0; j &lt; grid[0].length; j++){ if(grid[i][j] == 1){ startX = i; startY = j; continue; } if(grid[i][j] == 0) stepNum++; } } dfs(startX,startY,stepNum,grid); return res; } public void dfs(int startX,int startY,int stepNum,int[][] grid){ // 边界处理 if(startX &lt; 0 || startX &gt;= grid.length || startY &lt; 0 || startY &gt;= grid[0].length || grid[startX][startY] == -1) return; // 结束条件 if(grid[startX][startY] == 2) { if(stepNum == 0)res++; return; }; // 将当前位置标记为已经过，不可重复 grid[startX][startY] = -1; // 依次统计上下左右方向走的步数 dfs(startX,startY-1,stepNum -1,grid); dfs(startX,startY+1,stepNum -1,grid); dfs(startX-1,startY,stepNum -1,grid); dfs(startX+1,startY,stepNum -1,grid); // 结束本次遍历后将当前位置还原为可经过路线，以便下次统计 grid[startX][startY] = 0; }} 1143. 最长公共子序列12345678910111213141516class Solution { public int longestCommonSubsequence(String text1, String text2) { int l1 = text1.length(),l2 = text2.length(); int[][] dp = new int[l1+1][l2+1]; for(int i = 0; i &lt; l1; i++){ for(int j = 0; j &lt; l2; j++){ if(text1.charAt(i) == text2.charAt(j)){ dp[i+1][j+1] = dp[i][j] + 1; }else{ dp[i+1][j+1] = Math.max(dp[i+1][j],dp[i][j+1]); } } } return dp[l1][l2]; }} 70. 爬楼梯 保存中间值： 123456789101112class Solution { public int climbStairs(int n) { if(n&lt;=2) return n; int[] sum = new int[n+1]; sum[1] = 1; sum[2] = 2; for(int i = 3; i &lt;= n;i++){ sum[i] = sum[i-1] + sum[i-2]; } return sum[n]; }} 动态规划：dp方程:f(n) = f(n-1) + f(n-2); 123456789101112class Solution { public int climbStairs(int n) { if(n &lt;= 2) return n; int f1 = 1,f2 = 2,f3 = 0; for(int i = 3;i &lt;= n; i++){ f3= f1 + f2; f1 = f2; f2 = f3; } return f3; }} 120. 三角形最小路径和 思路： 1234567891011class Solution { public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) { int[] path = new int[triangle.size() + 1]; for(int i = triangle.size() -1; i &gt;= 0;--i){ for(int j = 0; j &lt; triangle.get(i).size();++j){ path[j] = Math.min(path[j],path[j+1]) + triangle.get(i).get(j); } } return path[0]; }} 53. 最大子序和123456789101112131415class Solution { public int maxSubArray(int[] nums) { int res = nums[0]; int sum = 0; for(int i = 0; i &lt; nums.length; i++){ if(sum &gt; 0){ sum += nums[i]; }else{ sum = nums[i]; } res = Math.max(res,sum); } return res; }} 152. 乘积最大子数组 思路：当值为负数时，会令最大乘积变为最小乘积或最小乘积变为最大乘积 12345678910111213141516class Solution { public int maxProduct(int[] nums) { int proMin = 1 ,proMax = 1 ,max = Integer.MIN_VALUE; for(int i = 0; i &lt; nums.length; i++){ if(nums[i] &lt; 0){ int temp = proMax; proMax = proMin; proMin = temp; } proMin = Math.min(proMin*nums[i],nums[i]); proMax = Math.max(proMax*nums[i],nums[i]); max = Math.max(max,proMax); } return max; }}","link":"/2021/01/31/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"title":"第一章 影响力的武器 ——武装自己","text":"凡事都应当尽可能地简单，而不是较为简单。——阿尔伯特·爱因斯坦 实验案例：雌火鸡对小火鸡的“叽叽”声很敏感，即使这个声音是实验模拟发出的，它也会机械重复的执行自己作为母亲的职责。 固定行为模式，这些模式的一个基本特点是：每一次，构成模式的所有行为几乎都是按相同的方式、相同的顺序发生的。 人类也有相似的自动反应模式，比如：我们在要别人帮忙的时候，要是能给一个理由，成功的概率会更大，因为人就是单纯地喜欢做事有个理由。 大部分影响力武器具备的相同要素： 这类武器有能力激活一种近似机械化的过程 只要掌握了触发这种过程的能力，人们就能从中渔利 使用者能借助这些自动影响力武器的威力，这种武器就好像一根沉甸甸的大棒，只要用了它，就能让另一个人乖乖就范。 例如：人类认知中的“对比原理”，两样东西一前一后地展示出来，我们怎样看待其间的区别，对比原理是有影响的。简单地说，要是第二样东西跟第一样东西有着相当的不同，那么，我们往往会认为两者的区别比实际上更大。","link":"/2021/01/31/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%BD%B1%E5%93%8D%E5%8A%9B%E7%9A%84%E6%AD%A6%E5%99%A8%20%E2%80%94%E2%80%94%E6%AD%A6%E8%A3%85%E8%87%AA%E5%B7%B1/"},{"title":"第二章 互惠 ——给予，索取，再索取","text":"每一笔债都还得干干净净，就好像上帝他老人家是债主。——拉尔夫·沃尔多·爱默生互惠原理，别人给了我们什么好处，我们理应有义务在将来回报别人的好意、礼物、邀请等。 1、互惠原理如何起作用？ 我们每个人从小听人教导，不能辜负了它，我们每个人也都知道，凡是有人敢违背它，必然要受到社会的制裁和嘲笑。由于普通人大多讨厌一味索取、从不回报的家伙，我们往往会想法设法地避免被别人看成是揩油王、忘恩负义的王八蛋，或是不劳而获的懒虫。 2、互惠原理在人类社会中到处都能运用，而且所向披靡，比如政客间和生意场的请客吃饭送礼，以及经济活动中的应用，，比如超市免费赠送样本体验等。 3、人类可利用互惠原理触发不对等交换，别人最初给予的小小恩惠，能够让当事人产生亏欠感，最终回报以大得多的恩惠。 4、互惠式让步，高阶使用技巧，先提大要求后提小要求。互惠原理和直觉对比原理的结合。 5、如何抵挡使用互惠原理的敌人？ 首先要学会辨别别人的恩惠是真诚的善意还是虚假的策略，如果是善意的就以善意回报，否则就拒绝。","link":"/2021/01/31/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E4%BA%92%E6%83%A0%20%E2%80%94%E2%80%94%E7%BB%99%E4%BA%88%EF%BC%8C%E7%B4%A2%E5%8F%96%EF%BC%8C%E5%86%8D%E7%B4%A2%E5%8F%96/"},{"title":"第三章 承诺和一致——脑子里的怪物","text":"一开始就拒绝，比最后反悔要容易。——达芬奇 人人都有一种言行一致（同时也显得言行一致）的愿望。一旦我们作出了一个选择，或采取了某种立场，我们立刻就会碰到来自内心和外部的压力，迫使我们按照承诺的那样去做。在这样的压力之下，我们会想方设法地以行动证明自己先前的决定是正确的。我们所有人都会一次次地欺骗自己，以便在作出选择之后，坚信自己做得没错。 这就是承诺和一致原则对人的行为的强大指引力量。 言出必行，在大多数环境下，言行一致都是很有价值也很合适的。依照人们的普遍感觉，言行不一是一种不可取的人格特性。信仰、言语和行为前后不一的人，会被看成是脑筋混乱、表里不一，甚至精神有毛病的。另一方面，言行高度一致大多跟个性坚强、智力出众挂钩，他是逻辑性、稳定性和诚实感的核心。 1、为什么我们要努力做到L言行一致？ 因为日常生活的纷繁复杂对我们的精力和能力都提出了苛刻的要求，有了一致性我们就能以相对轻松、高效的便利方式来应对一切了。是我们懒惰的大脑想避免思考的一种处理方式。 2、人们是如何利用承诺和一致原则来达到自己的目的的呢？ 承诺是关键，通过各种直接的或间接的方式诱使人们做出承诺，那么人自然就想要倔强地按照之前的承诺去保持一致从而完成达到自己的目的。而且为一个承诺付出的努力越多，它对承诺者的影响也就越大。 3、如何避免自己受承诺和一致原则的影响？ 尽管保持言行一致是好品质，但是这只适用于大多数情况，在某些地方我们也必须避免愚蠢的死脑筋。因为我们不假思索自动保持一致的反应，正是某些人耍花招利用它在我们身上谋利的策略。","link":"/2021/01/31/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%89%BF%E8%AF%BA%E5%92%8C%E4%B8%80%E8%87%B4%E2%80%94%E2%80%94%E8%84%91%E5%AD%90%E9%87%8C%E7%9A%84%E6%80%AA%E7%89%A9/"},{"title":"第四章 社会认同——我们就是真理","text":"在人人想法都差不多的地方，没人会想得太多——沃尔特·李普曼 社会认同原理：在判断何为正确时，我们会根据别人的意见行事。 我们对社会认同的反应方式完全是无意识的、条件反射式的。 1、什么时候会容易产生社会认同？ 一般来说，在我们自己不确定、情况不明或含糊不清，意外性太大的时候，我们最有可能觉得别人的行为是正确的。但是在审视他人反应，消除不确定性的过程中，我们很容易忽视一点微妙而重要的事实：其他人有可能也在寻找社会证据。尤其是在局面模糊不清的时候，人人都倾向于观察别人在做什么，这会导致一种叫“多元无知”的有趣现象。 2、社会认同原理能发挥出最大的影响力的一条适用条件：相似性。我们会根据他人的行为来判断自己怎么做才合适，尤其是在我们觉得这些人跟自己相似的时候。 3、如何拒绝？ 如果在情况不明或含糊不清时，应该及时关闭社会认同开关，谨防同类的伪造数据和虚假证据。面对明显时伪造的社会证据，我们只要多保持一点警惕感，就能很好地保护自己了。首先，我们似乎持有这样的假设：要是很多人在做相同的事情，他们必然知道一些我们不知道的事情。尤其在我们并不确定的时候，我们很乐意对这种集体智慧投入极大的信任。其次，人群很多时候都是错的，因为群体的成员并不是根据优势信息才采取行动，而只是基于社会认同原理在做反应。","link":"/2021/01/31/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E7%A4%BE%E4%BC%9A%E8%AE%A4%E5%90%8C%E2%80%94%E2%80%94%E6%88%91%E4%BB%AC%E5%B0%B1%E6%98%AF%E7%9C%9F%E7%90%86/"},{"title":"第四章 社会认同——我们就是真理","text":"辩护律师的主要任务就是让陪审团喜欢他的客户 —— 克拉伦斯·达罗 我们大多数人总是更容易答应自己认识和喜欢的人所提出的要求。 1、我喜欢你的理由 外表魅力：长的好看的人在社交中占有优势，我们会自动给长得好看的人添加一些正面特点，比如有才华、善良、诚实和聪明等。而且我们在作出这些判断的时候并没有意识到外表魅力在其中发挥的作用。 相似性：我们喜欢与自己相似的人。不管相似之处是在观点、个性、背景还是生活方式上，我们总有这样的倾向。 恭维：我们特别喜欢听人恭维奉承 接触与合作：我们更喜欢自己熟悉的人或者相互之间有合作的人 条件反射和关联：我们总喜欢给自己带来好消息的人，讨厌给自己带来坏消息的人。人们深知关联原理的奥妙，并努力把自己跟积极的事情联系起来，跟消极的事情保持距离。 2、如何拒绝？ 不去压抑好感因素产生的影响力，听凭这些因素发挥力量，然后用这股力量反过来对付那些想从中获利的人。","link":"/2021/01/31/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%96%9C%E5%A5%BD%20%E2%80%94%E2%80%94%E5%8F%8B%E5%A5%BD%E7%9A%84%E7%AA%83%E8%B4%BC/"}],"tags":[{"name":"读书","slug":"读书","link":"/tags/%E8%AF%BB%E4%B9%A6/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"编程","slug":"编程","link":"/tags/%E7%BC%96%E7%A8%8B/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"读书","slug":"读书","link":"/categories/%E8%AF%BB%E4%B9%A6/"},{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"}]}