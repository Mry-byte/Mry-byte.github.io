{"pages":[],"posts":[{"title":"算法学习总结","text":"1、什么是算法？算法就是计算或者解决问题的步骤。我们可以把它想象成食谱。要想做出特定的料理，就要遵循食谱上的步骤；同理，要想用计算机解决特定的问题，就要遵循算法。这里所说的特定问题多种多样，比如“将随意排列的数字按从小到大的顺序重新排列”“寻找出发点到目的地的最短路径”，等等。食谱和算法之间最大的区别就在于算法是严密的。食谱上经常会有描述得比较模糊的部分，而算法的步骤都是用数学方式来描述的，所以十分明确。算法和程序有些相似，区别在于程序是以计算机能够理解的编程语言编写而成的，可以在计算机上运行，而算法是以人类能够理解的方式描述的，用于编写程序之前。不过，在这个过程中到哪里为止是算法、从哪里开始是程序，并没有明确的界限。就算使用同一个算法，编程语言不同，写出来的程序也不同；即便使用相同的编程语言，写程序的人不同，那么写出来的程序也是不同的。 摘录自《我的第一本算法》，这本书特别适合新手学习，以图形的方式来讲解，易于理解。 2、数据结构什么是数据结构？ 答：数据存储于内存中，决定了数据顺序和位置关系的便是“数据结构”。 数组（Array） 数据按顺序存储在内存的连续空间内。 链表（Linked List） 是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 栈（Stack） 栈也是一种数据呈线性排列的数据结构，遵循后进先出原则 队列（Queue） 普通队列：队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作。 双端队列（Deque）：入口和出口都可以入队和出队 优先队列（PriorityQueue）：根据优先级出队 哈希表（Hash table） 哈希表（Hash table），也叫散列表，是根据关键码值（Key value）而直接进行访问的数据结构。 树（Tree） 一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。 特点： 每个节点都只有有限个子节点或无子节点 没有父节点的节点称为根节点 每一个非根节点有且仅有一个父节点 除了根节点外，每个子节点可以分为多个不相交的子树 树中没有环路 堆（Heap） 可以迅速找到一堆数中的最大或者最小值的数据结构。将根节点最大的堆叫做大顶堆或大根堆，根节点最小的堆叫做小顶堆或小根堆。常见的堆有二叉堆、斐波那契堆等。 满足下列性质： 堆中任意节点的值总是&gt;=或&lt;=其子节点的值 堆总是一颗完全二叉树 图（Graph） 图结构也是一种非线性数据结构，并且每个数据元素之间可以任意关联。 一个典型的图结构包括如下两个部分： 顶点（Vertex）：图中的数据元素 边（Edge）：图中连接这些顶点的线 存储方法：邻接矩阵、邻接表 邻接矩阵 邻接表 关于数据结构总结脑图附件 数据结构和算法-思维导图.pdf 3、算法 递归（Recursion） 递归也是一种循环，不过是通过函数体自己调用自己来进行的循环 简单示例：计算 n！ 12345// n！= 1*2*3*...*ndef Factorial(n): if n&lt;=1: return 1 return n*Factorial(n-1) 代码模板（Java） 123456789101112public void recur(int level , int param){ // terminator if (level &gt; MAX_LEVEL){ // process result retutn; } // process current logic process(level,param); // drill down recur(level+1,newParam); // restore current status} 爬楼梯（阿里巴巴、腾讯、字节跳动在半年内面试常考） 常规写法： 123456public int climbStairs(int n) { if(n &lt;= 2){ return n; } return climbStairs(n-1) + climbStairs(n-2);} 升级版本： 123456789public int climbStairs(int n) { int f1 = 1, f2 = 2, f3 = 0; for (int i = 3; i &lt;= n; i++) { f3 = f1 + f2; f1 = f2; f2 = f3; } return f3;} 括号生成(字节跳动在半年内面试中考过)123456789101112131415161718192021222324252627public List&lt;String&gt; generateParenthesis(int n) { List&lt;String&gt; res = new ArrayList&lt;&gt;(); if (n &lt; 1) { return res; } generate(0, 0, &quot;&quot;, res, n); return res;}public void generate(int left, int right, String s, List&lt;String&gt; res, int n) { // 1.递归终结条件 if (left == n &amp;&amp; right == n) { res.add(s); return; } // 2.处理当前层 // 右括号多余左括号，说明已经是无效括号组合 if (left &lt; right) { return; } // 3.下探下一层 // 如果左括号还能添加,右括号不变 if (left &lt; n) generate(left + 1, right, s + &quot;(&quot;, res, n); // 如果右括号还能添加，左括号不变 if (right &lt; n) generate(left, right + 1, s + &quot;)&quot;, res, n);} 翻转二叉树(谷歌、字节跳动、Facebook 在半年内面试中考过)12345678910public TreeNode invertTree(TreeNode root) { if (root == null) return null; TreeNode left = root.left; root.left = root.right; root.right = left; invertTree(root.left); invertTree(root.right); return root;} 验证二叉搜索树（亚马逊、微软、Facebook 在半年内面试中考过）1234567891011// 中序遍历访问，先遍历左子树，如果有当前节点值&lt;=前节点值，不满足条件private TreeNode per;public boolean isValidBST(TreeNode root) { if (root == null) return true; if (!isValidBST(root.left)) return false; if (per != null &amp;&amp; root.val &lt;= per.val) return false; per = root; if (!isValidBST(root.right)) return false; return true;} 二叉树的最大深度（亚马逊、微软、字节跳动在半年内面试中考过）123456class Solution { public int maxDepth(TreeNode root) { if(root == null) return 0; return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1; }} 二叉树的最小深度（Facebook、字节跳动、谷歌在半年内面试中考过）123456789class Solution { public int minDepth(TreeNode root) { if(root == null) return 0; if(root.left == null &amp;&amp; root.right ==null) return 1; if(root.left == null || root.right == null) return minDepth(root.left) + minDepth(root.right) + 1; return Math.min(minDepth(root.left),minDepth(root.right)) + 1; }} 二叉树的序列化与反序列化（Facebook、亚马逊在半年内面试常考）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */public class Codec { // Encodes a tree to a single string. public String serialize(TreeNode root) { StringBuilder str = new StringBuilder(); // BFS return traversTree(root,str); } // Decodes your encoded data to tree. public TreeNode deserialize(String data) { if(data.isEmpty() || data.equals(&quot;#&quot;)){ return null; } Queue&lt;TreeNode&gt; queue = new LinkedList(); String[] nodes = data.split(&quot;,&quot;); TreeNode root = new TreeNode(Integer.valueOf(nodes[0])); queue.add(root); for(int i = 1; i &lt; nodes.length ; i++){ TreeNode p = queue.poll(); if(!&quot;#&quot;.equals(nodes[i])){ TreeNode left = new TreeNode(Integer.valueOf(nodes[i])); p.left = left; queue.add(left); } if(!&quot;#&quot;.equals(nodes[++i])){ TreeNode right = new TreeNode(Integer.valueOf(nodes[i])); p.right = right; queue.add(right); } } return root; } public String traversTree(TreeNode root,StringBuilder str){ if(root == null) { return &quot;#&quot;; } Queue&lt;TreeNode&gt; queue = new LinkedList(); queue.add(root); while(!queue.isEmpty()){ TreeNode node = queue.poll(); if(node == null){ str.append(&quot;#&quot;+&quot;,&quot;); continue; } str.append(node.val+&quot;,&quot;); queue.add(node.left); queue.add(node.right); } return str.toString(); }}// Your Codec object will be instantiated and called as such:// Codec ser = new Codec();// Codec deser = new Codec();// TreeNode ans = deser.deserialize(ser.serialize(root)); 课后作业： 二叉树的最近公共祖先（Facebook 在半年内面试常考）123456789101112class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null || root == p || root == q) { return root; } TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if(left == null) return right; if(right == null) return left; return root; }} 从前序与中序遍历序列构造二叉树（字节跳动、亚马逊、微软在半年内面试中考过）123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { private Map&lt;Integer, Integer&gt; indexMap = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] preorder, int[] inorder) { if (preorder.length == 0 || inorder.length == 0) { return null; } int n = preorder.length; // 将中序遍历的数组保存在map中，以便快速查询节点对应的下标 for (int i = 0; i &lt; n; i++) { indexMap.put(inorder[i], i); } return buildTreeHelper(preorder, inorder, 0, n - 1, 0, n - 1); } private TreeNode buildTreeHelper(int[] preorder, int[] inorder, int preLeft, int preRight, int inLeft, int inRight) { // 递归结束条件，数组切分完为止 if (preLeft &gt; preRight) { return null; } // 前序遍历的第一个节点就是根节点 int perRoot = preLeft; // 查询根节点在中序遍历中的下标位置 int index_root = (int)indexMap.get(preorder[perRoot]); // 创建根节点 TreeNode root = new TreeNode(preorder[perRoot]); // 计算左子树中的节点数目，以index_root下标为中心将前序遍历数组inorder切分为左子树、右子树两部分 int left_size = index_root - inLeft; // 递归构造左子树 root.left = buildTreeHelper(preorder, inorder, preLeft + 1, preLeft + left_size, inLeft, index_root - 1); // 递归构造右子树 root.right = buildTreeHelper(preorder, inorder, preLeft + left_size + 1, preRight, index_root + 1, inRight); return root; }} 组合（微软、亚马逊、谷歌在半年内面试中考过）123456789101112131415161718class Solution { public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); dfs(n, k, 1, new ArrayList&lt;Integer&gt;(), res); return res; } private void dfs(int n, int k, int start, ArrayList&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; res) { if (k == 0) { res.add(new ArrayList&lt;&gt;(list)); return; } for (int i = start; i &lt;= n - k + 1; i++) { list.add(i); dfs9(n, k - 1, i + 1, list, res); list.remove(list.size() - 1); } }} 全排列（字节跳动在半年内面试常考）123456789101112131415161718192021222324class Solution { public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(); boolean[] used = new boolean[nums.length]; dfs(nums, 0, path, used, res); return res; } private void dfs(int[] nums, int level, Deque&lt;Integer&gt; path, boolean[] used, List&lt;List&lt;Integer&gt;&gt; res) { if (level == nums.length) { res.add(new ArrayList&lt;&gt;(path)); return; } for (int j = 0; j &lt; nums.length; j++) { if (!used[j]) { path.addLast(nums[j]); used[j] = true; dfs(nums, level + 1, path, used, res); used[j] = false; path.removeLast(); } } }} 全排列 II （亚马逊、字节跳动、Facebook 在半年内面试中考过）12345678910111213141516171819202122232425262728293031class Solution { public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(); boolean[] used = new boolean[nums.length]; // 排序（升序或者降序都可以），排序是剪枝的前提 Arrays.sort(nums); dfs(nums, 0, path, used, res); return res; } private void dfs(int[] nums, int level, Deque&lt;Integer&gt; path, boolean[] used, List&lt;List&lt;Integer&gt;&gt; res) { if (level == nums.length) { res.add(new ArrayList&lt;&gt;(path)); return; } for (int j = 0; j &lt; nums.length; j++) { if (used[j]) { continue; } // 剪枝，取掉重复的搜索结果 if (j &gt; 0 &amp;&amp; nums[j] == nums[j - 1] &amp;&amp; !used[j - 1]) { continue; } path.addLast(nums[j]); used[j] = true; dfs(nums, level + 1, path, used, res); used[j] = false; path.removeLast(); } }} 分治、回溯 分治代码模板1234567891011private static int divide_conquer(Problem problem, ) { if (problem == NULL) { int res = process_last_result(); return res; } subProblems = split_problem(problem) res0 = divide_conquer(subProblems[0]) res1 = divide_conquer(subProblems[1]) result = process_result(res0, res1); return result;} 50. Pow(x, n)12345678910class Solution { public double myPow(double x, int n) { if(n == 0) return 1; if(n == 1) return x; if(n == -1) return 1/x; double helf = myPow(x,n/2); double rest = myPow(x,n%2); return rest*helf*helf; }} 78. 子集123456789101112131415class Solution { public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); subsets(nums,0,new ArrayList(),result); return result; } public void subsets(int[] nums,int index ,List&lt;Integer&gt; list,List&lt;List&lt;Integer&gt;&gt; result){ result.add(new ArrayList&lt;&gt;(list)); for(int i = index;i&lt;nums.length;i++){ list.add(nums[i]); subsets(nums,i + 1,list,result); list.remove(list.size() - 1); } }} 169. 多数元素 思路：排序 123456class Solution { public int majorityElement(int[] nums) { Arrays.sort(nums); return nums[nums.length/2]; }} 思路：摩尔投票法相同的元素则 票数+1，遇到不同的则 票数-1 因为“多数元素”个数 &gt; n/2 ，则其余元素个数 &lt;= n/2 这样“多数元素”的票数就能抵消掉所有其余元素的票数，最终剩余的就是票数最多的元素。 1234567891011121314151617181920class Solution { public int majorityElement(int[] nums) { // 默认选中第一个元素为候选人，票数默认10 int count = 1; int choose = nums[0]; for (int i = 1; i &lt; nums.length; i++) { if (nums[i] == choose) { count++; } else { count--; } // 当票数为0时，需要更换候选人，票数也重置为1 ，开始重新投票 if (count == 0) { choose = nums[i]; count = 1; } } return choose; }} 17. 电话号码的字母组合 思路：dfs+回溯 123456789101112131415161718192021222324252627class Solution { public List&lt;String&gt; letterCombinations(String digits) { List&lt;String&gt; res = new ArrayList(); if (digits.length() == 0) return res; Map&lt;Character, String&gt; keyboard = new HashMap&lt;&gt;(); keyboard.put('2', &quot;abc&quot;); keyboard.put('3', &quot;def&quot;); keyboard.put('4', &quot;ghi&quot;); keyboard.put('5', &quot;jkl&quot;); keyboard.put('6', &quot;mno&quot;); keyboard.put('7', &quot;pqrs&quot;); keyboard.put('8', &quot;tuv&quot;); keyboard.put('9', &quot;wxyz&quot;); search(digits, 0, &quot;&quot;, res, keyboard); return res; } public void search(String digits, int level, String s, List&lt;String&gt; res, Map&lt;Character, String&gt; keyboard) { if (level == digits.length()) { res.add(s); return; } String letter = keyboard.get(digits.charAt(level)); for (int i = 0; i &lt; letter.length(); i++) { search(digits, level + 1, s + letter.charAt(i), res, keyboard); } }} 51. N 皇后12345678910111213141516171819202122232425262728```3. 深度优先搜索、广度优先搜索* DFS代码模板中序遍历```java//Javapublic List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; allResults = new ArrayList&lt;&gt;(); if(root==null){ return allResults; } travel(root,0,allResults); return allResults;}public void travel(TreeNode root,int level,List&lt;List&lt;Integer&gt;&gt; results){ if(results.size()==level){ results.add(new ArrayList&lt;&gt;()); } results.get(level).add(root.val); if(root.left!=null){ travel(root.left,level+1,results); } if(root.right!=null){ travel(root.right,level+1,results); }} BFS代码模板 层序遍历 123456789101112131415161718192021222324public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; allResults = new ArrayList&lt;&gt;(); if (root == null) { return allResults; } Queue&lt;TreeNode&gt; nodes = new LinkedList&lt;&gt;(); nodes.add(root); while (!nodes.isEmpty()) { int size = nodes.size(); List&lt;Integer&gt; results = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; size; i++) { TreeNode node = nodes.poll(); results.add(node.val); if (node.left != null) { nodes.add(node.left); } if (node.right != null) { nodes.add(node.right); } } allResults.add(results); } return allResults;} 102. 二叉树的层序遍历1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty()){ int size = queue.size(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i = 0 ; i &lt; size; i++){ TreeNode node = queue.poll(); list.add(node.val); if(node.left != null) queue.add(node.left); if(node.right != null) queue.add(node.right); } res.add(list); } return res; }} 515. 在每个树行中找最大值1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public List&lt;Integer&gt; largestValues(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty()){ int size = queue.size(); int max = Integer.MIN_VALUE; for(int i = 0;i &lt; size;i++){ TreeNode node = queue.poll(); max = Math.max(max,node.val); if(node.left != null) queue.add(node.left); if(node.right != null) queue.add(node.right); } res.add(max); } return res; }} 589. N叉树的前序遍历123456789101112131415161718192021222324252627282930313233/*// Definition for a Node.class Node { public int val; public List&lt;Node&gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&lt;Node&gt; _children) { val = _val; children = _children; }};*/class Solution { public List&lt;Integer&gt; preorder(Node root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; traverse(root,res); return res; } private void traverse(Node node,List&lt;Integer&gt; res){ if(node == null){ return; } res.add(node.val); List&lt;Node&gt; children = node.children; for(int i = 0 ; i &lt; children.size(); i++){ traverse(children.get(i),res); } }} 200. 岛屿数量12345678910111213141516171819202122232425class Solution { public int numIslands(char[][] grid) { if(grid.length == 0 &amp;&amp; grid[0].length == 0) return 0; int count = 0; for(int i = 0 ; i &lt; grid.length; i++){ for(int j = 0; j &lt; grid[i].length;j++){ if(grid[i][j] == '1'){ count++; dfs(grid,i,j); } } } return count; } private void dfs(char[][] grid , int i , int j){ if(i &lt; 0 || i &gt;= grid.length || j &lt; 0 || j &gt;= grid[0].length || grid[i][j] == '0'){ return; } grid[i][j] = '0'; dfs(grid,i+1,j);// rigth dfs(grid,i-1,j);// left dfs(grid,i,j+1);// top dfs(grid,i,j-1);// bottom }} 529. 扫雷游戏123456789101112131415161718192021222324252627282930313233```4. 贪心算法贪心算法是一种在每一步选择中都采取在当下状态下最好或最优（最有利）的选择，从而希望导致结果是全局最好或最优的算法。关于贪心算法推荐博客[贪心算法](https://mp.weixin.qq.com/s/O935TaoHE9Eexwe_vSbRAg)适用场景：问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。这种子问题最优解称为最优子结构。[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)贪心策略：每次兑换都从最大的零钱开始兑换，找最少硬币兑换个数，直至兑换完毕。```javaclass Solution { private int res = Integer.MAX_VALUE; public int coinChange(int[] coins, int amount) { if(amount == 0) return 0; Arrays.sort(coins); change(coins,amount,coins.length - 1,0); return res == Integer.MAX_VALUE ? -1 : res; } public void change(int[] coins, int amount , int coinIndex ,int count){ if(amount == 0){ res = Math.min(res,count); return; } if(coinIndex &lt; 0) return; for(int k = amount/coins[coinIndex];k&gt;=0 &amp;&amp; k + count&lt; res ; k--){ change(coins,amount-(k*coins[coinIndex]),coinIndex - 1,count + k); } }} 122. 买卖股票的最佳时机 II 贪心策略：低买高卖，所有上涨日都买卖，下跌日都不进行买卖，这样的收益是最大的 123456789101112class Solution { public int maxProfit(int[] prices) { int profit = 0; for (int i = 1; i &lt; prices.length; i++) { int temp = prices[i] - prices[i - 1]; if (temp &gt; 0) { profit += temp; } } return profit; }} 二分查找 33. 搜索旋转排序数组1234567891011121314151617181920212223class Solution { public int search(int[] nums, int target) { int left = 0,right = nums.length - 1,mid = 0; while(left &lt;= right){ mid = left + (right - left)/2; if(target == nums[mid]) return mid; if(nums[left] &lt;= nums[mid]){ if(target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) { right = mid - 1; }else { left = mid + 1; } }else { if(target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]){ left = mid + 1; }else { right = mid - 1; } } } return -1; } } 69. x 的平方根1234567891011121314151617class Solution { public int mySqrt(int x) { if (x == 0) { return x; } long left = 1, right = x/2, mid = 1; while(left &lt; right){ mid = (left + right + 1) &gt;&gt;&gt; 1; if(mid*mid &gt; x){ right = mid - 1; }else{ left = mid; } } return (int)left; }} 74. 搜索二维矩阵 思路：二分法 将二维数组转换为虚拟一维数组，长度= m*n，每次找中间值 matrix[mid / n][mid % n] 与 target 对比； 12345678910111213141516171819202122class Solution { public boolean searchMatrix(int[][] matrix, int target) { if (matrix.length == 0) return false; int m = matrix.length; int n = matrix[0].length; int left = 0, right = m * n - 1; int mid = 0, num = 0; while (left &lt;= right) { mid = left + (right - left) / 2; num = matrix[mid / n][mid % n]; if (target == num) { return true; } if (target &gt; num) { left = mid + 1; } else { right = mid - 1; } } return false; }} 动态规划 关键点：动态规划和递归或者分治没有根本上的区别（关键看有无最优的子结构） 共性：都是找到重复子问题 差异性：最优子结构、中途可以淘汰次优解 经典案例：剑指 Offer 10- I. 斐波那契数列 1）、常规递归法：12345class Solution { public int fib(int n) { return n &lt;= 1 ? n : fib(n-1) + fib(n-2); }} 2）、保存中间值递归法：123456789101112131415class Solution { private int[] num; public int fib(int n) { num = new int[n+1]; return fibonacci(n); } public int fibonacci(int n){ if(n &lt;= 1) return n; if(num[n] == 0){ num[n] = fibonacci(n-1) + fibonacci(n-2); num[n] %= 1000000007; } return num[n]; }} 3）、自底向上递推12345678910111213class Solution { public int fib(int n) { if(n &lt;= 1) return n; int[] num = new int[n+1]; num[0] = 0; num[1] = 1; for(int i = 2; i &lt;= n; i++){ num[i] = num[i-1] + num[i-2]; num[i] %= 1000000007; } return num[n]; }} 4）、动态规划123456789101112class Solution { public int fib(int n) { if(n &lt;= 1) return n; int f0 = 0,f1 = 1,f2 = 0; for(int i = 2; i &lt;= n; i++){ f2 = (f0 + f1) %1000000007; f0 = f1; f1 = f2; } return f2; }} 62. 不同路径 思路：使用二维数组表示机器人行走区域，（0，0）表示起点start，dp[i][j]表示机器人行走到（i，j）坐标的路径条数，那么最终答案就是求机器人行走至终点（m-1,n-1）对应的dp[m-1][n-1]的值；已知机器人只能向下或向右行走，那么当机器人行走至第一行或第一列任意位置的路径条数都为 1，也就是dp[0][j] == 1，dp[i][0] == 1；同样也可推导出机器人行走至（i，j）位置只能从（i-1，j）点或（i，j-1）点走过来，那么dp[i][j] == dp[i-1][j] + dp[i][j-1]; 1234567891011121314class Solution { public int uniquePaths(int m, int n) { if(m == 0 || n == 0) return 0; int[][] dp = new int[m][n]; for(int i = 0; i &lt; m; i++) dp[i][0] = 1; for(int j = 0; j &lt; n; j++) dp[0][j] = 1; for(int i = 1; i &lt; m;i++){ for(int j = 1; j &lt; n; j++){ dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } return dp[m-1][n-1]; }} 优化版： 12345678910111213141516class Solution { public int uniquePaths(int m, int n) { if(m == 0 || n == 0) return 0; int[][] dp = new int[m][n]; for(int i = 0; i &lt; m;i++){ for(int j = 0; j &lt; n; j++){ if (i == 0 || j == 0){ dp[i][j] = 1; }else{ dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } } return dp[m-1][n-1]; }} 进阶：63. 不同路径 II 思路：不同于62题，机器人在行走过程中会碰到障碍物阻挡。同样的思路我们只需要处理无障碍物的情况； 123456789101112131415class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length , n = obstacleGrid[0].length; int[][] dp = new int[m][n]; for(int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++) dp[i][0] = 1; for(int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; j++) dp[0][j] = 1; for(int i = 1; i &lt; m;i++){ for(int j = 1; j &lt; n; j++){ if(obstacleGrid[i][j] == 0) dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } return dp[m-1][n-1]; }} 内存优化版： 12345678910111213141516class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length , n = obstacleGrid[0].length; int[] dp = new int[n+1]; dp[1] = 1; for(int i = 0; i &lt; m;i++){ for(int j = 1; j &lt;= n; j++){ if(obstacleGrid[i][j-1] == 1) dp[j] = 0; else dp[j] += dp[j-1]; } } return dp[n]; }} 高阶：980. 不同路径 III12345678910111213141516171819202122232425262728293031323334353637class Solution { private int res = 0; public int uniquePathsIII(int[][] grid) { // 初始化起点坐标和总步数,grid[i][j] == 2 也算步数，所以初始化为 1 int startX = 0, startY = 0, stepNum = 1; for(int i = 0; i &lt; grid.length; i++){ for(int j = 0; j &lt; grid[0].length; j++){ if(grid[i][j] == 1){ startX = i; startY = j; continue; } if(grid[i][j] == 0) stepNum++; } } dfs(startX,startY,stepNum,grid); return res; } public void dfs(int startX,int startY,int stepNum,int[][] grid){ // 边界处理 if(startX &lt; 0 || startX &gt;= grid.length || startY &lt; 0 || startY &gt;= grid[0].length || grid[startX][startY] == -1) return; // 结束条件 if(grid[startX][startY] == 2) { if(stepNum == 0)res++; return; }; // 将当前位置标记为已经过，不可重复 grid[startX][startY] = -1; // 依次统计上下左右方向走的步数 dfs(startX,startY-1,stepNum -1,grid); dfs(startX,startY+1,stepNum -1,grid); dfs(startX-1,startY,stepNum -1,grid); dfs(startX+1,startY,stepNum -1,grid); // 结束本次遍历后将当前位置还原为可经过路线，以便下次统计 grid[startX][startY] = 0; }} 1143. 最长公共子序列12345678910111213141516class Solution { public int longestCommonSubsequence(String text1, String text2) { int l1 = text1.length(),l2 = text2.length(); int[][] dp = new int[l1+1][l2+1]; for(int i = 0; i &lt; l1; i++){ for(int j = 0; j &lt; l2; j++){ if(text1.charAt(i) == text2.charAt(j)){ dp[i+1][j+1] = dp[i][j] + 1; }else{ dp[i+1][j+1] = Math.max(dp[i+1][j],dp[i][j+1]); } } } return dp[l1][l2]; }} 70. 爬楼梯 保存中间值： 123456789101112class Solution { public int climbStairs(int n) { if(n&lt;=2) return n; int[] sum = new int[n+1]; sum[1] = 1; sum[2] = 2; for(int i = 3; i &lt;= n;i++){ sum[i] = sum[i-1] + sum[i-2]; } return sum[n]; }} 动态规划：dp方程:f(n) = f(n-1) + f(n-2); 123456789101112class Solution { public int climbStairs(int n) { if(n &lt;= 2) return n; int f1 = 1,f2 = 2,f3 = 0; for(int i = 3;i &lt;= n; i++){ f3= f1 + f2; f1 = f2; f2 = f3; } return f3; }} 120. 三角形最小路径和 思路： 1234567891011class Solution { public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) { int[] path = new int[triangle.size() + 1]; for(int i = triangle.size() -1; i &gt;= 0;--i){ for(int j = 0; j &lt; triangle.get(i).size();++j){ path[j] = Math.min(path[j],path[j+1]) + triangle.get(i).get(j); } } return path[0]; }} 53. 最大子序和123456789101112131415class Solution { public int maxSubArray(int[] nums) { int res = nums[0]; int sum = 0; for(int i = 0; i &lt; nums.length; i++){ if(sum &gt; 0){ sum += nums[i]; }else{ sum = nums[i]; } res = Math.max(res,sum); } return res; }} 152. 乘积最大子数组 思路：当值为负数时，会令最大乘积变为最小乘积或最小乘积变为最大乘积 12345678910111213141516class Solution { public int maxProduct(int[] nums) { int proMin = 1 ,proMax = 1 ,max = Integer.MIN_VALUE; for(int i = 0; i &lt; nums.length; i++){ if(nums[i] &lt; 0){ int temp = proMax; proMax = proMin; proMin = temp; } proMin = Math.min(proMin*nums[i],nums[i]); proMax = Math.max(proMax*nums[i],nums[i]); max = Math.max(max,proMax); } return max; }} 字典树和并查集 字典树的数据结构 字典树，即Trie树，又称单词查找或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。 优点：最大限度地减少无谓的字符串比较，查询效率比哈希表高。 字典树的核心思想 空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。 字典树的基本性质 1、结点本身不存完整单词； 2、从根结点到某结点，路径上经过的字符连接起来，为该结点对应的字符串； 3、每个结点的所有子结点路径代表的字符都不相同。 字典树代码模板： 12345678910111213141516171819202122232425262728293031323334353637383940414243class Trie { private boolean isEnd; private Trie[] next; /** Initialize your data structure here. */ public Trie() { isEnd = false; next = new Trie[26]; } /** Inserts a word into the trie. */ public void insert(String word) { if (word == null || word.length() == 0) return; Trie curr = this; char[] words = word.toCharArray(); for (int i = 0;i &lt; words.length;i++) { int n = words[i] - 'a'; if (curr.next[n] == null) curr.next[n] = new Trie(); curr = curr.next[n]; } curr.isEnd = true; } /** Returns if the word is in the trie. */ public boolean search(String word) { Trie node = searchPrefix(word); return node != null &amp;&amp; node.isEnd; } /** Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) { Trie node = searchPrefix(prefix); return node != null; } private Trie searchPrefix(String word) { Trie node = this; char[] words = word.toCharArray(); for (int i = 0;i &lt; words.length;i++) { node = node.next[words[i] - 'a']; if (node == null) return null; } return node; }} 208. 实现 Trie (前缀树) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Trie { private boolean isEnd; private Trie[] next; /** Initialize your data structure here. */ public Trie() { isEnd = false; next = new Trie[26]; } /** Inserts a word into the trie. */ public void insert(String word) { if(word == null || word.length() == 0) return; Trie curr = this; char[] words = word.toCharArray(); for(int i = 0; i &lt; words.length; i++){ int n = words[i] - 'a'; if(curr.next[n] == null) curr.next[n] = new Trie(); curr = curr.next[n]; } curr.isEnd = true; } /** Returns if the word is in the trie. */ public boolean search(String word) { Trie node = searchPrefix(word); return node != null &amp;&amp; node.isEnd; } /** Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) { Trie node = searchPrefix(prefix); return node != null; } private Trie searchPrefix(String word){ Trie node = this; char[] words = word.toCharArray(); for(int i = 0; i &lt; words.length; i++) { node = node.next[words[i] - 'a']; if(node == null) return null; } return node; }}/** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */ 212. 单词搜索 II经典题型，使用字典树+dfs，逻辑思维简单易懂 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788class Solution { private static final int[] dx = new int[]{0,0,-1,1}; private static final int[] dy = new int[]{-1,1,0,0}; public List&lt;String&gt; findWords(char[][] board, String[] words) { if(words.length == 0) return new ArrayList&lt;&gt;(); // 构建字典树 Trie root = new Trie(); for(String word : words){ root.insert(word); } // 遍历board + dfs递归 向四周扩撒构建字符串，并在字典树中查找是否存在此字符串 Set&lt;String&gt; res = new HashSet&lt;&gt;(); int m = board.length,n = board[0].length; for(int i = 0; i &lt; m; i++){ for(int j = 0; j &lt; n; j++){ dfs(board,root,i,j,&quot;&quot;,res); } } return new ArrayList&lt;String&gt;(res); } public void dfs(char[][] board, Trie root, int i, int j, String currStr, Set res){ // 递归结束条件,边界处理以及访问过的字符不能再次访问 if(i &lt; 0 || j &lt; 0 || i == board.length || j == board[0].length || board[i][j] == '@') return; // 递归结束条件 2 char currChar = board[i][j]; if(root.next[currChar - 'a'] == null) return; // 处理当前层 char temp = currChar; board[i][j] = '@'; // 构建字符串 currStr += currChar; root = root.next[currChar - 'a']; if(root.isEnd){ res.add(currStr); } // 向上下左右递归下探 for(int k = 0; k &lt; dx.length; k++){ dfs(board,root,i + dx[k], j + dy[k],currStr,res); } // 将字符串置为空字符串 currStr = &quot;&quot;; // 恢复当前层字符 board[i][j] = temp; } class Trie { private boolean isEnd; private Trie[] next; /** Initialize your data structure here. */ public Trie() { isEnd = false; next = new Trie[26]; } /** Inserts a word into the trie. */ public void insert(String word) { if(word == null || word.length() == 0) return; Trie curr = this; char[] words = word.toCharArray(); for(int i = 0; i &lt; words.length; i++){ int n = words[i] - 'a'; if(curr.next[n] == null) curr.next[n] = new Trie(); curr = curr.next[n]; } curr.isEnd = true; } /** Returns if the word is in the trie. */ public boolean search(String word) { Trie node = searchPrefix(word); return node != null &amp;&amp; node.isEnd; } /** Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) { Trie node = searchPrefix(prefix); return node != null; } private Trie searchPrefix(String word){ Trie node = this; char[] words = word.toCharArray(); for(int i = 0; i &lt; words.length; i++) { node = node.next[words[i] - 'a']; if(node == null) return null; } return node; }}} 并查集数据结构：跟树有些类似，只不过和树是相反的。在树这个数据结构里面，每个结点会记录它的子结点。在并查集里，每个结点会记录它的父节点； 并查集适用场景：组团、配对问题 基本操作 makeSet(s)：建立一个新的并查集，其中包含s个单元素集合。 unionSet(x,y)：把元素x和元素y所在的集合合并，要求x和y所在的集合不相交，如果相交则不合并。 find(x)：找到元素x所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将他们各自的代表比较一下就可以了。 参考链接 代码模板： 12345678910111213141516171819202122232425class UnionFind { private int count = 0; private int[] parent; public UnionFind(int n) { count = n; parent = new int[n]; for (int i = 0; i &lt; n; i++) { parent[i] = i; } } public int find(int p) { while (p != parent[p]) { parent[p] = parent[parent[p]]; p = parent[p]; } return p; } public void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; parent[rootP] = rootQ; count--; }} 547. 省份数量思路：DFS 深度优先搜索 12345678910111213141516171819202122class Solution { public int findCircleNum(int[][] isConnected) { if(isConnected.length == 0) return 0; boolean[] statistics = new boolean[isConnected.length]; int res = 0; for(int i = 0; i &lt; isConnected.length; i++){ if(!statistics[i]){ dfs(isConnected,statistics,i); res++; } } return res; } public void dfs(int[][] isConnected,boolean[] statistics, int i){ for(int j = 0; j &lt; isConnected.length; j++){ if(isConnected[i][j] == 1 &amp;&amp; !statistics[j]){ statistics[j] = true; dfs(isConnected,statistics,j); } } }} 思路：BFS 广度优先搜索 123456789101112131415161718192021222324class Solution { public int findCircleNum(int[][] isConnected) { if(isConnected.length == 0) return 0; boolean[] statistics = new boolean[isConnected.length]; int res = 0; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for(int i = 0; i &lt; isConnected.length; i++){ if(!statistics[i]){ queue.offer(i); res++; while(!queue.isEmpty()){ int m = queue.poll(); for(int n = 0; n &lt; isConnected.length; n++){ if(isConnected[m][n] == 1 &amp;&amp; !statistics[n]){ queue.offer(n); statistics[n] = true; } } } } } return res; }} 思路：并查集 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution { public int findCircleNum(int[][] isConnected) { if(isConnected.length == 0) return 0; // 初始化并查集 UnionFind union = new UnionFind(isConnected.length); // 遍历isConnected中每个关联关系，有相连的城市合并为相同的省份 for(int i = 0; i &lt; isConnected.length; i++){ for(int j = 0; j &lt; isConnected.length; j++){ if(isConnected[i][j] == 1){ union.union(i,j); } } } return union.count; } class UnionFind { private int count = 0; private int[] parent; public UnionFind(int n) { count = n; parent = new int[n]; for (int i = 0; i &lt; n; i++) { parent[i] = i; } } public int find(int p) { while (p != parent[p]) { parent[p] = parent[parent[p]]; p = parent[p]; } return p; } public void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; parent[rootP] = rootQ; count--; } }} 200. 岛屿数量思路：DFS 深度优先搜索算法 123456789101112131415161718192021222324class Solution { private static int[] dx = new int[]{0,0,-1,1}; private static int[] dy = new int[]{-1,1,0,0}; public int numIslands(char[][] grid) { if (grid.length == 0) return 0; int count = 0; for (int i = 0; i &lt; grid.length; i++) { for (int j = 0; j &lt; grid[0].length; j++) { if (grid[i][j] == '1') { count++; dfs(grid, i, j); } } } return count; } public void dfs(char[][] grid, int i, int j){ if (i &lt; 0 || j &lt; 0 || i &gt;= grid.length || j &gt;= grid[0].length || grid[i][j] == '0') return; grid[i][j] = '0'; for(int k = 0; k &lt; dx.length; k++){ dfs(grid,i+dx[k],j+dy[k]); } }} 思路：BFS 广度优先搜索 12345678910111213141516171819202122232425262728293031class Solution { public int numIslands(char[][] grid) { if (grid.length == 0) return 0; int count = 0; for (int i = 0; i &lt; grid.length; i++) { for (int j = 0; j &lt; grid[0].length; j++) { if (grid[i][j] == '1') { count++; bfs(grid, i, j); } } } return count; } public void bfs(char[][] grid, int i,int j){ Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.offer(new int[]{i,j}); while(!queue.isEmpty()){ int[] curr = queue.poll(); i = curr[0]; j = curr[1]; if(i &gt;= 0 &amp;&amp; i &lt; grid.length &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; grid[0].length &amp;&amp; grid[i][j] == '1'){ grid[i][j] = '0'; queue.offer(new int[]{i,j-1}); queue.offer(new int[]{i,j+1}); queue.offer(new int[]{i-1,j}); queue.offer(new int[]{i+1,j}); } } }} 思路：并查集 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution { private int m,n; public int numIslands(char[][] grid) { if (grid.length == 0) return 0; m = grid.length; n = grid[0].length; UnionFind union = new UnionFind(m*n); int spaces = 0;// 空地的数量 int[][] direction = new int[][]{{1,0},{0,1}}; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (grid[i][j] == '0') { spaces++; }else{ for(int[] dire : direction){ int newx = i + dire[0]; int newy = j + dire[1]; // 判断边界 if(newx &lt; m &amp;&amp; newy &lt; n &amp;&amp; grid[newx][newy] == '1'){ // 合并陆地 union.union(getIndex(i,j),getIndex(newx,newy)); } } } } } return union.getCount() - spaces; } public int getIndex(int i,int j){ return i*n + j; } class UnionFind{ private int count; private int[] parent; UnionFind(int n){ count = n; parent = new int[n]; for(int i = 0; i &lt; n; i++){ parent[i] = i; } } private int find(int p){ while(p != parent[p]){ parent[p] = parent[parent[p]]; p = parent[p]; } return p; } private void union(int p, int q){ int P = find(p); int Q = find(q); if(P == Q) return; parent[P] = Q; count--; } public int getCount(){ return count; } }} 130. 被围绕的区域思路：DFS 深度优先搜索 1、遍历 board ，从边界为‘O’的开始递归，查找相联通的‘O’ 2、将与边界相联通的‘O’转换为‘#’，剩余‘O’就是被‘X’包围的 3、再次遍历 board，将‘#’转换为原来的‘O’，将‘O’转换为‘X’ 123456789101112131415161718192021222324252627282930313233343536class Solution { private static int[] dx = new int[]{0,0,-1,1}; private static int[] dy = new int[]{-1,1,0,0}; public void solve(char[][] board) { if (board.length == 0) return; int m = board.length,n = board[0].length; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { // 首先从边界为‘O’的开始递归下探,将与边界‘O’联通的‘O’都替换为‘#’ boolean isEdge = i == 0 || j == 0 || i == m-1 || j == n-1; if(isEdge &amp;&amp; board[i][j] == 'O'){ dfs(board,i,j); } } } // 将递归后的结果进行转换，‘#’代表和边界联通的，剩余的‘O’代表和边界不连通，需要转换为‘X’ for (int i = 0; i &lt; m; i++){ for(int j = 0; j &lt; n; j++){ if(board[i][j] == '#'){ board[i][j] = 'O'; }else if(board[i][j] == 'O'){ board[i][j] = 'X'; } } } } public void dfs(char[][] board, int i, int j){ // 递归结束条件 if (i &lt; 0 || j &lt; 0 || i &gt;= board.length || j &gt;= board[0].length || board[i][j] == 'X' || board[i][j] == '#') return; board[i][j] = '#'; // 左右上下，递归下探 for (int k = 0; k &lt; dx.length; k++){ dfs(board,i+dx[k],j+dy[k]); } }} 思路：BFS 广度优先搜索 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution { private static int[] dx = new int[]{0,0,-1,1}; private static int[] dy = new int[]{-1,1,0,0}; public void solve(char[][] board) { if (board.length == 0) return; int m = board.length,n = board[0].length; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { // 首先从边界为‘O’的开始递归下探,将与边界‘O’联通的‘O’都替换为‘#’ boolean isEdge = i == 0 || j == 0 || i == m-1 || j == n-1; if(isEdge &amp;&amp; board[i][j] == 'O'){ bfs(board,i,j); } } } // 将递归后的结果进行转换，‘#’代表和边界联通的，剩余的‘O’代表和边界不连通，需要转换为‘X’ for (int i = 0; i &lt; m; i++){ for(int j = 0; j &lt; n; j++){ if(board[i][j] == '#'){ board[i][j] = 'O'; }else if(board[i][j] == 'O'){ board[i][j] = 'X'; } } } } public void bfs(char[][] board, int i,int j){ Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.offer(new int[]{i,j}); while(!queue.isEmpty()){ int[] curr = queue.poll(); i = curr[0]; j = curr[1]; if(i &gt;= 0 &amp;&amp; i &lt; board.length &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].length &amp;&amp; board[i][j] == 'O'){ board[i][j] = '#'; for (int k = 0; k &lt; dx.length; k++){ queue.offer(new int[]{i+dx[k],j+dy[k]}); } } } }} 思路：并查集1、首先创建一个虚拟结点，将所有在边界上为‘O’的点都联通到虚拟结点上； 2、然后再将非边界上的‘O’按是否与边界元素‘O’相连分组； 3、按分组后的情况，将与边界‘O’相连的即就是与虚拟结点相连的都转换为‘O’，不与边界‘O’相连的说明就是被‘X’包围的，转换为‘X’； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution { private int[] dx = new int[]{0,0,-1,1}; private int[] dy = new int[]{-1,1,0,0}; private int rows,clos; public void solve(char[][] board) { rows = board.length; if (rows == 0) return; clos = board[0].length; UnionFind union = new UnionFind(rows*clos+1); int dummyNode = rows*clos; for (int i = 0; i &lt; rows; i++){ for(int j = 0; j &lt; clos; j++){ if (board[i][j] == 'O'){ if (i == 0 || j == 0 || i == rows - 1 || j == clos - 1){ union.union(getIndex(i,j),dummyNode); }else{ for(int k = 0; k &lt; dx.length; k++){ int currI = i + dx[k]; int currJ = j + dy[k]; if (currI &gt;= 0 &amp;&amp; currI &lt; rows &amp;&amp; currJ &gt;= 0 &amp;&amp; currJ &lt; clos &amp;&amp; board[currI][currJ] == 'O'){ union.union(getIndex(i,j),getIndex(currI,currJ)); } } } } } } for (int i = 0; i &lt; rows; i++){ for (int j = 0; j &lt; clos; j++) { if (union.find(getIndex(i,j)) == union.find(dummyNode)){ board[i][j] = 'O'; }else { board[i][j] = 'X'; } } } } public int getIndex (int i, int j){ return i * clos + j; } class UnionFind{ private int count; private int[] parent; UnionFind(int n){ count = n; parent = new int[n]; for (int i = 0; i &lt; n; i++){ parent[i] = i; } } private int find(int p){ while(p != parent[p]){ parent[p] = parent[parent[p]]; p = parent[p]; } return p; } private void union(int p, int q){ int P = find(p); int Q = find(q); if (p == Q) return; parent[P] = Q; count--; } }}","link":"/2021/01/31/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"title":"第一章 影响力的武器 ——武装自己","text":"凡事都应当尽可能地简单，而不是较为简单。——阿尔伯特·爱因斯坦 实验案例：雌火鸡对小火鸡的“叽叽”声很敏感，即使这个声音是实验模拟发出的，它也会机械重复的执行自己作为母亲的职责。 固定行为模式，这些模式的一个基本特点是：每一次，构成模式的所有行为几乎都是按相同的方式、相同的顺序发生的。 人类也有相似的自动反应模式，比如：我们在要别人帮忙的时候，要是能给一个理由，成功的概率会更大，因为人就是单纯地喜欢做事有个理由。 大部分影响力武器具备的相同要素： 这类武器有能力激活一种近似机械化的过程 只要掌握了触发这种过程的能力，人们就能从中渔利 使用者能借助这些自动影响力武器的威力，这种武器就好像一根沉甸甸的大棒，只要用了它，就能让另一个人乖乖就范。 例如：人类认知中的“对比原理”，两样东西一前一后地展示出来，我们怎样看待其间的区别，对比原理是有影响的。简单地说，要是第二样东西跟第一样东西有着相当的不同，那么，我们往往会认为两者的区别比实际上更大。","link":"/2021/01/31/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%BD%B1%E5%93%8D%E5%8A%9B%E7%9A%84%E6%AD%A6%E5%99%A8%20%E2%80%94%E2%80%94%E6%AD%A6%E8%A3%85%E8%87%AA%E5%B7%B1/"},{"title":"第二章 互惠 ——给予，索取，再索取","text":"每一笔债都还得干干净净，就好像上帝他老人家是债主。——拉尔夫·沃尔多·爱默生互惠原理，别人给了我们什么好处，我们理应有义务在将来回报别人的好意、礼物、邀请等。 1、互惠原理如何起作用？ 我们每个人从小听人教导，不能辜负了它，我们每个人也都知道，凡是有人敢违背它，必然要受到社会的制裁和嘲笑。由于普通人大多讨厌一味索取、从不回报的家伙，我们往往会想法设法地避免被别人看成是揩油王、忘恩负义的王八蛋，或是不劳而获的懒虫。 2、互惠原理在人类社会中到处都能运用，而且所向披靡，比如政客间和生意场的请客吃饭送礼，以及经济活动中的应用，，比如超市免费赠送样本体验等。 3、人类可利用互惠原理触发不对等交换，别人最初给予的小小恩惠，能够让当事人产生亏欠感，最终回报以大得多的恩惠。 4、互惠式让步，高阶使用技巧，先提大要求后提小要求。互惠原理和直觉对比原理的结合。 5、如何抵挡使用互惠原理的敌人？ 首先要学会辨别别人的恩惠是真诚的善意还是虚假的策略，如果是善意的就以善意回报，否则就拒绝。","link":"/2021/01/31/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E4%BA%92%E6%83%A0%20%E2%80%94%E2%80%94%E7%BB%99%E4%BA%88%EF%BC%8C%E7%B4%A2%E5%8F%96%EF%BC%8C%E5%86%8D%E7%B4%A2%E5%8F%96/"},{"title":"第三章 承诺和一致——脑子里的怪物","text":"一开始就拒绝，比最后反悔要容易。——达芬奇 人人都有一种言行一致（同时也显得言行一致）的愿望。一旦我们作出了一个选择，或采取了某种立场，我们立刻就会碰到来自内心和外部的压力，迫使我们按照承诺的那样去做。在这样的压力之下，我们会想方设法地以行动证明自己先前的决定是正确的。我们所有人都会一次次地欺骗自己，以便在作出选择之后，坚信自己做得没错。 这就是承诺和一致原则对人的行为的强大指引力量。 言出必行，在大多数环境下，言行一致都是很有价值也很合适的。依照人们的普遍感觉，言行不一是一种不可取的人格特性。信仰、言语和行为前后不一的人，会被看成是脑筋混乱、表里不一，甚至精神有毛病的。另一方面，言行高度一致大多跟个性坚强、智力出众挂钩，他是逻辑性、稳定性和诚实感的核心。 1、为什么我们要努力做到L言行一致？ 因为日常生活的纷繁复杂对我们的精力和能力都提出了苛刻的要求，有了一致性我们就能以相对轻松、高效的便利方式来应对一切了。是我们懒惰的大脑想避免思考的一种处理方式。 2、人们是如何利用承诺和一致原则来达到自己的目的的呢？ 承诺是关键，通过各种直接的或间接的方式诱使人们做出承诺，那么人自然就想要倔强地按照之前的承诺去保持一致从而完成达到自己的目的。而且为一个承诺付出的努力越多，它对承诺者的影响也就越大。 3、如何避免自己受承诺和一致原则的影响？ 尽管保持言行一致是好品质，但是这只适用于大多数情况，在某些地方我们也必须避免愚蠢的死脑筋。因为我们不假思索自动保持一致的反应，正是某些人耍花招利用它在我们身上谋利的策略。","link":"/2021/01/31/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%89%BF%E8%AF%BA%E5%92%8C%E4%B8%80%E8%87%B4%E2%80%94%E2%80%94%E8%84%91%E5%AD%90%E9%87%8C%E7%9A%84%E6%80%AA%E7%89%A9/"},{"title":"第四章 社会认同——我们就是真理","text":"在人人想法都差不多的地方，没人会想得太多——沃尔特·李普曼 社会认同原理：在判断何为正确时，我们会根据别人的意见行事。 我们对社会认同的反应方式完全是无意识的、条件反射式的。 1、什么时候会容易产生社会认同？ 一般来说，在我们自己不确定、情况不明或含糊不清，意外性太大的时候，我们最有可能觉得别人的行为是正确的。但是在审视他人反应，消除不确定性的过程中，我们很容易忽视一点微妙而重要的事实：其他人有可能也在寻找社会证据。尤其是在局面模糊不清的时候，人人都倾向于观察别人在做什么，这会导致一种叫“多元无知”的有趣现象。 2、社会认同原理能发挥出最大的影响力的一条适用条件：相似性。我们会根据他人的行为来判断自己怎么做才合适，尤其是在我们觉得这些人跟自己相似的时候。 3、如何拒绝？ 如果在情况不明或含糊不清时，应该及时关闭社会认同开关，谨防同类的伪造数据和虚假证据。面对明显时伪造的社会证据，我们只要多保持一点警惕感，就能很好地保护自己了。首先，我们似乎持有这样的假设：要是很多人在做相同的事情，他们必然知道一些我们不知道的事情。尤其在我们并不确定的时候，我们很乐意对这种集体智慧投入极大的信任。其次，人群很多时候都是错的，因为群体的成员并不是根据优势信息才采取行动，而只是基于社会认同原理在做反应。","link":"/2021/01/31/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E7%A4%BE%E4%BC%9A%E8%AE%A4%E5%90%8C%E2%80%94%E2%80%94%E6%88%91%E4%BB%AC%E5%B0%B1%E6%98%AF%E7%9C%9F%E7%90%86/"},{"title":"第五章 喜好 ——友好的窃贼","text":"辩护律师的主要任务就是让陪审团喜欢他的客户 —— 克拉伦斯·达罗 我们大多数人总是更容易答应自己认识和喜欢的人所提出的要求。 1、我喜欢你的理由 外表魅力：长的好看的人在社交中占有优势，我们会自动给长得好看的人添加一些正面特点，比如有才华、善良、诚实和聪明等。而且我们在作出这些判断的时候并没有意识到外表魅力在其中发挥的作用。 相似性：我们喜欢与自己相似的人。不管相似之处是在观点、个性、背景还是生活方式上，我们总有这样的倾向。 恭维：我们特别喜欢听人恭维奉承 接触与合作：我们更喜欢自己熟悉的人或者相互之间有合作的人 条件反射和关联：我们总喜欢给自己带来好消息的人，讨厌给自己带来坏消息的人。人们深知关联原理的奥妙，并努力把自己跟积极的事情联系起来，跟消极的事情保持距离。 2、如何拒绝？ 不去压抑好感因素产生的影响力，听凭这些因素发挥力量，然后用这股力量反过来对付那些想从中获利的人。","link":"/2021/01/31/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%96%9C%E5%A5%BD%20%E2%80%94%E2%80%94%E5%8F%8B%E5%A5%BD%E7%9A%84%E7%AA%83%E8%B4%BC/"},{"title":"第六章 权威 —— 教化下的敬重","text":"跟着权威走。—— 维吉尔 1、权威高压的力量 在权威的命令下，成年人几乎愿意干任何事情。政府机构往往都有这样的能力从普通共鸣身上压榨出可怕的百依百顺，对他们而言，这样的结果显然具有更为严肃的引申意义。 2、盲目服从的诱惑和危险 服从权威人物的命令，总能给我们带来一些实际的好处。部分原因是因为他们更有智慧，也有部分原因是他们手里攥着对我们的奖惩。很多情况下，只要有正统的权威说了话，其他本来应该考虑的事情就变得不相关了。 3、内涵不是内容 在没有真正权威的情况下，有几种象征权威的符号能十分有效的触发我们的顺从态度。 头衔：头衔比当事人的本质更能影响他人的行为。头衔除了能让陌生人表现更恭顺，还能让有头衔的那个人在旁人眼里显得更高大。 衣着：一个西装革履的人和一个着装普普通通的人你觉得那个人比较有权威？ 身份标识：开名车戴名表的人和普通人你觉得那个人比较有权威？ 4、如何拒绝 当你认识到权威的力量后，对付以权威或虚假的权威象征符号代表的权威影响力来左右我们的时候，我们的防御策略就是提高警惕。首先质疑权威的资格，以及这些资格是否跟眼前的主题相关，然后再质疑权威说的是真话吗？，因为即使是真正的权威专家也不见得会诚实地把正确的信息告知我们。","link":"/2021/01/31/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%9D%83%E5%A8%81%20%E2%80%94%E2%80%94%20%E6%95%99%E5%8C%96%E4%B8%8B%E7%9A%84%E6%95%AC%E9%87%8D/"},{"title":"第七章 稀缺 —— 数量少的说了算","text":"不管是什么东西，只要你晓得会失去它，自然就会爱上它。—— G.K. 切斯特顿 1、物以稀为贵 稀缺原理：机会越少，价值似乎越高。对失去某种东西的恐惧，似乎要比对获得同一物品的渴望，更能激发人们的行动力。 2、逆反心理 我们基本可以根据获得一样东西的难易程度，迅速准确地判断它的质量。机会越来越少的话，我们的自由也会随之丧失。而我们又痛恨失去本来拥有的自由。保住既得利益的愿望，是心理逆反理论的核心。 3、最佳条件 一开始就知道机会少比开始有机会后来再慢慢减少机会的场景，后者比前者更加有刺激性。 4、如何拒绝 一旦在顺从环境下体验到高涨的情绪，我们就可以提醒自己：说不定有人在玩弄稀缺手法，必须谨慎行事。那么如何判断稀缺的东西是真的对我们有价值呢？那就需要我们清楚的思考，我们想从这样的东西里获得什么？如果带来的价值是我们迫切想要的，而且付出的代价是我们能够承受的，那么就去占有它吧！","link":"/2021/01/31/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E7%A8%80%E7%BC%BA%20%E2%80%94%E2%80%94%20%E6%95%B0%E9%87%8F%E5%B0%91%E7%9A%84%E8%AF%B4%E4%BA%86%E7%AE%97/"},{"title":"高情商的人不会做的四件事","text":"来自 github 上一位博主的分享 4 Things Emotionally Intelligent People Don’t DoGive up these bad habits and your natural emotional intelligengce will shine. Improving your emotional intelligence is often about what you do less of , not more of. 改掉不好的习惯，自然不做作的情商才会使你大放异彩。提高情商往往是少做什么而不是多做。 情商不好的人往往体现在一下几个方面： They blame other people for their problems They trap themselves in cycles of stress and anxiety They self-sabotage as soon as they start to make progress 如果你想提高你的情商，就在生活中学会去努力避免这些不好的习惯，那么是那四件事呢？ 1. Criticizing others 批评别人 Criticizing others is often an unconscious defense mechanism aimed at alleviating our own insecurities. 批评别人往往是一种无意识的防御机制，目的是减轻我们自己的不安全感。为什么呢？ When you point out to yourself that someone else is dumb , you’re also implying that you’re smart . And that feels good. When you criticize someone else for being naive , what you’re really doing is telling yourself that you’re somhisticated . And that feels good. When you silently chuckle to yourself about how terrible someone’s fashion sense is ,you’re telling yourself how refined your own taste is . And that feels good. 许多人都喜欢站在傍观者的角度给别人提意见，说出别人的不好，美其名曰为了别人好。但是 Unhelpful criticism is about making yourself feel better. 所以，我们在不可能完全彻底了解一个人的时候，尽量不要去批评别人，反而多点鼓励和欣赏才是正确的做法。 “Criticism of others is a form of self-commendation(自我表扬). We think we make the picture hang straight on our wall by telling our neighbors that all his pictures are crooked(扭曲的).” ― Fulton J. Sheen 2. Worrying about the future 担心未来 为什么会担心未来？因为未来是充满不确定性，但是我们谁都不喜欢不确定性。 Chronic worriers live under the illusion that thinking is always problem-solving and that planning always leads to greater levels of preparedness. But neither of those are true: 长期担忧者总生活在一种错觉中，认为思考总能解决问题，计划总能让准备更加充分。 Just because you’re thinking about a problem doesn’t mean you’re thinking about it productively. 但是仅仅因为你思考一个问题，不代表你能卓有成效的思考它。 And just because you’re planning - running through countless hypothetical future scenarios - doesn’t mean you’re any better equipped to handle them. Often, you’re just making yourself feel more prepared. 仅仅因为你的计划——贯穿了无数假定的未来场景。但这并不意味着你就能更好地应对他们。通常，你只是让自己感觉准备得更充分。 “Worry does not empty tomorrow of its sorrow, it empties today of its strength.”― Corrie Ten Boom 3. Ruminating on the past 活在过去 If you want to move on with your life instead of staying stuck in the past ,you must accept the past for what it is—including feeling helpless. 如果你想让你的生活继续前行而不是停滞不前，你就必须接受过去——包括无助的感受 莫名的想起前段时间在看《被讨厌的勇气》中提到的阿德勒心理学提倡的“目的论”和弗洛伊德心理学说的“原因论”，关于一个人是否能改变自己，“原因论”认为，是因为过去的某些创伤（比如自己从小胆小怯懦）导致了你做不出改变自己的行动，而“目的论”认为，是因为你不想改变自己，做不到改变自己的行动才找出过去的某些创伤来解释自己为什么做不到，因为相比找一个过去的原因比你去做出改变容易的多。人们总是喜欢做简单的事情。 人们常常会觉得以前我要是努力点就不至于是现在这个样子了，但是往往这样抱怨都是没用的，所以，忘掉过去，从现在开始也不晚。 Don’t give up control over your future by pretending you can control the past. “To think too much is a disease.” ― Fyodor Dostoyevsky 4. Maintaining unrealistic expectations 抱有不切实际的期望 But what does it mean, exactly, to maintain an unrealistic expectation? You probably see your expectations of other people as a good thing: Having high expectations for people encourages them to grow and mature and become their best self! 不要对别人抱有不切实际的期望，因为当他达不到你的期望会让你感到沮丧和失望。我们应该对自己充满信心，不应该期望别人来帮助你。 “He was swimming in a sea of other people’s expectations. Men had drowned in seas like that.” ― Robert Jordan","link":"/2021/01/31/%E9%AB%98%E6%83%85%E5%95%86%E7%9A%84%E4%BA%BA%E4%B8%8D%E4%BC%9A%E5%81%9A%E7%9A%84%E5%9B%9B%E4%BB%B6%E4%BA%8B/"},{"title":"字符串算法","text":"1、字符串基础问题709. 转换成小写字母 ASCII码表： a-z：97-122 A-Z：65-90 0-9：48-57 12345678910111213141516class Solution { public String toLowerCase(String str) { int len = str.length(); StringBuffer sb = new StringBuffer(); for(int i = 0; i &lt; len; i++){ int ascii = (int)str.charAt(i); if(ascii &gt;= 65 &amp;&amp; ascii &lt;= 90){ char c = (char)(ascii+32); sb.append(c); }else{ sb.append(str.charAt(i)); } } return sb.toString(); }} 58. 最后一个单词的长度调用分割函数 1234567class Solution { public int lengthOfLastWord(String s) { if(s == null || s.length() == 0) return 0; String[] arrays = s.split(&quot; &quot;); return arrays.length == 0 ? 0 : arrays[arrays.length - 1].length(); }} 从后往前遍历 1234567891011class Solution { public int lengthOfLastWord(String s) { if(s == null || s.length() == 0) return 0; int end = s.length() - 1; while(end &gt;= 0 &amp;&amp; s.charAt(end) == ' ') end--; if(end &lt; 0) return 0; int start = end; while(start &gt;= 0 &amp;&amp; s.charAt(start) != ' ') start--; return end - start; }} 771. 宝石与石头 123456789101112class Solution { public int numJewelsInStones(String jewels, String stones) { if(jewels.length() == 0 || stones.length() == 0) return 0; int res = 0; for(char jewel : jewels.toCharArray()){ for(char stone : stones.toCharArray()){ if(jewel == stone) res++; } } return res; }} 387. 字符串中的第一个唯一字符 123456789101112131415161718class Solution { public int firstUniqChar(String s) { if(s == null || s.length() == 0) return -1; Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); for(char c : s.toCharArray()){ if(!map.containsKey(c)){ map.put(c,1); }else{ map.put(c,map.get(c)+1); } } for(int i = 0; i &lt; s.length(); i++){ int count = (int)map.get(s.charAt(i)); if(count == 1) return i; } return -1; }} 8. 字符串转换整数 (atoi) 123456789101112131415161718192021222324252627282930313233343536373839class Solution { public int myAtoi(String s) { int res = 0; int len = s.length(); char[] charArray = s.toCharArray(); // 定义一个下标指针 int index = 0; // 循环遍历，去掉前导空格 while(index &lt; len &amp;&amp; charArray[index] == ' '){ index++; } // 处理极端情况 if(index == len) return 0; // 检查是正数还是负数 int sign = 1; char first = charArray[index]; if(first == '+'){ index++; }else if(first == '-'){ index++; sign = -1; } // 循环遍历字符 while(index &lt; len){ char c = charArray[index]; // 检查字符是否是数字字符 if(c &gt; '9' || c &lt; '0') break; // 检查数字是否越界 if(res &gt; Integer.MAX_VALUE/10 || (res == Integer.MAX_VALUE/10 &amp;&amp; (c - '0') &gt; Integer.MAX_VALUE%10)) return Integer.MAX_VALUE; if(res &lt; Integer.MIN_VALUE/10 || (res == Integer.MIN_VALUE/10 &amp;&amp; (c - '0') &gt; - (Integer.MIN_VALUE%10))) return Integer.MIN_VALUE; // 合法情况，转换字符为相应的数字 res = res*10 + sign * (c - '0'); index++; } return res; }} 2、字符串操作问题14. 最长公共前缀 1234567891011121314151617class Solution { public String longestCommonPrefix(String[] strs) { if(strs.length == 0) return &quot;&quot;; String prefix = strs[0]; for(int i = 1; i &lt; strs.length; i++){ String currStr = strs[i]; int j = 0; for(; j &lt; prefix.length() &amp;&amp; j &lt; currStr.length(); j++){ if(currStr.charAt(j) != prefix.charAt(j)) break; } prefix = prefix.substring(0,j); if(prefix.equals(&quot;&quot;)) return &quot;&quot;; } return prefix; }} 344. 反转字符串 1234567891011121314class Solution { public void reverseString(char[] s) { int left = 0 ,right = s.length - 1; while(left &lt; right){ if(s[left] != s[right]){ char temp = s[left]; s[left] = s[right]; s[right] = temp; } left++; right--; } }} 541. 反转字符串 II 1234567891011121314class Solution { public String reverseStr(String s, int k) { char[] charArray = s.toCharArray(); for(int index = 0;index &lt; charArray.length;index +=2*k){ int left = index,right = Math.min(index + k - 1,charArray.length - 1); while(left &lt; right){ char temp = charArray[left]; charArray[left++] = charArray[right]; charArray[right--] = temp; } } return new String(charArray); }} 151. 翻转字符串里的单词 123456789class Solution { public String reverseWords(String s) { // 去除多余空格 s = s.trim(); List&lt;String&gt; strList = Arrays.asList(s.split(&quot;\\s+&quot;)); Collections.reverse(strList); return String.join(&quot; &quot;,strList); }} 557. 反转字符串中的单词 III 12345678910111213141516171819class Solution { public String reverseWords(String s) { String[] strArray = s.split(&quot; &quot;); StringBuffer sb = new StringBuffer(); for(String currStr : strArray){ int right = currStr.length() - 1; int left = 0; char[] charArr = currStr.toCharArray(); while(left &lt; right){ char temp = charArr[left]; charArr[left++] = charArr[right]; charArr[right--] = temp; } sb.append(charArr); sb.append(&quot; &quot;); } return sb.toString().trim(); }} 917. 仅仅反转字母思路：双指针，碰到非字母字符跳过循环 12345678910111213141516171819202122232425262728class Solution { public String reverseOnlyLetters(String S) { int len = S.length(); if(len &lt; 2) return S; // 熟悉的双指针 int left = 0,right = len - 1; char[] charArr = S.toCharArray(); while(left &lt; right){ char leftChar = charArr[left]; char rightChar = charArr[right]; if(!isLetter(leftChar)) { left++; continue; } if(!isLetter(rightChar)) { right--; continue; } char temp = charArr[left]; charArr[left++] = charArr[right]; charArr[right--] = temp; } return new String(charArr); } public boolean isLetter(char c){ return (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= 'a' &amp;&amp; c &lt;= 'z'); }} 3、异位词问题242. 有效的字母异位词 123456789101112131415161718192021class Solution { public boolean isAnagram(String s, String t) { if (s.isEmpty() &amp;&amp; t.isEmpty()) { return true; } if (s.length() != t.length()) { return false; } char[] sChars = s.toCharArray(); char[] tChars = t.toCharArray(); Arrays.sort(sChars); Arrays.sort(tChars); for (int i = 0; i &lt; sChars.length; i++) { if (sChars[i] != tChars[i]) { return false; } } //return Arrays.equals(sChars, tChars); return true; }} 49. 字母异位词分组 123456789101112131415161718 class Solution { public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) { if (strs == null || strs.length == 0) { return new ArrayList&lt;&gt;(); } Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; strs.length; i++) { char[] chars = strs[i].toCharArray(); Arrays.sort(chars); String key = String.valueOf(chars); if (!map.containsKey(key)) { map.put(key, new ArrayList&lt;&gt;()); } map.get(key).add(strs[i]); } return new ArrayList&lt;&gt;(map.values()); }} 438. 找到字符串中所有字母异位词 4、回文串问题125. 验证回文串 思路：先筛选，再反转，再比较 12345678910111213class Solution { public boolean isPalindrome(String s) { if(s.length() == 0) return true; StringBuilder sb = new StringBuilder(); for(char c : s.toCharArray()){ if((c &lt;= 'Z' &amp;&amp; c &gt;= 'A') || (c &lt;= 'z' &amp;&amp; c &gt;= 'a') || (c &lt;= '9' &amp;&amp; c &gt;='0')) sb.append(c); } String origStr = sb.toString(); String reverseStr = sb.reverse().toString(); return reverseStr.equalsIgnoreCase(origStr); }} 思路：双指针判断1、如果 start 指针所指字符不符合[^A-Za-z0-9] start++ ,跳过本次判断； 2、如果 end 指针所指字符不符合[^A-Za-z0-9] end– , 跳过本次判断； 3、如果 start 、end 指针所指字符都不符合，start++,end–; 4、如果 start 、end 指针所指字符忽略大小写情况下不相同，就代表不是回文串，返回 false; 1234567891011121314151617181920212223242526272829class Solution { public boolean isPalindrome(String s) { if(s.length() == 0) return true; // 双指针 int start = 0,end = s.length() - 1; while(start &lt; end){ char startC = s.charAt(start); char endC = s.charAt(end); if(!isMath(startC)) { start++; continue; } if(!isMath(endC)) { end--; continue; } if(Character.toLowerCase(startC) != Character.toLowerCase(endC)) { return false; }else{ start++; end--; } } return true; } public boolean isMath(char c){ return ((c &lt;= 'Z' &amp;&amp; c &gt;= 'A') || (c &lt;= 'z' &amp;&amp; c &gt;= 'a') || (c &lt;= '9' &amp;&amp; c &gt;='0')); }} 680. 验证回文字符串 Ⅱ思路：双指针 1、i 指针从头开始，j 指针从尾开始，依次比较是否相等; 2、charArrsy[i] == charArray[j] , 则将这两字符算在回文串中，并 i++，j–; 3、charArrsy[i] != charArray[j] , 说明这两个字符是构成回文串的“阻碍”，依据题目可以删除其中任意一个字符后再进行比较； 4、比较删除其中任意字符后的字串是否构成回文串，删除左边字符后取(i+1,j)范围内字符比较，删除右边字符取(i,j-1)范围内字符比较； 5、比较字串是否是回文串又是“双指针”的用法； 为什么使用字符数组，这样虽然开辟了多余的内存，但是数组能提升查询效率 1234567891011121314151617class Solution { public boolean validPalindrome(String s) { char[] charArray = s.toCharArray(); for(int i = 0,j = charArray.length -1; i &lt; j; i++,j--){ if(charArray[i] != charArray[j]){ return isPalindrome(charArray,i+1,j) || isPalindrome(charArray,i,j-1); } } return true; } public boolean isPalindrome(char[] charArray , int i,int j){ while(i &lt; j){ if(charArray[i++] != charArray[j--]) return false; } return true; }} 5、最长子串、子序列问题最常规子串、子序列问题： 1143. 最长公共子序列 思路：动态规划 题解：动态规划图文解析（java） key：找到动态方程 1、当前对比的两个字符不相同时，取text1倒退一格和text2倒退一格两者中的最大值，也就是 dp[i + 1][j + 1] = Math.max(dp[i+1][j], dp[i][j+1]); 2、当前对比的两个字符相同时，取text1与text2各退一格的值+1，及 dp[i+1][j+1] = dp[i][j] + 1; 1234567891011121314151617181920class Solution { public int longestCommonSubsequence(String text1, String text2) { int m = text1.length(), n = text2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { // 获取两个串字符 char c1 = text1.charAt(i), c2 = text2.charAt(j); if (c1 == c2) { // 去找它们前面各退一格的值加1即可 dp[i + 1][j + 1] = dp[i][j] + 1; } else { //要么是text1往前退一格，要么是text2往前退一格，两个的最大值 dp[i + 1][j + 1] = Math.max(dp[i + 1][j], dp[i][j + 1]); } } } return dp[m][n]; }} 72. 编辑距离思路：动态规划 dp方程. dp[i][j] 表示 word1 字符串前 i +1个字符组成的字符串转换为 word2 字符串前 j +1个字符组成的字符串的最少操作数，那么 1、当 word1.charAt(i) == word2.charAt(j) ，只有一种操作删除，dp[i][j] = dp[i-1][j-1]; 2、当 word1.charAt(i) != word2.charAt(j) ，有三种操作替换dp[i-1][j-1]，删除dp[i-1][j]，插入dp[i][j-1]，求三者的最小值 min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])； 3、当 word1 为空字符串时，只能通过插入操作来转换 ，也就是 dp[j][0] = dp[j-1][0] + 1； 4、当 word2 为空字符串时，只能通过删除操作来转换 ，也就是 dp[0][i] = dp[0][i-1] + 1； 123456789101112131415161718192021class Solution { public int minDistance(String word1, String word2) { int len1 = word1.length(); int len2 = word2.length(); int[][] dp = new int[len1+1][len2+1]; for(int i = 1; i &lt;= len2; i++) dp[0][i] = dp[0][i-1] + 1; for(int j = 1; j &lt;= len1; j++) dp[j][0] = dp[j-1][0] + 1; for(int i = 1; i &lt;= len1; i++){ for(int j = 1; j &lt;= len2; j++){ char c1 = word1.charAt(i-1); char c2 = word2.charAt(j-1); if(c1 == c2){ dp[i][j] = dp[i-1][j-1]; }else{ dp[i][j] = Math.min(Math.min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1]) + 1; } } } return dp[len1][len2]; }} 5. 最长回文子串思路：暴力+双指针 1234567891011121314151617181920212223class Solution { public String longestPalindrome(String s) { if(s.length() &lt;= 1) return s; int maxLen = 1; int index = 0; char[] charArr = s.toCharArray(); for(int i = 0; i &lt; s.length(); i++){ for(int j = i+1; j &lt; s.length(); j++){ if(j-i+1 &gt; maxLen &amp;&amp; isPalindrime(charArr,i,j)){ maxLen = j-i+1; index = i; } } } return s.substring(index,index + maxLen); } public boolean isPalindrime(char[] charArr,int left ,int right){ while(left &lt; right){ if(charArr[left++] != charArr[right--]) return false; } return true; }} 动态规划： 1234567891011121314151617181920212223242526272829303132333435363738class Solution { public String longestPalindrome(String s) { int len = s.length(); if(len &lt;= 1) return s; char[] charArr = s.toCharArray(); // 记录子串是回文串的长度 int maxLen = 1; // 记录子串是回文串的头坐标 int index = 0; // dp[i][j] 代表[i,j]区间内子串是否式回文串 boolean [][] dp = new boolean[len][len]; // 子串长度为 1，一个字符时肯定是回文串 for(int i = 0;i &lt; len; i++){ dp[i][i] = true; } // 状态转移方程 charArr[i] == charArr[j] 前提下 dp[i][j] = dp[i+1][j-1] ， // 判断当前子串是否是回文串 == 当首尾字符相同的情况下取决于剩余子串是否是回文串 for(int j = 1; j &lt; len; j++){ for(int i = 0; i &lt; j; i++){ if(charArr[i] != charArr[j]){ dp[i][j] = false; }else{ // (i,j) 区间长度小于2的子串都是回文串 if(j-i &lt; 3){ dp[i][j] = true; }else{ dp[i][j] = dp[i+1][j-1]; } } if(j-i+1 &gt; maxLen &amp;&amp; dp[i][j]){ maxLen = j-i+1; index = i; } } } return s.substring(index,index + maxLen); } } 6、字符串+DP问题10. 正则表达式匹配 7、字符串匹配算法","link":"/2021/02/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"},{"title":"除夕夜","text":"来自 微信公众号“为你读诗”除夕 作者：于谦[明] 今宵是除夕，明日又新年。 爆竹惊残梦，寒镫照独眠。 风霜催腊尽，梅柳得春先。 抚景情无限，那能不怅然。 许愿：2021 祝自己万事如意","link":"/2021/02/12/2021%E9%99%A4%E5%A4%95%EF%BC%8C%E4%B8%BA%E4%BD%A0%E8%AF%BB%E8%AF%97/"},{"title":"《百元之恋》观后感","text":"来自 《百元之恋》日常的生活丧吗？这无疑是肯定的。就像电影的结尾，狩野拉着一子去吃饭一样，深情浪漫与惊天动地有的话也只是转瞬即逝，普通人生活的大部分时间，也都是朴实无华。今天即便有再大的挫折，一觉醒来后或许依旧是满满的颓废。不过事在人为，时间会解决一切。这不是一碗甜蜜的鸡汤，而是一管苦涩的藿香正气，喝完之后，日子还是要奔的，工作还是要干的，领导还是要“骂”的，坎坷还是要继续经历的。","link":"/2021/02/12/%E3%80%8A%E7%99%BE%E5%85%83%E4%B9%8B%E6%81%8B%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/"},{"title":"理念的力量-序言","text":"序言： 本书的基本思想：理念是重要的，人的行为不仅受利益的支配，也受理念的支配，社会的变革和人类的进步基本上都是在新的理念推动下出现的，没有理念的变化就没有制度和政策的改变，中国过去三十多年所取得的成就是理念变化的结果，中国的未来很大程度取决于我们能否走出一些错误理念的陷阱，而没有思想市场，就很难有新的理念的出现和传播，从而整个社会就会失去变革的源泉。 英国经济学家艾奇沃斯讲过“经济学的第一原理是，每个人都是有利益驱动的”及就是在经济社会中不管是个人选择还是国家政策都是各种利益之间的博弈结果，但是我们忽视了一个重要的事实，即个人行为也受其持有的理念、世界观、意识形态的支配。总结起来就是人是由利益支配的，但利益本身却受人的理念支配。更简练的说，人是会思考的，人做事是有目的、有计划的。作为理性存在物，我们做任何事一定要找一个正当性的理由，这一正当性理由是由观念提供的。如果人的行为不受理念的影响，人和动物就没有区别。 经济学上讲的理性是工具理性，简单说，就是人的目标是给定的，理性就是选择最有效的方式达到这些目标，最大化我们的偏好，最大化我们的效用。从这个角度看，理性只是人欲望和情感的奴隶，对我们并没有什么好处。而人应该更在乎或者对我们更重要的应该是目标理性，应该弄清楚我们究竟该追求什么？不该追求什么？人应该做欲望和情感的主人，那么这就体现出理念的重要性了，因为我们追求的目标是受我们持有的理念影响的。 理念的力量比利益驱动的力量更加重要在社会变革中体现的尤为显著。比如由共产党领导的新民主主义革命和社会主义革命，并不是农民和工人的利益战胜了地主和资本家的利益，而是马克思主义战胜了其他主义，马克思主义就是一种理念。“文化大革命”之后，邓小平提出的改革开放也是一种新理念战胜旧理念的现象，其中也有一些是利益的驱动，但更重要的的理念的力量，理念的转变。 理念来自哪里？来自思想市场，就是不同的观点、信仰、理念、思想、主张之间平等和自由的竞争。","link":"/2021/02/12/%E7%90%86%E5%BF%B5%E7%9A%84%E5%8A%9B%E9%87%8F/"},{"title":"排序算法","text":"十大经典排序算法 分类 复杂度|排序方法|时间复杂度|空间复杂度||:—-:|:—-|:—-:|:—-|:—-:|:—-||插入排序|O(n^2)|O(1)||希尔排序|O(n^1.3)|O(1)||选择排序|O(n^2)|O(1)||堆排序|O(nlogn)|O(1)||冒泡排序|O(n^2)|O(1)||快速排序|O(nlogn)|O(nlogn)||归并排序|O(nlogn)|O(n)|| | | ||计数排序|O(n+k)|O(n+k)||桶排序|O(n+k)|O(n+k)||基数排序|O(n*k)|O(n+k)| 代码实现 1.插入 1234567891011121314public int[] insertionSort(int[] arr) { int len = arr.length; int preIndex, curr; for (int i = 1; i &lt; len; i++) { preIndex = i - 1; curr = arr[i]; while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; curr) { arr[preIndex + 1] = arr[preIndex]; preIndex--; } arr[preIndex + 1] = curr; } return arr;} 希尔 选择1234567891011121314public int[] selectionSort(int[] arr) { int len = arr.length; int minIndex, temp; for (int i = 0; i &lt; len - 1; i++) { minIndex = i; for (int j = i + 1; j &lt; len; j++) { if (arr[minIndex] &gt; arr[j]) minIndex = j; } temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; } return arr;} 堆排序 冒泡1234567891011121314public int[] bubbleSort(int[] arr) { int len = arr.length; int temp; for (int i = 0; i &lt; len - 1; i++) { for (int j = 0; j &lt; len - 1 - i; j++) { if (arr[j] &gt; arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } return arr;} 快速 归并 计数 桶排序 基数排序4.算法实战 1122. 数组的相对排序 思路：计数排序 题目条件: 0 &lt;= arr1[i] &lt;= 1000; 1、在arr1 中寻找一个最大值 maxNum 并创建一个长度为 maxNum + 1 的数组来记录 arr1 中元素出现的频次； 2、遍历 arr2 中元素，再根据元素在 arr1 中出现的频次，将元素添加至新数组中，并将频次清零； 3、将频次不为 0 的元素按升序添加至新数组； 12345678910111213141516171819202122232425262728293031class Solution {public int[] relativeSortArray(int[] arr1, int[] arr2) { int maxNum = 0; // 寻找arr1中最大的值 for(int num : arr1){ maxNum = Math.max(maxNum,num); } // 将最大值 +1 作为新数组长度，用来记录 arr1 中元素出现的次数 int[] frequency = new int[maxNum + 1]; // 记录元素出现的频次 for(int num : arr1){ ++frequency[num]; } // 循环遍历 arr2 依据每个元素出现的频次来添加数组 int index = 0; int[] res = new int[arr1.length]; for(int num : arr2){ for(int i = 0; i &lt; frequency[num]; i++){ res[index++] = num; } frequency[num] = 0; } // 将不在 arr2 中的元素按升序添加至末尾 for(int i = 0; i &lt;= maxNum; i++){ for(int j = 0; j &lt; frequency[i]; j++){ res[index++] = i; } } return res; }} 242. 有效的字母异位词 123456789class Solution { public boolean isAnagram(String s, String t) { char[] sCharArr = s.toCharArray(); char[] tCharArr = t.toCharArray(); Arrays.sort(sCharArr); Arrays.sort(tCharArr); return new String(sCharArr).equals(new String(tCharArr)); }} 56. 合并区间 1234567891011121314151617181920212223242526class Solution { public int[][] merge(int[][] intervals) { // 对 intervals 按每个区间 intervals[i] 的起点starti排序 Arrays.sort(intervals, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { return o1[0] - o2[0]; } }); // 区间比对并合并组合 // 先存入第一个区间，然后依次取集合中最后一个区间和新区间对比 // 1、如果新区间的起点 start &lt; 最后一个区间的终点，说明两个区间有重叠需要重组合并，然后对比新区间和已有区间的终点值 end ，取相对大的值为新区间 end 值 // 2、不满足条件，说明没重叠，就新增一个区间 List&lt;int[]&gt; merge = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; intervals.length; i++) { int start = intervals[i][0]; int end = intervals[i][1]; if (merge.size() == 0 || merge.get(merge.size() - 1)[1] &lt; start) { merge.add(new int[] {start , end}); } else { merge.get(merge.size() - 1)[1] = Math.max(merge.get(merge.size() - 1)[1], end); } } return merge.toArray(new int[merge.size()][]); }} 493. 翻转对","link":"/2021/02/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"Android性能优化实践笔记","text":"1、绘制原理应用层Android的每个View的绘制中有三个核心步骤：Measure、Layout、Drow 通过measure和layout来确定当前需要绘制的View的大小和位置，通过drow来绘制到surface。绘制源码在ViewRootImp类中的performTraversals()方法实现。 measure：用深度优先原则递归得到所有视图的宽高；获取当前view的正确宽度childWidthMeasureSpec和高度childHeightMeasureSpec，可以调用它的成员函数measure来设置它的大小。 layout：用深度优先原则递归得到所有视图的位置。当一个view在应用程序窗口左上角的位置确定之后，再结合measure过程中获取的宽高就能确定view在窗口中的布局。 drow：Android目前支持两种绘制，软件绘制（CPU）和硬件绘制（GPU），其中Android3.0开始支持硬件加速。硬件加速缺点：a、耗电：因为GPU的耗电比CPU的高；b、兼容问题：某些接口和函数不支持硬件加速；c、内存消耗大：使用OpenGL的接口至少需要8MB内存。 系统层 真正把数据渲染到屏幕上是通过系统进程级进程中的SurfaceFlinger服务来实现的。 大致步骤： 响应客户端事件，创建Layer与客户端的Surface的连接； 接受客户端数据及属性，修改Layer属性，如尺寸、颜色、透明度等； 将创建的Layer内容刷新到屏幕上； 维持Layer的序列，并对Layer最终输出做出裁剪计算； 应用层与系统层的交互，使用了Android的匿名共享内存：SharedClient，每个应用和SurfaceFlinger之间都会创建一个SharedClient。每个SharedClient中最多可创建31个SharedBufferStack（4.1版本以上包含三个缓冲区），一个SharedBufferStack对应一个Surface，也就是一个window。 总结应用层绘制到缓存区，系统层SurfaceFlinger则把缓存区数据渲染到屏幕，中间使用SharedClient共享内存传递数据。 刷新机制Android4.1 Jelly Bean 引入Project Butter 黄油计划 FPS：每秒传输帧数，在60FPS以上人眼看屏幕就感觉不到卡顿，意味着每次绘制时长应该控制在16ms（1000ms/60帧）以内。 三核心元素：VSYNC、Triple Buffer（三级缓冲）和Choreographer（编舞者） 双缓冲：在SharedBufferStack中有两个缓冲区Front Buffer和Back Buffer。UI总是先在Back Buffer中绘制，然后再和Front Buffer交换，渲染到设备屏幕。即只有当另一个buffer的数据准备好后，通过io_ctcl来通知显示设备切换Buffer。 VSYNC：Vertical Synchronization（垂直同步），一旦收到VSYNC中断信号，CPU就开始处理各帧数据。 Choreographer：收到VSYNC信号，调用回调函数。三种类型回调：CALLBACK_INPUT（优先级最高，与输入事件有关）、CALLBACK_ANIMATION（第二优先，与动画有关）、CALLBACK_TRAVERSAL（最低优先级，与UI控件绘制有关） Android屏幕刷新机制 2、卡顿分析工具根本原因：1）绘制任务太重，绘制一帧内容耗时太长；2）主线程太忙，导致VSYNC信号来时还没准备好数据导致丢帧； UI线程（主线程）主要工作： * UI生命周期控制 * 系统事件处理 * 消息处理 * 界面布局 * 界面绘制 * 界面刷新 卡顿解决：尽量避免将其他处理放在主线程中，特别是复杂的数据计算和网络请求； 卡顿检测工具：Profile GPU Rendering（GPU呈现模式分析） 6.0后将每一帧的渲染过程拆分成了八个步骤，每个步骤一种颜色，每种颜色的意义如下： (1)Swap Buffers：表示处理任务的时间，也可以说是CPU等待GPU完成任务的时间，线条越高，表示GPU做的事情越多； (2)Command Issue：表示执行任务的时间，这部分主要是Android进行2D渲染显示列表的时间，为了将内容绘制到屏幕上，Android需要使用Open GL ES的API接口来绘制显示列表，红色线条越高表示需要绘制的视图更多； (3)Sync &amp; Upload：表示的是准备当前界面上有待绘制的图片所耗费的时间，为了减少该段区域的执行时间，我们可以减少屏幕上的图片数量或者是缩小图片的大小； (4)Draw：表示测量和绘制视图列表所需要的时间，蓝色线条越高表示每一帧需要更新很多视图，或者View的onDraw方法中做了耗时操作； (5)Measure/Layout：表示布局的onMeasure与onLayout所花费的时间，一旦时间过长，就需要仔细检查自己的布局是不是存在严重的性能问题； (6)Animation：表示计算执行动画所需要花费的时间，包含的动画有ObjectAnimator，ViewPropertyAnimator，Transition等。一旦这里的执行时间过长，就需要检查是不是使用了非官方的动画工具或者是检查动画执行的过程中是不是触发了读写操作等； (7)Input Handling：表示系统处理输入事件所耗费的时间，粗略等于对事件处理方法所执行的时间。一旦执行时间过长，意味着在处理用户的输入事件的地方执行了复杂的操作； (8)Misc Time/Vsync Delay：表示在主线程执行了太多的任务，导致UI渲染跟不上VSYNC的信号而出现掉帧的情况； TraceView 工具：是AndroidSDK自带的工具，用来分析函数调用过程，可以对Android应用程序以及framework层的代码进行性能分析。 使用方法：1、打开DDMS工具（androidStudio中Android Device Monitor），单击Start Method Profiling按钮开始监控，单击Stop Method Profiling结束监控；2、在需要监控的地方调用android.os.Debug类中提供的方法startMethodTracing()、stopMethodTracing()，保存trace文件来分析。 SystraceUI性能分析工具：是Android4.1及以上版本提供的性能数据采样和分析工具。 3、布局优化布局优化辅助工具：Hierarchy Viewer和Android Lint(可检查xml布局层级和view的个数) 优化方法： 减少层级：合理使用RelativeLayout和LinearLayout，合理使用Merge，使界面尽量扁平化 提高显示速度：合理使用ViweStub，ViewStub的局限性：仅加载一次，不能按需显隐；仅能加载一个布局，而不是具体的View； 布局复用：将可复用的组件抽取出来并通过标签使用； 优化遵循原则： 布局的层级越少，加载速度越快。 减少同一层级控件的数量，加载速度会变快。 一个控件的属性越少，解析越快 优化具体方法总结： 尽量多使用RelativeLayout或LinearLayout 复用布局使用标签 使用标签加载一些不常用布局。 使用标签减少布局的嵌套层次。 尽可能使用固定值，少用wrap_content，会增加布局measure时的计算成本。 删除控件中无用的属性。4、避免过度绘制 导致过度绘制主要原因： xml布局-&gt;控件有重叠且都设置背景 View自绘-&gt;onDraw()方法里面同一区域被绘制多次 监测工具：Show GPU Overdraw 无色：无过度绘制，每个像素绘制一次 蓝色：每个像素被多绘制了一次 绿色：每个像素被多绘制了两次 淡红：每个像素被多绘制了三次 深红：每个像素被多绘制了四次或更多 xml布局优化： 移除xml中非必要的背景，或动态设置背景 移除Window默认的背景，this.getWindow().setBackgroundDrawable(null); 按需显示占位背景图片","link":"/2021/04/06/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/"},{"title":"Android知识学习笔记","text":"Activity相关生命周期： onCreate():Activity被创建 onRestart():Activity被重新启动 onStart():Activity可见，处于后台，还无法与用户交互 onResume():Activity可见，处于前台活动，可与用户交互 onPause():Activity不可见，onPause必须执行完，新Activity的onResume才会执行 onStop():Activity停止，可做一些回收工作 onDestory():Activity销毁，可做一些资源释放工作 不同场景的生命周期： 第一次启动：onCreate-&gt;onStart-&gt;onResume 启动新Activity或切换至桌面：onPause-&gt;onStop ,如果设置透明主题，onStop不会执行 再次启动：onRestart-&gt;onStart-&gt;onResume 点击back键：onPause-&gt;onStop-&gt;onDestory 问题1：当前ActivityA中启动新ActivityB,B的onResume和A的onPause哪个先执行？ onPause执行完才去执行onResume 启动Activity的请求会由Instrumentation来处理，然后它通过Binder向AMS发请求，AMS内部维护着一个ActivityStack并负责栈内的Activity的状态同步，AMS通过ActivityThread去同步Activity的状态从而完成生命周期方法的调用。在ActivityStack中的resumeTopActivityInnerLocked方法中的逻辑可看出，在新的Activity启动之前，栈顶的Activity需要先onPause后新Activity才能启动。而且在官方文档中对onPause的注释是：不能在onPause中做重量级的耗时操作，因为必须onPause执行完以后新Activity才能执行onResume。 异常情况下的生命周期： 场景一：资源相关的系统配置发生改变导致Activity被杀死重建 杀死：Activity-旋转屏幕，分屏-&gt;onPause-&gt;onSaveInstanceState-&gt;onStop-&gt;onDestory 重建：Activity-onCreate-&gt;onStart-&gt;onRestoreInstanceState-&gt;onResume 此场景可通过给configChange属性添加orientation来避免activity被销毁重建 场景二：资源内存不足导致低优先级Activyt被杀死 生命周期同上，此场景可通过onSaveInstanceState的Bundle类型存储一些数据，再从onRestoreInstanceState的Bundle数据中恢复数据。 activity的启动模式 standard:每次启动一个Activity都会重新创建一个新的实例，不管这个实例是否已经存在 singleTop:栈顶复用模式。在这种模式下，如果新Activity已经位于任务栈的栈顶，那么此Activity不会被重新创建，同时它的onNewIntent方法会被回调 singleTask:栈内复用模式,Activity栈中只要有此activity的实例就去复用，并清除栈中此实例以上的activity实例，让其处于栈顶，同时也会调用onNewIntent方法 singleInstance:单例模式，Activity只能单独处于一个任务栈中 使用场景： singleTop：消息推送展示页，新闻详情页 singleTask：主入口，登录页面，订单页面 singleInstance：闹铃提醒界面，来电接听界面 intent中添加flag的类型： Activity的启动流程： 从Launcher启动 三个过程： （1）Launcher请求AMS的过程（2）AMS调用ApplicationThread的过程（3）ActivityThread启动Activity的过程 Launcher程序里点击应用图标时，会通过AMP（ActivityManagerProxy）以Binder的方式通知ActivityManagerService启动应用的入口Activity，ActivityManagerService发现这个应用还未启动，会以Socket的方式通知Zygote进程fork出一个app进程，然后在这个app进程里执行ActivityThread的main方法。接着app进程通过AMP以Binder的方式通知ActivityManagerService应用进程已启动，然后ActivityManagerService保存应用进程的一个代理对象ATP（ApplicationThreadProxy），并通过这个代理对象ATP控制应用进程，然后ActivityManagerService通知应用进程创建入口Activity的实例，最终ApplicationThread通过UI线程中的Handler以发送消息的方式来执行它的生命周期方法。 问题1：如何跨app启动Activity？有哪些注意事项？ 1)设置android:exported=”true”启动方式： 123Intent intent = new Intent();intent.setComponent(new ComponentName(&quot;com.xxx.xxx&quot;,&quot;com.xxx.xxx.MainActivity&quot;));startActivity(intent); 2)使用IntentFilter方式 123&lt;intent-filter&gt; &lt;action android:name=&quot;xxx.xxx.xxx.action&quot; /&gt;&lt;/intent-filter&gt; 注意事项：添加权限保护 12345&lt;uses-permission android:name=&quot;android.permission.xxx&quot; /&gt;&lt;activity android:name=&quot;.activity.BaseActivity&quot; android:exported=&quot;true&quot; android:permission=&quot;android.permission.xxx&quot;&gt;&lt;/activity&gt; 拒绝服务漏洞ActivityA向ActivityB传递了一个B中不存在的数据类型SerializableA导致App运行时异常崩溃 解决方案：Activity中读取Intent的Extras,使用try catch包裹代码 问题2：如何解决Activity参数传递的类型安全以及接口复杂的问题？ 传统传参方式的弊端： 类型安全：Bundle的K - V不能在编译期间保证类型 接口繁琐：启动Activity时参数和结果传递都依赖Intent 解决方案：设计一个基于注解处理器实现的简化参数传递的框架，比如EventBus Service相关生命周期： bindService/unbindService()：onCreate()-&gt;onStartCommand()-&gt;onDestory() startService/stopService()：onCreate()-&gt;onBind()-&gt;onDestory() BroadcastReceiver相关静态注册：常驻，静态注册就是在AndroidManifest中注册BroadcastReceiver，并指定它所接收的广播种类 动态注册：非常驻，registerReceiver/unregisterReceiver 广播种类 无序广播：所有与intent匹配的BroadcastReceiver都可接受广播，而且不分先后顺序 有序广播：Context.sendOrderedBroadcast()发送，设置优先级android:priority，按优先级先后接受广播，使用setResult()把结果传递给下一个接受者，getResult()方法获取接受到的结果，通过abortBroadcast()丢弃广播 粘性广播：Context.sendStickBroadcast()发送，发送的广播会一直滞留，当有匹配此广播的接收器被注册后，该广播接收器就会收到此广播。需要获得一下权限 1&lt;uses-permission android:name=&quot;android.permission.BROADCAST_STICKY&quot; /&gt; 系统广播：开机广播、来电广播、锁屏等本地广播：通过LocalBroadcastManager操作 注册：LocalBroadcastManager.getInstance(mContext).registerReceiver(mReceiver)； 发送：LocalBroadcastManager.getInstance(mContext).sendBroadcast(intent); 注销：LocalBroadcastManager.getInstance(mContext).unregisterReceiver(mReceiver)； ContentProvider相关 View绘制首先需要了解View是如何被添加到屏幕窗口上的 1、创建顶层布局容器DecorView 2、在顶层布局中根据不同的theme加载不同的基础布局ViewGroup 3、将main_activity.xml通过LayoutInflate添加到基础布局中的FrameLayout（R.id.content）中 绘制流程： 1、绘制入口： ActivityThread.handleResumeActivity-&gt;WindowManagerImpl.addView(decorView,layoutParams)-&gt;WindowManagerGlobal.addView() 2、绘制的类及方法 ViewRootImpl.setView(decorView,layoutParams,parentView)-&gt; ViewRootImpl.requestLayout-&gt;scheduleTraversals()-&gt;doTracersal()-&gt;performTraversals() 3、绘制的三大步骤 测量：ViewRootImpl.performMeasure MeasureSpec(32位 int) = SpecMode（前2位） + SpecSize（后30位） UNSPECIFIED：父容器不对View做任何限制，一般是系统内部使用 EXACTILY：精确大小，父容器检测出View的大小，就是SpecSize。一般是LayoutParams设定match_parent或固定大小 AT_MOST：view不能超出父容器可用的大小，对应LayoutParams中设定wrap_content ViewGroup测量：measure-&gt;onMeasure-&gt;measureChildWithMargins(遍历子View，并测量子View)-&gt;setMeasureDimension-&gt;setMeasureDimensionRaw（保存自己的宽高） View的测量：measure-&gt;onMeasure-&gt;setMeasureDimension-&gt;setMeasureDimensionRaw（保存自己的宽高） 布局：ViewRootImpl.performLayout View：调用view.layout根据测量结果确定自身在父容器中的位置，即确定mLeft\\mTop\\mRight\\mBottom的值 ViewGroup：需要实现onLayout()方法，确定ziView的摆放位置 绘制：ViewRootImpl.performDraw 绘制背景：drawBackground（canvas） 绘制自己：onDraw（canvas） 绘制子View：dispatchDraw(canvans) 绘制前景，滚动条等装饰onDrawForeground(canvas) 事件分发机制事件的类型： MotionEvent.ACTION_DOWN MotionEvent.ACTION_MOVE MotionEvent.ACTION_UP MotionEvent.ACTION_CANCEL 主要方法： dispatchTouchEvent(MotionEvent event)：用来进行事件分发 onInterceptTouchEvent(MotionEvent event)：判断是否拦截事件，仅存在于ViewGroup，同一事件序列中仅执行一次 onTouchEvent(MotionEvent event)：消费事件 分发流程： Activity：activity-&gt;Window-&gt;DecorView-&gt;ViewGroup ViewGroup的事件分发：onInterceptTouchEvent默认返回false,不拦截任何事件 12345678910111213伪代码public boolean dispatchTouchEvent(MotionEvent event){ boolean concume = false; // 判断是否拦截DOWN事件 if(onInterceptTouchEvent(event)){ // 调用自身onTouchEvent concume = onTouchEvent(event); }else{ // 将事件分发给子View concume = child.dispatchTouchEvent(event); } return concume;} View：没有onInterceptTouchEvent方法，onTouchEvent()默认返回true，默认消耗事件（除非clickable和longClickable同时都为false）首先会判断有没有设置OnToucheListener，如果onTouch返回true，优先处理外部点击事件。 View的enable属性不影响onTouchEvent的默认返回值。 问题1：实际项目中的滑动冲突解决规则以及方案 如何判断上下和左右滑动：根据滑动路劲于水平方向的夹角，水平滑动和竖直滑动距离长短以及滑动的速度差 1、外部拦截法：重写onInterceptTouchEvent方法返回false；重写onTouchEvent方法，并根据业务逻辑处理MOVE事件； 2、内部拦截法：需配合parent.requestDisallowInterceptTouchEvent方法，父元素拦截事件 Handler原理Handler的作用主要是用来线程间收发消息，Handler的运行需要底层的MessageQueue和Looper的支撑，MessageQueue采用的是单链表的数据结构来存储消息列表，Looper起消息轮询的作用。 工作流程：Handler通过send和post方法将消息通过MessageQueue的enqueueMessage方法放入消息队列，然后Looper通过loop方法轮询消息，发现有新消息，就会处理这个消息，最终消息中的Runnable或Handler的handleMessage方法会被调用。 问题1：系统为什么不允许在子线程中访问UI呢？ 原因是UI线程不是线程安全的，多并发访问会导致UI控件状态异常。如果通过加锁来控制的话会使UI访问逻辑变复杂从而会降低UI访问的效率。 问题2：ThreadLocal是如何将线程和Looper绑定的？ Looper中定义了一个静态常量ThreadLocal，当调用Looper.prepare()会将一个Looper对象实例存入ThreadLocal内部类ThreadLocalMap中，而其实在ThreadLocal的set方法中会通过creatMap方法初始化ThreadLocalMap将当前线程和ThreadLocalMap绑定了，而且Map中存储的是一个软引用对象Entry[] table数组，key是ThreadLocal，value是ThreadLocal设置的值。如果使用不当容易导致内存泄漏，所以 使用完成后手动执行remove方法或将threadLocal定义为private static，可随线程一起消亡。 问题3：Looper中的loop死循环为什么不会卡死，是不是特别消耗CPU资源 死循环是为了保证程序能够一直运行下去不会退出，真正会卡死UI主线程的是执行onCreate/onStart/onResum等操作的时间过长，会导致掉帧，甚至发生ANR，Looper.loop本身不会导致应用卡死。****** 参考 IPC（Inter-Process Communication）机制传递方式 Bunble： 共享文件： Messager： AIDL： ContentProvider： OOM问题分析内存分析工具：Memory Monitor、Heap Viewer、Allocation Tracker ANR问题分析Android异步任务处理Android常见架构模型设计一个网络框架设计一个图片加载框架如何性能优化启动优化： 测量启动时间：logcat日志（displayed的值）、adb命令、手动代码打点获取（一般线上统计 ） 方法耗时统计： traceview统计：Debug.startMethodTracing()/Debug.stopMethodTracing()，查看本地trace文件 systrace统计：Trace.beginSection()/Trace.endSection()，保存html文件，UI卡顿也能检测 冷启动、热启动、温启动 黑白屏优化：设置自定义Theme、设置系统的取消预览为true，设置背景为透明 优化方式：异步初始化、延迟初始化、空闲时初始化（IdleHandler） 布局优化： 内存优化： 线程优化： 网络优化： 电量优化： 设计一个log收集系统","link":"/2021/04/06/Android%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Java知识学习笔记","text":"1、常见设计模式有哪些？创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 2、设计模式七大原则1.开闭原则 （Open Close Principle） 对扩展开放，对更改关闭 -保证以前代码的准确性，使开发者更专注于新扩展的代码上 2.单一职责原则 （Single Responsibility Principle） 一个类只负责一个功能领域的职责 -降低类的复杂度，当修改一个功能时，降低对其他功能的影响，提供类的可读性 3.里氏替换原则 （Liskov Substitution Principle） -任何基类出现的地方，子类一定可以出现 -在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象，开闭原则实现的手段之一 4.依赖倒转原则 （Dependence Inversion Principle） -针对接口编程，抽象不依赖于细节，细节应依赖于抽象 -多数情况下，开闭原则，里氏替换原则，依赖倒转原则会同时出现，开闭原则是目标，里氏替换原则是基础，依赖倒转是手段。 5.接口隔离原则 （Interface Segregation Principle） -使用多个专门的接口，不使用单一的总接口 -当一个接口太大时，我们需要把他拆分成更小的接口，但不能违反单一职责原则，每个接口应该承担一种相对独立的角色，不该干的事情不干，该干的事情都要干。 6.迪米特法则 （Law Of Demeter） -一个实体应当尽量少的与其他实体发生相互作用 应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。 7.合成复用原则（Composite Reuse Principle） -尽量使用组合而非继承 -就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，新的对象通过这些对象的委派达到复用已有功能的目的 3、举例实现其中几种设计模式（单例模式）：单例模式：懒汉式（双重校验模式） 1234567891011121314151617public class Singleton { // 必须使用volatile修饰，保证线程间可见性 private static volatile Singleton instance = null; // 必须私有化构造方法，保证实例唯一性 private Singleton() { } public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; }} 问题1：说说两次判空的意义是什么？第一次判空：假设没有第一次不判空校验，那么每个线程每次获取实例时都会执行一次同步代码块拿到锁对象才能执行下去，如果锁对象被其他线程持有时就需要等待锁被释放才能使用，降低了程序的效率。而有了第一次判空，只需要首次初始化的时候才会执行同步代码块，大大提高了程序的执行效率。 第二次判空：假设没有第二次判空验校，线程A执行到第一次判空验校那里，它判断到instance== null。此时它的资源被线程B抢占了，B执行程序，进入同步代码块创建对象，然后释放同步锁，此时线程A又拿到了资源也拿到了同步锁，然后执行同步代码块，因为之前线程A它判断到instance==null，因此它会直接创建新的对象。所以就违反了我们设计的最终目的。 问题2：说说为什么加volatile关键字？ volatile关键字的特性：可见性，有序性（禁止指令重排），不具备原子性 问题3：volatile如何保证可见性 在x86处理器下通过工具获取JIT编译器生成的汇编指令来看看对Volatile进行写操作CPU会做什么事情。 |Java代码：|instance = new Singleton();//instance是volatile变量||:—-|:—-|:—-||汇编代码：|0x01a3de1d: movb $0x0,0x1104800(%esi);0x01a3de24: lock addl $0x0,(%esp);| 有volatile变量修饰的共享变量进行写操作的时候会多第二行汇编代码，通过查IA-32架构软件开发者手册可知，lock前缀的指令在多核处理器下会引发了两件事情。 将当前处理器缓存行的数据会写回到系统内存。 这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。 处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（L1,L2或其他）后再进行操作，但操作完之后不知道何时会写到内存，如果对声明了Volatile变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址的数据被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。 回答：系统内存中的insatance共享变量,当多个线程并发访问这个对象时,如上图cpu1通过threadA访问instance,cpu2通过threadB访问instance,处理器为了提高处理速度,不直接和内存进行通讯,而是先将系统内存的数据读到cache再进行操作,如果变量instance被volatile关键字修饰,cpu1修改cache中的instance数据会立马通过系统总线写到系统内存,其他处理器通过嗅探总线上传播的数据来检查自己缓存的值是不是过期了,当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。 问题4：说说volatile禁止指令重排的作用 首先了解一个概念：内存屏障，它是一个CPU指令，作用如下： 1、保证特定操作的执行顺序； 2、保证某些变量的内存可见（利用此特性实现volatile的内存可见性）。 由于编译器和处理器都能执行指令重排优化，如果在指令间插入一条Memory Barrier（内存屏障）指令，则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。内存屏障另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。 instance = new Singleton()；// 实例化一个对象的指令执行过程 1、为对象分配内存空间 2、初始化对象 3、将引用指向对象的内存空间地址 但是虚拟机执行的时候不一定是按123的顺序执行的。 假设没有volatile关键字修饰，线程A执行 instance = new Singleton()；虚拟机是按132排序执行，当执行到3的时候single 引用已经不为空。此时若线程B执行到第一次验校处(第一次验校不在同步代码中，因此所有线程随时都可以访问)，它判断 instance == null 得到false,直接返回instance 对象。但是此时instance 对象还没初始化完成，因此很有可能就会发生bug。 抽象工厂模式：制造手机的工厂 首先创建一个手机的公共接口 123public interface Phone { public abstract void showPhone();} 再分别实现Android和iOS系统手机的实现类 123456public class AndroidPhone implements Phone { @Override public void showPhone() { System.out.println(&quot;AndroidPhone&quot;); }} 123456public class IosPhone implements Phone{ @Override public void showPhone() { System.out.println(&quot;IosPhone&quot;); }} 然后创建一个公共手机工厂 123public interface PhoneFactory { public abstract Phone createPhone();} 再分别实现两种手机的工厂实现类 123456public class AndroidPhoneFactory implements PhoneFactory { @Override public Phone createPhone() { return new AndroidPhone(); }} 123456public class IosPhoneFactory implements PhoneFactory { @Override public Phone createPhone() { return new IosPhone(); }} 使用方法： 12new AndroidPhoneFactory().createPhone().showPhone();new IosPhoneFactory().createPhone().showPhone(); 构建者模式： 1234567891011121314151617181920212223242526272829303132333435363738394041public class Phone { private String model;// 型号 private String system;// 系统 private String screen;// 屏幕 private String camera;// 摄像头 // 必须使用私有化无参构造方法，防止外部创建实例对象 private Phone() { } public static class Builder { private String model;// 型号 private String system;// 系统 private String screen;// 屏幕 private String camera;// 摄像头 public Builder() { } public Builder setModel(String model) { this.model = model; return this; } public Builder setSystem(String system) { this.system = system; return this; } public Builder setScreen(String screen) { this.screen = screen; return this; } public Builder setCamera(String camera) { this.camera = camera; return this; } public Phone build() { Phone phone = new Phone(); phone.model = model; phone.system = system; phone.screen = screen; phone.camera = camera; return phone; } }} 用法： 123456789101112Phone android = new Phone.Builder() .setModel(&quot;android10&quot;) .setScreen(&quot;三星&quot;) .setCamera(&quot;徕卡&quot;) .setSystem(&quot;Android&quot;) .build();Phone ios = new Phone.Builder() .setModel(&quot;ios10&quot;) .setScreen(&quot;三星&quot;) .setCamera(&quot;苹果&quot;) .setSystem(&quot;ios&quot;) .build(); Builder设计模式的好处是我们可以随意组合类相同类型输入的参数，不仅避免了方法重载出错的问题，还不需要写过多的构造器。 观察者模式： 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.Observable;// 被观察public class Phone extends Observable { private String model;// 型号 private String system;// 系统 private String screen;// 屏幕 private String camera;// 摄像头 public void setModel(String model) { this.model = model; // 通知观察者参数发生改变 setChanged(); notifyObservers(); } public void setSystem(String system) { this.system = system; setChanged(); notifyObservers(); } public void setCamera(String camera) { this.camera = camera; setChanged(); notifyObservers(); } public void setScreen(String screen) { this.screen = screen; setChanged(); notifyObservers(); } public String getModel() { return model; } public String getSystem() { return system; } public String getScreen() { return screen; } public String getCamera() { return camera; }} 1234567891011import java.util.Observable;import java.util.Observer;// 设计师，观察者public class Designer implements Observer { @Override public void update(Observable observable, Object o) { Phone phone = (Phone) o; String camera = phone.getCamera(); System.out.println(camera); }} 1234567891011import java.util.Observable;import java.util.Observer;// 生产者，观察者public class Producer implements Observer { @Override public void update(Observable observable, Object o) { Phone phone = (Phone) o; String camera = phone.getCamera(); System.out.println(camera); }} 使用方法： 123456789101112// 被观察者Phone phone = new Phone();// 观察者Designer designer = new Designer();Producer producer = new Producer();// 添加观察者phone.addObserver(designer);phone.addObserver(producer);// 发生改变phone.setCamera(&quot;三星&quot;);// 删除观察者phone.deleteObserver(designer); 4、JVM内存相关jvm运行时数据区划分 方法区：class会被加载到方法区，当JVM使用类加载器定位class文件，并将其载入到内存中，会提取class文件的类型信息，并将这些信息存储到方法区中，同时，放入方法区中的还有该类型中的类静态变量。【类型信息，方法信息，方法表，静态变量】 堆区：Java程序在运行时创建的所有类型对象和数组都存储在堆中/JVM会根据new指令在堆中开辟一个确定类型的对象内存空间。但是堆中开辟对象的空间并没有任何人工指令可以回收，而是通过JVM的垃圾回收器负责回收。 栈区：方法的执行是在虚拟机，Java方法执行存储在栈区，每个Java方法对应一个栈帧。每启动一个线程，JVM都会为它分配一个Java栈，用于存放方法中的局部变量，操作数以及异常数据等。当线程调用某个方法时，JVM会根据方法区中该方法的字节码组建一个栈帧，并将该栈帧压入Java栈中，方法执行完毕时，JVM会弹出该方法栈并释放掉。 本地方法栈(Native 堆)：本地方法栈的功能和特点类似于虚拟机栈，不同的是，本地方法栈服务的对象是JVM执行的native方法，而虚拟机栈服务的是JVM执行的java方法。 程序计数器(PC寄存器)：程序计数器是一个记录着当前线程所执行的字节码的行号指示器。 JAVA代码编译后的字节码在未经过JIT（实时编译器）编译前，其执行方式是通过“字节码解释器”进行解释执行。简单的工作原理为解释器读取装载入内存的字节码，按照顺序读取字节码指令。读取一个指令后，将该指令“翻译”成固定的操作，并根据这些操作进行分支、循环、跳转等流程。 GC 标记算法 引用计数法:每一个对象都有一个引用计数器,当有任何一个对象引用了它,那么引用计数器count+1,当这个引用失效,引用计数器count-1,当一个对象的引用计数器count==0时,说明这个对象不再被使用了,也就标记为垃圾对象了.但是此算法无法消除循环引用的垃圾对象 可达性分析:检索GC Root的引用链,如果一个对象不再任何GC Root的引用链上,说明此对象不再使用,可标记为垃圾对象. 问题1:哪些对象可做为GC Root呢? 1)Java虚拟机栈中引用的对象; 2)方法区中类静态成员引用的对象(static修饰的成员变量); 3)方法区中常量引用的对象(主要是final修饰的变量); 4)本地方法栈中JNI引用的对象. GC 回收算法 1)标记-清除算法:分两步,先标记后清除.首先遍历所有的根结点,将这些根结点的可达性对象标记为存活对象,不可达对象标记为垃圾对象,然后遍历堆中所有对象,清除垃圾对象,释放内存.此算法缺点:内存容易产生碎片化,利用率不够,而且算法执行效率也不高. 2)标记-复制算法:将内存空间一分为二,当一半空间快要用完时,将还存活的对象复制到另一半空间去,然后清除使用过的这一半内存空间. 缺点:只能利用一半的内存空间,利用率不高,但是解决了内存碎片化的问题 3)标记-压缩算法:需要将存活的对象先转移到内存区域的一端,然后清除区域外的内存.这样能有效的利用内存空间,但是压缩过程比较耗时. GC 分代收集算法 首先根据对象存活的时间将JVM堆内存空间区分为新生代,老年代和永久代(JDK8后变为元空间) 新生代**（Young generation）****:**存放一些生命周期较短的对象,会频繁发现大量垃圾,采用”标记-复制”算法. 在新生代中又分为Eden区、SurvivorFrom区、SurvivorTo区,默认比例8:1:1 回收原理： 绝大多数刚刚被创建的对象会存放在Eden区。 在Eden区执行第一次GC（Minor GC）之后，存活的对象被移动到其中一个Survivor空间（如S1，S1为From区域），Eden区会被清空。 再次Eden区执行GC后（Minor GC 是对整个新生代检查，不仅仅是Eden区），如果幸存者空间S1的对象依旧还存活，那么这些存活的对象年龄增加。然后所有还存活的对象会被移动到另一个Survivor空间（如S2，S2是下次Minor GC的From区域）中，Eden空间和Survivor空间S1会被清空。 以上步骤执行N（N = MaxTenuringThreshold（年龄阀值设定，默认15））次之后，依然存活的对象，就会被移动到老年代。 一般来说，新生代对象要经历N次MinorGC之后才会被移动到老年代。不过也有例外，对于一些比较大的**对象**（需要**分配**一块比较大的连续内存**空间**）**，**则直接进**入**到**老年代。**一般在**Survivor**空间不足的情况下发生。 老年代（Old******gene**r**at**io**n）** 老年代只有一个区域，但是这块区域很大，默认大小是新生代的2倍，正因如此，发生在老年代的GC（发生在老年代的GC叫Full GC）次数要比新生代少得多，而且做一次Full GC 的时间比Minor GC 要更长（约10倍）。采用”标记-压缩”和”标记-清除”算法. 持久代（Perm**a**n**en**t gene**r**at**i**o**n**） 也称之为 方法区（Methodarea）：用于保存类常量以及字符串常量。注意，这个区域不是用于存储那些从老年代存活下来的对象，这个区域也可能发生GC。发生在这个区域的GC事件也被算为 Full GC。 5、类加载相关1)类加载流程: 加载:根据路径找到相应的class文件然后导入 验证:检查加载的class文件的正确性 准备:给类中的静态变量分配内存空间,并赋予默认值 解析:虚拟机将常量池中的符号引用替换成直接引用的过程,也就是直接指向内存地址; 初始化:对静态变量和静态代码块执行初始化工作. 2)抽象类和接口区别 接口中所有的方法都是抽象方法,而抽象类中可以同时包含抽象方法和非抽象方法 一个类可以实现多个接口,但是只能继承一个抽象类 接口中声明的变量默认都是final的,抽象类中可以包含非final的变量 接口中的方法默认都是public的,抽象类中可以是private,protected和public的 接口和抽象类都不能被实例化 JDK1.8中对接口增加了新的特性： （1）、默认方法（default method）：JDK 1.8允许给接口添加非抽象的方法实现，但必须使用default关键字修饰；定义了default的方法可以不被实现子类所实现，但只能被实现子类的对象调用；如果子类实现了多个接口，并且这些接口包含一样的默认方法，则子类必须重写默认方法； （2）、静态方法（static method）：JDK 1.8中允许使用static关键字修饰一个方法，并提供实现，称为接口静态方法。接口静态方法只能通过接口调用（接口名.静态方法名）。 3)泛型理解 泛型:本质是参数化类型 使用:泛型类,泛型接口,泛型方法 特性:只在编译期有效,对编译器可见,jvm不可见.通过泛型擦除机制将泛型处理成普通类\\方法\\接口 作用:避免了类型转化的消耗,提供了编译期的类型安全保障,兼容了Java1.5之前的版本 泛型擦除规则: 如果没指定具体类型或&lt;?&gt;,用Object作为原始类型 如果有上限类型 ,使用 ParentClass作为原始类型,表示参数化的类型可能是所指类型或是此类型的子类 如果有下限,使用Object类型作为原始类型,表示参数化的类型可能是所指定的类型或此类型的父类 回答点：泛型类、泛型接口、泛型方法、泛型通配符、泛型擦除 实现机制：泛型本质是将数据类型参数化，它通过擦除的方式来实现。声明了泛型的 .java 源代码，在编译生成 .class 文件之后，泛型相关的信息就消失了。可以认为，源代码中泛型相关的信息，就是提供给编译器用的。泛型信息对 Java 编译器可以见，对 Java 虚拟机不可见。 Java 编译器通过如下方式实现擦除： ·用 Object 或者界定类型替代泛型，产生的字节码中只包含了原始的类，接口和方法； ·在恰当的位置插入强制转换代码来确保类型安全； ·在继承了泛型类或接口的类中插入桥接方法来保留多态性 泛型擦除优点：运行时内存负担小、兼容旧版本、 泛型缺点：基本类型无法作为泛型实参泛型类型无法用作方法重载 Java方法分派 重载：同一个类中方法名相同，参数列表不同，返回类型可相同可不同 重写：子类继承父类的方法，参数列表和返回值类型都必须相同 总结：静态分派—方法重载分派 编译期确定 依据调用者的声明类型和方法参数类型 动态分派—方法重写分派 运行时确定 依据调用者的实际类型分派 匿名内部类理解: 对匿名内部类的构造方法的总结： A、编译器帮助生成构造方法 B、参数列表包括 l外部对象（定义在非静态域内） l父类的外部对象（父类非静态） l父类的构造方法参数（父类有构造方法且参数列表不为空） l外部捕获的变量（方法体内有引用外部final变量） Java中的自动装箱和拆箱 当我们变量声明为对象类型而赋值为基本数据类型时，Java编译器会对我们的基本数据类型进行装箱，而我们的变量声明为基本类型赋值为对象类型时，编译器又会对我们的对象类型进行拆箱处理。valueOf作为装箱方法，基本数据类型加上Value做为拆箱方法如intValue，longValue，booleanValue。 为什么要使用包装类？ 1）对象是对现实世界的模拟，基本类型都有默认值，对象的默认值为null，而且是在堆中开辟空间 2）为泛型提供了支持 3）包装类提供了丰富的属性和API 6、多线程，线程池、锁线程的几种状态以及工作流程: 状态:New(新建状态)\\Runnable(就绪状态)\\Running(运行状态)\\Blocked(阻塞状态)\\Dead(死亡状态) New:Thread被创建,还未调用start方法,线程处于新建状态 Runnable:调用start方法后进入就绪状态,等待CPU资源,将Running状态的线程调用yield方法让出CPU资源后处于就绪状态,等待获取CPU资源,调用wait方法处于Blocked状态的线程调用notify/notiyAll唤醒后也处于就绪状态. Running:运行状态,线程获取到CPU资源执run方法 Blocked:线程未执行完毕,由于I/O操作或调用wait,sleep方法,让出CPU资源,处于阻塞状态 Dead:死亡状态,线程正常执行完毕后自动停止或执行过程中发生异常,处于死亡状态 sleep和wait区别 sleep是Thread的静态方法,wait是Object中的方法 调用sleep后,线程暂停指定的一段时间后去接着执行,期间不会释放锁对象 调用wait后,线程处于阻塞状态,需要调用notify/notifyAll方法后从等待池进入锁池中去竞争锁,才能重新获取CPU执行时间 wait,notify,notifyAll必须是在synchronized函数或代码块中进行调用,并且必须持有相同的锁对象,不然会发生异常. yield方法: 使当前线程重新回到可执行状态,所以执行yield的线程有可能进入可执行状态后立马被执行 但仅能是同优先级或高优先级的线程有执行机会 join方法: 等待该线程执行完毕 notify/notifyAll区别 notify:会将该锁对象中等待队列中的一个线程加入到锁池中去竞争锁 notifyAll:会将锁对象中等队列中的所有线程加入到锁池中去竞争锁,按线程优先级执行 问题1:如何停止一个线程? Stop方法为什么被废弃了？因为线程会持有内存锁对象，线程暂停不释放锁对象可能会导致死锁，如果线程立即停止并释放锁可能会导致内存读写异常。 正确的处理方案：应该是停止任务执行，让线程自动停止 方式一：interrupt 方式二：boolean 标记位 要保证线程间可见性，加volatile关键字修饰 interrupted() 与 isInterrupted()区别 interrupted() 是静态方法，获取当前线程的中断状态，并清空状态，后续调用返回false； isInterrupted() 是非静态方法，获取当前线程的中断状态，不清空状态，可重复调用，中断清空前一直返回true； 问题2:如何写出线程安全的程序? 什么是线程安全？多线程执行时，可变资源（内存）线程间共享 如何保证线程安全？不共享资源、共享不可变资源、保证共享资源的可见性、原子性、禁止指令重排优化 1）不共享资源：ThreadLocal，每个线程访问的都是线程自己内部的副本 原理：底层实际是用ThreadLocalMap 和 thread绑定了的，key就是ThreadLocal，value就是你想要传入的值；ThreadLocalMap 对象持有弱引用，线程退出后引用被移除，Hash冲突使用的是开放定址法，Hash计算使用的是神奇数字的倍数，适合对象较少的使用场景。ThreadLoacat使用建议：声明为全局静态final成员、避免存储大量对象、用完后及时移除对象。 2）共享不可变资源 final 关键字修饰成员变量除了初始化后不能修改，还有能禁止指令重排序的作用 3）禁止重排序 volatile，理解原理 4）保证可见性：使用final和volatile关键字，还有加锁的方式，锁释放时会强制将缓存刷新到主内存，并使引用该实例的。 5）保证原子性：a++为什么不是原子性操作，因为中间会生成临时变量； 保证原子性的方法：加锁，保证操作的互斥性；使用CAS指令（如Unsafe.compareAndSwapInt）；使用原子数值类型（如AtomicInteger）；使用原子属性更新器（AtomicReferenceFieldUpdater） 问题3:ThreadLocal原理是什么?如何与线程绑定 1.每个Thread线程内部都有一个ThreadLocalMap。 2.Map里面存储线程本地对象ThreadLocal（key）和线程的变量副本（value）。3.Thread内部的Map是由ThreadLocal维护，ThreadLocal负责向map获取和设置线程的变量值。 4.一个Thread可以有多个ThreadLocal。 问题4:synchronized原理 属于独占式的悲观锁,同时也属于可重入锁 Java中的每个对象都有个monitor对象,加锁就是在竞争monitor对象,对代码块加锁是通过在前后分别加上monitorenter和monitorexit指令实现的,对方法是否加锁是通过一个标记位来判断 synchronized的作用范围: synchronized作用于成员变量和非静态方法时，锁住的是对象的实例，即this对象。 synchronized作用于静态方法时，锁住的是Class实例，因为静态方法属于Class而不属于对象。 synchronized作用于一个代码块时，锁住的是所有代码块中配置的对象。 问题5:volatile原理,如何保证可见性? 在x86处理器下通过工具获取JIT编译器生成的汇编指令来看看对Volatile进行写操作CPU会做什么事情。 |Java代码：|instance = new Singleton();//instance是volatile变量||:—-|:—-|:—-||汇编代码：|0x01a3de1d: movb $0x0,0x1104800(%esi);0x01a3de24: lock addl $0x0,(%esp);| 有volatile变量修饰的共享变量进行写操作的时候会多第二行汇编代码，通过查IA-32架构软件开发者手册可知，lock前缀的指令在多核处理器下会引发了两件事情。 将当前处理器缓存行的数据会写回到系统内存。 这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。 处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（L1,L2或其他）后再进行操作，但操作完之后不知道何时会写到内存，如果对声明了Volatile变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。 问题6:创建线程的几种方法 继承Thread类,实现Runnable接口重写run方法,实现有回调的callback接口,采用线程池管理线程的方式 线程池原理 ThreadPoolExecutor创建基本线程池,构造方法的参数 corePoolSize:核心线程数 maximumPoolSize:最大线程数 keepAliveTime:非核心线程空闲等待时间 unit:keepAliveTime参数单位 workQueue:任务队列 LinkedBlockQueue 阻塞队列(基于单链表实现) threadFactory:线程工厂,设置线程名称 工作流程: 1.execute一个线程之后，如果线程池中的线程数未达到核心线程数，则会立马启用一个核心线程去执行。 2.execute一个线程之后，如果线程池中的线程数已经达到核心线程数，且workQueue未满，则将新线程放入workQueue中等待执行。 3.execute一个线程之后，如果线程池中的线程数已经达到核心线程数但未超过非核心线程数，且workQueue已满，则开启一个非核心线程来执行任务。 4.execute一个线程之后，如果线程池中的线程数已经超过非核心线程数，则拒绝执行该任务，采取饱和策略，并抛出RejectedExecutionException异常。 几种常用线程池 FixedThreadPool:可重用固定线程,只有核心线程,无非核心线程,并且阻塞队列无界 CacheThreadPool:缓存线程池,无核心线程,只有非核心线程,空闲等待时间60s,采用SynchronousQueue同步队列 SingleThreadPool:单个线程的线程池 ScheduledThreadPool:定时延时执行线程池 自定义线程池(PriorityThreadPool):按优先级执行任务的线程池,自定义实现Runnable和Comparable接口 Java中的锁: **乐观锁:**每次都数据都认为别人不会修改数据,所以不上锁,但是更新数据时会判断在此期间别人有没有更新该数据.乐观锁大部分是通过CAS操作实现的,CAS是一种原子更新操作，在对数据操作之前首先会比较当前值跟传入的值是否一样，如果一样则更新，否则不执行更新操作，直接返回失败状态。 **悲观锁:**在每次读取数据时都认为别人会修改数据，所以每次在读写数据时都会上锁，这样别人想读写这个数据时就会阻塞、等待直到拿到锁。Java中的悲观锁大部分基于AQS（AbstractQueued Synchronized，抽象的队列同步器）架构实现。该框架下的锁会先尝试以CAS乐观锁去获取锁，如果获取不到，则会转为悲观锁（如RetreenLock）。 **自旋锁:**如果持有锁的线程能在很短的时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞、挂起状态，只需等一等（也叫作自旋），在等待持有锁的线程释放锁后即可立即获取锁，这样就避免了用户线程在内核状态的切换上导致的锁时间消耗。减少CPU上下文的切换,但若自旋时间过长将引起CPU的浪费,适合占用锁的时间短或锁竞争不激烈的代码块来说性能大幅度提升. synchronized和ReentrantLock的比较 synchronized和ReentrantLock的共同点如下。 ◎ 都用于控制多线程对共享对象的访问。 ◎ 都是可重入锁。 ◎ 都保证了可见性和互斥性。 synchronized和ReentrantLock的不同点如下。 ◎ ReentrantLock显式获取和释放锁；synchronized隐式获取和释放锁。为了避免程序出现异常而无法正常释放锁，在使用ReentrantLock时必须在finally控制块中进行解锁操作。 ◎ ReentrantLock可响应中断、可轮回，为处理锁提供了更多的灵活性。 ◎ ReentrantLock是API级别的，synchronized是JVM级别的。 ◎ ReentrantLock可以定义公平锁。 ◎ ReentrantLock通过Condition可以绑定多个条件。 ◎ 二者的底层实现不一样：synchronized是同步阻塞，采用的是悲观并发策略；Lock是同步非阻塞，采用的是乐观并发策略。 ◎ Lock是一个接口，而synchronized是Java中的关键字，synchronized是由内置的语言实现的。 ◎ 我们通过Lock可以知道有没有成功获取锁，通过synchronized却无法做到。 ◎ Lock可以通过分别定义读写锁提高多个线程读操作的效率。 AtomicInteger 在多线程程序中，诸如++i或i++等运算不具有原子性，因此不是安全的线程操作。我们可以通过synchronized或ReentrantLock将该操作变成一个原子操作，但是synchronized和ReentrantLock均属于重量级锁。因此JVM为此类原子操作提供了一些原子操作同步类，使得同步操作（线程安全操作）更加方便、高效，它便是AtomicInteger。如果是引用类对象就使用AtomicReference和AtomicReferenceFieldUpdate. 多线程死锁的产生条件 互斥条件:一个资源每次只能被一个线程占有 不剥夺条件:线程以及获得的资源,在未使用完之前不能强行剥夺 请求和保持条件:线程已经占有了至少一个资源,但又提出新的资源请求,而该资源已被其他线程占有,此时请求线程被阻塞,但对自己以获得的资源保持不放 循环等待条件:若干线程之间形成一种首尾相连的循环等待资源关系 如何避免死锁? 指定获取锁的顺序,规定只有获得 A 锁的线程才有资格获取 B 锁，按顺序获取锁就可以避免死锁。 问题：线程A、B、C依次打印A、B、C，循环10次 方法一：使用Thread的join方法，强制执行一个线程 123456789101112131415161718192021222324252627282930for (int i = 0; i &lt; 10; i++) { Thread threadA = new Thread(new Runnable() { @Override public void run() { System.out.println(&quot;A&quot;); } }); Thread threadB = new Thread(new Runnable() { @Override public void run() { System.out.println(&quot;B&quot;); } }); Thread threadC = new Thread(new Runnable() { @Override public void run() { System.out.println(&quot;C&quot;); } }); try { threadA.start(); threadA.join(); threadB.start(); threadB.join(); threadC.start(); threadC.join(); } catch (InterruptedException e) { e.printStackTrace(); }} 方法二：使用单线程线程池依次执行 12345678910111213141516171819202122ExecutorService executorService = Executors.newSingleThreadExecutor();for (int i = 0; i &lt; 10; i++) { executorService.submit(new Runnable() { @Override public void run() { System.out.println(&quot;A&quot;); } }); executorService.submit(new Runnable() { @Override public void run() { System.out.println(&quot;B&quot;); } }); executorService.submit(new Runnable() { @Override public void run() { System.out.println(&quot;C&quot;); } });}executorService.shutdown(); 问题2：使用AtomicInteger实现一个Lock锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.concurrent.ConcurrentLinkedQueue;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.LockSupport;public class IConcurrentLock implements Lock {private AtomicInteger atomicInteger = new AtomicInteger(0);private ConcurrentLinkedQueue&lt;Thread&gt; concurrentLinkedQueue = new ConcurrentLinkedQueue&lt;&gt;();@Overridepublic void lock() {if (atomicInteger.compareAndSet(0, 1)) {return;}// 首先将当前线程添加至等待队列concurrentLinkedQueue.add(Thread.currentThread());// 自旋，等死while (true) {if (0 == atomicInteger.get()) {// 期望是0，如果是0则返回true，否则加1并返回falseif (atomicInteger.compareAndSet(0, 1)) {concurrentLinkedQueue.remove(Thread.currentThread());return;}} else {// 挂起当前线程LockSupport.park();}}}@Overridepublic void unlock() {atomicInteger.set(0);// 唤醒等待队列中的第一个线程Thread waiterHead = concurrentLinkedQueue.peek();if (null != waiterHead) {// 唤醒线程LockSupport.unpark(waiterHead);}}@Overridepublic void lockInterruptibly() throws InterruptedException {}@Overridepublic boolean tryLock() {return false;}@Overridepublic boolean tryLock(long time, TimeUnit unit) throws InterruptedException {return false;}@Overridepublic Condition newCondition() {return null;}} 7、各类集合比较List、Set和Map区别 List、Set都继承Collection接口，Map为独立的一个接口 List： 允许重复的对象 可插入多个null元素 是有序的容器 常用类型ArrayList、LinkedList和Vector Set: 不允许重复对象 只允许插入一个null元素 无序容器 常用类型HashSet、LinkedHashSet和TreeSet Map： Map的每个Entry都持有一个key和value，key必须是唯一的 Map可存储多个null值，但最多只能有一个null键 常用类型HashMap、LinkedHashMap、HashTable和TreeMap HashMap,ArrayMap,SparseMap比较 HashMap:数组+链表+红黑树实现,查询\\插入接近O(1) ,2倍的扩容,无缩容机制,有额外的Entry对象,适用于大量(1000)的增删频繁的操作 ArrayMap:两个数组,一个用来存放key,一个用来存放value,查询\\插入O(logN),1.5倍扩容,0.5倍缩容,适合增删不频繁的操作 SparseMap:两个数组实现,key必须是整型,避免了装箱操作 ArrayList与LinkedList比较 ArrayList是动态数组的数据结构,LinkedList是链表的数据结构 ArrayList查询效率高,增删效率低 LinkedList查询慢,增删快 HashMap,HashTable HashMap:线程不安全,数组+链表+红黑树,默认大小16,扩容:capacity2,加载因子:0.75,临界值:160.75,大小都是2的N次幂; Hash Table:方法添加了synchronized关键字,是线程安全的,数组+链表,默认大小11,扩容:capacity*2+1 为什么HashMap大小都是2的N次幂? index = h &amp; (length - 1); 为了减少Hash碰撞,尽量使Hash算法的结果均匀分布 8、HTTPS相关说一下一次完整的Http请求流程 1)DNS域名解析:先在DNS缓存中查找-&gt;系统host文件中查找-&gt;DNS服务查找-&gt;IP地址 2)建立TCP/IP连接,客户端与服务端通过socket三次握手,成功建立连接 3)客户端向服务端发送http请求 4)客户端发送请求头信息,请求内容,最后会发送一行空白行,表示客户端请求完毕 5)服务端做出应答,表示对客户端请求的应答,例如:HTTP/1.1 200 OK 6)服务端向客户端发送应答头信息 7)服务端向客户端发送应答头消息后,也会发送一行空白行,表示应答头信息发送完毕,接着就以Content-type要求的数据格式发送数据给客户端 8)服务器关闭TCP/IP连接 Https和http的主要区别 1)https协议需要到CA申请证书 2)http是超文本传输协议,信息的明文传输,https则是具有安全性的ssl/tls加密传输协议 3)http和https使用的是完全不同的连接方式,用的端口也不一样,前者是80,后者是443. 4)http的连接很简单是无状态的,HTTPS协议是由SSL/TLS + HTTP协构建的可进行加密传输,身份认证的网络协议,比http协议安全 TCP连接三次握手与四次挥手 三次握手： （1）首先客户端向服务器端发送一段TCP报文，其中： 标记位为SYN，表示“请求建立新连接”; 序号为Seq=X（X一般为1）； 随后客户端进入SYN-SENT阶段。 （2）服务器端接收到来自客户端的TCP报文之后，结束LISTEN阶段。并返回一段TCP报文，其中： 标志位为SYN和ACK，表示“确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接”（即告诉客户端，服务器收到了你的数据）； 序号为Seq=y； 确认号为Ack=x+1，表示收到客户端的序号Seq并将其值加1作为自己确认号Ack的值；随后服务器端进入SYN-RCVD阶段。 （3）客户端接收到来自服务器端的确认收到数据的TCP报文之后，明确了从客户端到服务器的数据传输是正常的，结束SYN-SENT阶段。并返回最后一段TCP报文。其中： 标志位为ACK，表示“确认收到服务器端同意连接的信号”（即告诉服务器，我知道你收到我发的数据了）； 序号为Seq=x+1，表示收到服务器端的确认号Ack，并将其值作为自己的序号值； 确认号为Ack=y+1，表示收到服务器端序号Seq，并将其值加1作为自己的确认号Ack的值； 随后客户端进入ESTABLISHED阶段。 服务器收到来自客户端的“确认收到服务器数据”的TCP报文之后，明确了从服务器到客户端的数据传输是正常的。结束SYN-SENT阶段，进入ESTABLISHED阶段。 在客户端与服务器端传输的TCP报文中，双方的确认号Ack和序号Seq的值，都是在彼此Ack和Seq值的基础上进行计算的，这样做保证了TCP报文传输的连贯性。一旦出现某一方发出的TCP报文丢失，便无法继续”握手”，以此确保了”三次握手”的顺利完成。此后客户端和服务器端进行正常的数据传输。这就是“三次握手”的过程。 四次挥手： （1）首先客户端想要释放连接，向服务器端发送一段TCP报文，其中： 标记位为FIN，表示“请求释放连接“； 序号为Seq=U； 随后客户端进入FIN-WAIT-1阶段，即半关闭阶段。并且停止在客户端到服务器端方向上发送数据，但是客户端仍然能接收从服务器端传输过来的数据。 （2）服务器端接收到从客户端发出的TCP报文之后，确认了客户端想要释放连接，随后服务器端结束ESTABLISHED阶段，进入CLOSE-WAIT阶段（半关闭状态）并返回一段TCP报文，其中： 标记位为ACK，表示“接收到客户端发送的释放连接的请求”； 序号为Seq=V； 确认号为Ack=U+1，表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值； 随后服务器端开始准备释放服务器端到客户端方向上的连接。 客户端收到从服务器端发出的TCP报文之后，确认了服务器收到了客户端发出的释放连接请求，随后客户端结束FIN-WAIT-1阶段，进入FIN-WAIT-2阶段 前”两次挥手”既让服务器端知道了客户端想要释放连接，也让客户端知道了服务器端了解了自己想要释放连接的请求。于是，可以确认关闭客户端到服务器端方向上的连接了 （3）服务器端自从发出ACK确认报文之后，经过CLOSED-WAIT阶段，做好了释放服务器端到客户端方向上的连接准备，再次向客户端发出一段TCP报文，其中： 标记位为FIN，ACK，表示“已经准备好释放连接了”。注意：这里的ACK并不是确认收到服务器端报文的确认报文。 序号为Seq=W； 确认号为Ack=U+1；表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值。 随后服务器端结束CLOSE-WAIT阶段，进入LAST-ACK阶段。并且停止在服务器端到客户端的方向上发送数据，但是服务器端仍然能够接收从客户端传输过来的数据。 （4）客户端收到从服务器端发出的TCP报文，确认了服务器端已做好释放连接的准备，结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，并向服务器端发送一段报文，其中： 标记位为ACK，表示“接收到服务器准备好释放连接的信号”。 序号为Seq=U+1；表示是在收到了服务器端报文的基础上，将其确认号Ack值作为本段报文序号的值。 确认号为Ack=W+1；表示是在收到了服务器端报文的基础上，将其序号Seq值作为本段报文确认号的值。 随后客户端开始在TIME-WAIT阶段等待2MSL 服务器端收到从客户端发出的TCP报文之后结束LAST-ACK阶段，进入CLOSED阶段。由此正式确认关闭服务器端到客户端方向上的连接。 客户端等待完2MSL之后，结束TIME-WAIT阶段，进入CLOSED阶段，由此完成“四次挥手”。 与“三次握手”一样，在客户端与服务器端传输的TCP报文中，双方的确认号Ack和序号Seq的值，都是在彼此Ack和Seq值的基础上进行计算的，这样做保证了TCP报文传输的连贯性，一旦出现某一方发出的TCP报文丢失，便无法继续”挥手”，以此确保了”四次挥手”的顺利完成。 问题1：**为什么客户端在**TIME-WAIT阶段要等2MSL? 为的是确认服务器端是否收到客户端发出的ACK确认报文 当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。 服务器端在1MSL内没有收到客户端发出的ACK确认报文，就会再次向客户端发出FIN报文； 如果客户端在2MSL内，再次收到了来自服务器端的FIN报文，说明服务器端由于各种原因没有接收到客户端发出的ACK确认报文。客户端再次向服务器端发出ACK确认报文，计时器重置，重新开始2MSL的计时； 否则客户端在2MSL内没有再次收到来自服务器端的FIN报文，说明服务器端正常接收了ACK确认报文，客户端可以进入CLOSED阶段，完成“四次挥手”。 所以，客户端要经历时长为2SML的TIME-WAIT阶段；这也是为什么客户端比服务器端晚进入CLOSED阶段的原因 Https的加密机制-混合密钥 HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。公开密钥加密很安全。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。 所以应充分利用共享密钥加密和公开密钥加密各自的优势，将共享密钥加密和公开密钥加密组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。 证书的基本原理 首先，客户端向服务器发出加密请求 服务器将自己的证书发送给请求的客户端，这个证书中包含服务器的公钥，而这个证书本身被颁发证书的可信机构的私钥加密。并且可信机构的公钥一般会存储于请求的客户端电脑上。 请求的客户端利用存储于本电脑上的可信机构的公钥，来验证该证书是否正确，这样就验证了服务器身份，同时得到了服务器的公钥 客户端利用服务器的公钥加密共享秘钥,服务器收到客户端的共享秘钥后，二者就可以通过共享秘钥完成接下来的加密通信 参考Https加密原理 9、Java的数据类型byte 1个字节，8位表示 范围[-128,127] short 2个字节，16位表示 范围[-2^15,2^15-1] int 4个字节，32位表示 范围[-2^31,2^31-1] long 8个字节，64位表示 范围[-2^64,2^63-1] char 2个字节，16位表示 范围[0,65535]，默认值’\\u0000’ float 4个字节，32位表示 单精度浮点数 double 8个字节，64位表示 双精度浮点数 boolean 默认值 false String、StringBuilder、StringBuffer区别 String为字符串常量，不可变，StringBuilder与StringBuffer都是可变字符串，StringBuffer是线程安全的 执行效率比较：StringBuilder&gt;StringBuffer&gt;String StringBuffer线程安全是因为大部分方法是synchronized关键字修饰的 String适用于少量的字符串操作，StringBuilder适用于单线程字符串缓冲区进行大量操作，StringBuffer适用于多线程字符串缓冲区进行大量操作 ==与equals区别 “==”比较两个引用是否指向堆内存里的同一个地址，一般用于基本类型的比较 equals是Object中的一个方法，该方法返回结果依赖自身的实现，适用于引用对象比较 Object中的equals实现，比较的是两个对象的内存地址 123public boolean equals(Object obj) { return (this == obj); } String中的equals实现，首先判断地址是否相等，然后再判断每个字符是否相同，不同则返回false 12345678910111213141516171819202122232425public boolean equals(Object anObject) { //判断地址值是否相等 if (this == anObject) { return true; } //判断对象类型是否为String if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; //判断长度是否相等 if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { //每一个字符都必须相同 if (v1[i] != v2[i]) return false; i++; } return true; } } return false;｝ 10、Java反射机制JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法； Java中的Class三种获取方式 利用对象调用getClass()方法获取该对象的Class实例 使用Class类的静态方法forName()，用类的名称获取一个Class实例 利用Java类自己的.class的方式来获取Class实例 一些常用重要方法： Annotation[] getAnnotations()，获取类中所有注解 getClassLoader 获取加载这个类的类加载器 getDeclaredMethods() 获取这个类中的所有方法 getReturnType() 获取方法的返回类型 getParameterTypes() 获取方法的传入参数类型 isAnnotation() 测试这个类是否是一个注解类 getDeclaredConstructors() 获取所有的构造方法 getDeckaredMethod(String name,Class… parameterTypes)获取指定的构造方法 getSupperclass() 获取父类 getInterfaces() 获取此类实现的所有接口 getFields() 获取这个类中所有public的成员变量 getField(String name)获取指定名称的public成员变量 newInstance() 调用默认无参构造创建一个实例对象 获取私有变量 123456Field field = person.getClass().getDeclaredField(fieldName); // 参数值为true，打开禁用访问控制检查 //setAccessible(true) 并不是将方法的访问权限改成了public，而是取消java的权限控制检查。 //所以即使是public方法，其accessible 属相默认也是false field.setAccessible(true); return field.get(person); 11、Java的注解","link":"/2021/04/06/java%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"丁与丹的爱情——耶路撒冷之行的寓意是什么？","text":"丁与丹的爱情——耶路撒冷之行的寓意是什么？格律诗公司的事情处理完成之后，芮小丹那颗不安静的心，终于放了下来。她从来没有向现在这样感觉时间如此的漫长，送走了郑建时，芮小丹回到柏林的家，已经是下午三点多钟，此时，大洋彼岸另一端的古城已经是北京时间夜里十点多钟，丁元英正在悠然惬意的喝着茗茶，听着音响。芮小丹料定丁元英这个时间一定还没休息，于是便迫不及待的拨通了国际长途…… 丁：“喂！” 芮：“元英，我是小丹，刚刚郑大哥来过，吃完饭就回柏林了，我送他到机场刚刚回来。你现在把电脑打开，上到中华佛教网站注册个名字，进到佛法聊天室，我的昵称叫‘丑小鸭’，你上来找我，我们到文字聊天室用秘谈聊。” 丁：“小丹，我已经在包厢秘谈里了，你可以开始了。” 芮：”郑大哥已经把格律诗音箱在德、英、法三个国家和欧洲总代理四份代理协议签好了，这里的事情办完了，我想这两天就直接回去，不从耶路撒冷绕道了，一绕道又得耽搁几天。“ 丁：”你探亲的目的就是陪你母亲，如果你在执行任务，你也能说句‘我想你了’就回家吗？“ 芮：”反对，条件设置错误，那是没选择，这是有选择。我妈看我心不在这儿，已经同意让我回去了。我想你了，很想！“ 丁：”确定回来？“ 芮：”确定，我一分钟都等不及了。“ 芮：”元英，我是警察，就连我这个警察，也没有像你那样的完全活在‘应该’里，我们就不能往‘我想’里活一点吗？活得像计算机一样精确，就连接吻都纳入了程序，生活精确到这种程度好吗？对此我有看法，我申诉！“ 这时候丁元英立马拨通了国际长途。 丁：“小丹，我刚向北京机场售票处咨询过，北京到特拉维夫的航班，每星期是两个班次，后天就有一班，北京时间13点50起飞，当地时间21点10分到达，我明天就坐飞机去北京，争取当天能拿到签证，这样能赶上后天的航班，从法兰克福到特拉维夫的航班很多，你根据我的班次调一下时间，咱们在特拉维夫见面。” 芮：“你是不是在赌气，你还是想让我绕道耶路撒冷。” 丁：“你认为我对你说的我想你了这四个字可以那么无动于衷吗？我想你了和必要信息储备两条思路不必矛盾，它们的交汇点就在耶路撒冷。” 爱情中的理想伴侣，应该是“独立成长，互相成就”的关系，丁元英与芮小丹就很好的诠释了这一点，它们俩就是一对理想伴侣。芮小丹本来是吸烟的，但爱上了丁元英后便不再吸烟，丁元英为了送给芮小丹一个“神话”，也改变了自己，改变了他到古城只图清静的初衷，主动走出去帮助发烧友以及王庙村的农户。丁元英之前一直活在“应该”里，如今却为了芮小丹主动改变了自己的风格，为她而变得更温暖，更有爱。其实理想伴侣的获得并不在寻，而是靠自身能量的吸引，甚至是你内心的创造。丁元英与芮小丹的相爱，完全是能量吸引，并不是单纯的为了爱而爱，“爱”不是名词而是动词，是一种行为，你到底是因为爱情中的他（她）而变得更美好，更幽默，更智慧，还是因为爱上了一个人而变得更傻，更颓废，更弱智。这，即是差别，当爱是一种能力的时候，你会因为爱上一个人而变得更美好。丁元英因为爱着芮小丹而变得更善解人意，芮小丹也因为爱着丁元英而变得更有智慧，总之，相同“能量”的人才能走到一起，“福德相似，方为夫妻”你自己是什么样的人就会遇到什么样的人，让自己化身为爱和智慧的化身，在通往喜悦和光明的人生道路上与志同道合的同路人，不期而遇。 丁元英为什么执意要让芮小丹绕道耶路撒冷呢？这件事情从表面上看似乎和整个故事并没有什么关联性，但其实耶路撒冷之行对芮小丹有着极大的影响，并且也间接预示了芮小丹命运的结局。丁元英与芮小丹两个人都是踩了佛门“门槛”的人，用书中的话来说就是强势文化的塑造者，强势文化所信奉的准则就是，世上没有真正的救世主，能救自己的只有自己，只有自己觉得悟到的，才是属于自己的，否则，即便别人给你，你也拿不住。正如此前，丁元英曾神态严肃的告诉芮小丹，你应该辞职，而不是我希望你辞职，丁元英觉得芮小丹有维纳斯酒店的股份，完全不用考虑收入的问题，已芮小丹的身份资历完全不需要冒险去做一份有危险性的工作，丁元英的建议，并不带有任何强迫或要挟的态度，而是纯粹以“应该”为基础的建议，他觉得芮小丹应该辞职，是因为她具备了辞职的客观条件，完全有能力避开刑警的职业风险，但以芮小丹的认知却无法接受丁元英的建议，两个人在一番争执后，最终以不愉快的方式收场，这个结局当然不是丁元英所期望的，他也并不想强迫芮小丹，因为他知道，强迫没有任何效果，只能适得其反，只有让芮小丹“自悟”，才能让她主动去改变。这个时候耶路撒冷做一个重要的觉悟载体，便出现在了两人的计划之中，耶路撒冷是世界三大宗教的圣地，真主、上帝和耶稣都在，但历史却在这里沉积了太多的哀怨与仇恨，也凝聚了太多的祈祷、叹息、鲜血和眼泪。有人说，上帝给了世界十分哀愁九分给了耶路撒冷，当上帝耶和华、耶稣基督与真主安拉聚在同一片土地上的时候，世界就再也没有什么地方，能像耶路撒冷这样令人沉思，两次世界大战也不过打了十年，而巴以冲突就打了50年之久，什么样的民族能承受如此的苦难呢？可上帝和真主仍然没能拯救他们，因此世界上再没有什么地方，能让人明白救世主文化的荒诞之说，虽然芮小丹早就明白这个道理，但她的明白是“自觉”，而丁元英此行的目的是让芮小丹“觉他”，觉他的“无明”，“自觉”简单的说就是明白条件的存在以自我为中心的按照客观规律办事，而“觉他”是唯条件是从，按照客观规律办事，通过改变其他人的生存状态来实现自己的人生价值，“觉他”就是让别人知道自己的“无明”,”无明”指的是你不知道自己不知道，不知道拥有知识，懂得很多道理根本没用，它只是有用的一个条件，用才有用，这些知识和道理或许能让你的生存得到保障，但却无法让你更好的谋生，“觉他”的目的是让越来越多的人因为你的存在而获得更好的生活更幸福的未来，而你也可以因此而得到生存的保障，精神的富足，灵魂的自由。丁元英与芮小丹都明白因果不虚的规律，但唯一有区别的是，丁元英心中的因果不虚是“觉他”之后的结果，而芮小丹只是随心的本性使然，是“自觉”而不是“觉他”，“自觉”是明白条件的存在，而“觉他”是唯条件是从，明白为因果不虚的规律，他希望芮小丹在明白这个真相之后能够完成由“自觉”到“觉他”的境界转变，从而明白他劝诫的用心，在“觉他”之后按因果不虚的规律做事，并向刑警队提出辞职，“觉他”是让自己有可能更好的谋生，没有谁可以普渡众生，很多东西不必当下明白，信息储备也只是一个有用的条件，这也是丁元英希望芮小丹来耶路撒冷的真实原因，这一切充分体现了丁元英对芮小丹的良苦用心，但遗憾的是芮小丹虽然明白了这个道理但并没有将条件用在自己身上，最终也没有彻底达到“觉他”的状态，所以才有了最后执行任务时被歹徒炸伤然后举枪自尽的一幕悲剧。","link":"/2021/04/06/%E9%81%A5%E8%BF%9C%E7%9A%84%E6%95%91%E4%B8%96%E4%B8%BB%E2%80%94%E2%80%94%E7%88%B1%E6%83%85/"}],"tags":[{"name":"读书","slug":"读书","link":"/tags/%E8%AF%BB%E4%B9%A6/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"编程","slug":"编程","link":"/tags/%E7%BC%96%E7%A8%8B/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"java","slug":"java","link":"/tags/java/"}],"categories":[{"name":"读书","slug":"读书","link":"/categories/%E8%AF%BB%E4%B9%A6/"},{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"},{"name":"生活随笔","slug":"生活随笔","link":"/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"},{"name":"感情随笔","slug":"感情随笔","link":"/categories/%E6%84%9F%E6%83%85%E9%9A%8F%E7%AC%94/"}]}