{"pages":[],"posts":[{"title":"算法学习总结","text":"1、什么是算法？算法就是计算或者解决问题的步骤。我们可以把它想象成食谱。要想做出特定的料理，就要遵循食谱上的步骤；同理，要想用计算机解决特定的问题，就要遵循算法。这里所说的特定问题多种多样，比如“将随意排列的数字按从小到大的顺序重新排列”“寻找出发点到目的地的最短路径”，等等。食谱和算法之间最大的区别就在于算法是严密的。食谱上经常会有描述得比较模糊的部分，而算法的步骤都是用数学方式来描述的，所以十分明确。算法和程序有些相似，区别在于程序是以计算机能够理解的编程语言编写而成的，可以在计算机上运行，而算法是以人类能够理解的方式描述的，用于编写程序之前。不过，在这个过程中到哪里为止是算法、从哪里开始是程序，并没有明确的界限。就算使用同一个算法，编程语言不同，写出来的程序也不同；即便使用相同的编程语言，写程序的人不同，那么写出来的程序也是不同的。 摘录自《我的第一本算法》，这本书特别适合新手学习，以图形的方式来讲解，易于理解。 2、数据结构什么是数据结构？ 答：数据存储于内存中，决定了数据顺序和位置关系的便是“数据结构”。 数组（Array） 数据按顺序存储在内存的连续空间内。 链表（Linked List） 是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 栈（Stack） 栈也是一种数据呈线性排列的数据结构，遵循后进先出原则 队列（Queue） 普通队列：队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作。 双端队列（Deque）：入口和出口都可以入队和出队 优先队列（PriorityQueue）：根据优先级出队 哈希表（Hash table） 哈希表（Hash table），也叫散列表，是根据关键码值（Key value）而直接进行访问的数据结构。 树（Tree） 一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。 特点： 每个节点都只有有限个子节点或无子节点 没有父节点的节点称为根节点 每一个非根节点有且仅有一个父节点 除了根节点外，每个子节点可以分为多个不相交的子树 树中没有环路 堆（Heap） 可以迅速找到一堆数中的最大或者最小值的数据结构。将根节点最大的堆叫做大顶堆或大根堆，根节点最小的堆叫做小顶堆或小根堆。常见的堆有二叉堆、斐波那契堆等。 满足下列性质： 堆中任意节点的值总是&gt;=或&lt;=其子节点的值 堆总是一颗完全二叉树 图（Graph） 图结构也是一种非线性数据结构，并且每个数据元素之间可以任意关联。 一个典型的图结构包括如下两个部分： 顶点（Vertex）：图中的数据元素 边（Edge）：图中连接这些顶点的线 存储方法：邻接矩阵、邻接表 邻接矩阵 邻接表 关于数据结构总结脑图附件 数据结构和算法-思维导图.pdf 3、算法 递归（Recursion） 递归也是一种循环，不过是通过函数体自己调用自己来进行的循环 简单示例：计算 n！ 12345// n！= 1*2*3*...*ndef Factorial(n): if n&lt;=1: return 1 return n*Factorial(n-1) 代码模板（Java） 123456789101112public void recur(int level , int param){ // terminator if (level &gt; MAX_LEVEL){ // process result retutn; } // process current logic process(level,param); // drill down recur(level+1,newParam); // restore current status} 爬楼梯（阿里巴巴、腾讯、字节跳动在半年内面试常考） 常规写法： 123456public int climbStairs(int n) { if(n &lt;= 2){ return n; } return climbStairs(n-1) + climbStairs(n-2);} 升级版本： 123456789public int climbStairs(int n) { int f1 = 1, f2 = 2, f3 = 0; for (int i = 3; i &lt;= n; i++) { f3 = f1 + f2; f1 = f2; f2 = f3; } return f3;} 括号生成(字节跳动在半年内面试中考过)123456789101112131415161718192021222324252627public List&lt;String&gt; generateParenthesis(int n) { List&lt;String&gt; res = new ArrayList&lt;&gt;(); if (n &lt; 1) { return res; } generate(0, 0, &quot;&quot;, res, n); return res;}public void generate(int left, int right, String s, List&lt;String&gt; res, int n) { // 1.递归终结条件 if (left == n &amp;&amp; right == n) { res.add(s); return; } // 2.处理当前层 // 右括号多余左括号，说明已经是无效括号组合 if (left &lt; right) { return; } // 3.下探下一层 // 如果左括号还能添加,右括号不变 if (left &lt; n) generate(left + 1, right, s + &quot;(&quot;, res, n); // 如果右括号还能添加，左括号不变 if (right &lt; n) generate(left, right + 1, s + &quot;)&quot;, res, n);} 翻转二叉树(谷歌、字节跳动、Facebook 在半年内面试中考过)12345678910public TreeNode invertTree(TreeNode root) { if (root == null) return null; TreeNode left = root.left; root.left = root.right; root.right = left; invertTree(root.left); invertTree(root.right); return root;} 验证二叉搜索树（亚马逊、微软、Facebook 在半年内面试中考过）1234567891011// 中序遍历访问，先遍历左子树，如果有当前节点值&lt;=前节点值，不满足条件private TreeNode per;public boolean isValidBST(TreeNode root) { if (root == null) return true; if (!isValidBST(root.left)) return false; if (per != null &amp;&amp; root.val &lt;= per.val) return false; per = root; if (!isValidBST(root.right)) return false; return true;} 二叉树的最大深度（亚马逊、微软、字节跳动在半年内面试中考过）123456class Solution { public int maxDepth(TreeNode root) { if(root == null) return 0; return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1; }} 二叉树的最小深度（Facebook、字节跳动、谷歌在半年内面试中考过）123456789class Solution { public int minDepth(TreeNode root) { if(root == null) return 0; if(root.left == null &amp;&amp; root.right ==null) return 1; if(root.left == null || root.right == null) return minDepth(root.left) + minDepth(root.right) + 1; return Math.min(minDepth(root.left),minDepth(root.right)) + 1; }} 二叉树的序列化与反序列化（Facebook、亚马逊在半年内面试常考）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */public class Codec { // Encodes a tree to a single string. public String serialize(TreeNode root) { StringBuilder str = new StringBuilder(); // BFS return traversTree(root,str); } // Decodes your encoded data to tree. public TreeNode deserialize(String data) { if(data.isEmpty() || data.equals(&quot;#&quot;)){ return null; } Queue&lt;TreeNode&gt; queue = new LinkedList(); String[] nodes = data.split(&quot;,&quot;); TreeNode root = new TreeNode(Integer.valueOf(nodes[0])); queue.add(root); for(int i = 1; i &lt; nodes.length ; i++){ TreeNode p = queue.poll(); if(!&quot;#&quot;.equals(nodes[i])){ TreeNode left = new TreeNode(Integer.valueOf(nodes[i])); p.left = left; queue.add(left); } if(!&quot;#&quot;.equals(nodes[++i])){ TreeNode right = new TreeNode(Integer.valueOf(nodes[i])); p.right = right; queue.add(right); } } return root; } public String traversTree(TreeNode root,StringBuilder str){ if(root == null) { return &quot;#&quot;; } Queue&lt;TreeNode&gt; queue = new LinkedList(); queue.add(root); while(!queue.isEmpty()){ TreeNode node = queue.poll(); if(node == null){ str.append(&quot;#&quot;+&quot;,&quot;); continue; } str.append(node.val+&quot;,&quot;); queue.add(node.left); queue.add(node.right); } return str.toString(); }}// Your Codec object will be instantiated and called as such:// Codec ser = new Codec();// Codec deser = new Codec();// TreeNode ans = deser.deserialize(ser.serialize(root)); 课后作业： 二叉树的最近公共祖先（Facebook 在半年内面试常考）123456789101112class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null || root == p || root == q) { return root; } TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if(left == null) return right; if(right == null) return left; return root; }} 从前序与中序遍历序列构造二叉树（字节跳动、亚马逊、微软在半年内面试中考过）123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { private Map&lt;Integer, Integer&gt; indexMap = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] preorder, int[] inorder) { if (preorder.length == 0 || inorder.length == 0) { return null; } int n = preorder.length; // 将中序遍历的数组保存在map中，以便快速查询节点对应的下标 for (int i = 0; i &lt; n; i++) { indexMap.put(inorder[i], i); } return buildTreeHelper(preorder, inorder, 0, n - 1, 0, n - 1); } private TreeNode buildTreeHelper(int[] preorder, int[] inorder, int preLeft, int preRight, int inLeft, int inRight) { // 递归结束条件，数组切分完为止 if (preLeft &gt; preRight) { return null; } // 前序遍历的第一个节点就是根节点 int perRoot = preLeft; // 查询根节点在中序遍历中的下标位置 int index_root = (int)indexMap.get(preorder[perRoot]); // 创建根节点 TreeNode root = new TreeNode(preorder[perRoot]); // 计算左子树中的节点数目，以index_root下标为中心将前序遍历数组inorder切分为左子树、右子树两部分 int left_size = index_root - inLeft; // 递归构造左子树 root.left = buildTreeHelper(preorder, inorder, preLeft + 1, preLeft + left_size, inLeft, index_root - 1); // 递归构造右子树 root.right = buildTreeHelper(preorder, inorder, preLeft + left_size + 1, preRight, index_root + 1, inRight); return root; }} 组合（微软、亚马逊、谷歌在半年内面试中考过）123456789101112131415161718class Solution { public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); dfs(n, k, 1, new ArrayList&lt;Integer&gt;(), res); return res; } private void dfs(int n, int k, int start, ArrayList&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; res) { if (k == 0) { res.add(new ArrayList&lt;&gt;(list)); return; } for (int i = start; i &lt;= n - k + 1; i++) { list.add(i); dfs9(n, k - 1, i + 1, list, res); list.remove(list.size() - 1); } }} 全排列（字节跳动在半年内面试常考）123456789101112131415161718192021222324class Solution { public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(); boolean[] used = new boolean[nums.length]; dfs(nums, 0, path, used, res); return res; } private void dfs(int[] nums, int level, Deque&lt;Integer&gt; path, boolean[] used, List&lt;List&lt;Integer&gt;&gt; res) { if (level == nums.length) { res.add(new ArrayList&lt;&gt;(path)); return; } for (int j = 0; j &lt; nums.length; j++) { if (!used[j]) { path.addLast(nums[j]); used[j] = true; dfs(nums, level + 1, path, used, res); used[j] = false; path.removeLast(); } } }} 全排列 II （亚马逊、字节跳动、Facebook 在半年内面试中考过）12345678910111213141516171819202122232425262728293031class Solution { public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(); boolean[] used = new boolean[nums.length]; // 排序（升序或者降序都可以），排序是剪枝的前提 Arrays.sort(nums); dfs(nums, 0, path, used, res); return res; } private void dfs(int[] nums, int level, Deque&lt;Integer&gt; path, boolean[] used, List&lt;List&lt;Integer&gt;&gt; res) { if (level == nums.length) { res.add(new ArrayList&lt;&gt;(path)); return; } for (int j = 0; j &lt; nums.length; j++) { if (used[j]) { continue; } // 剪枝，取掉重复的搜索结果 if (j &gt; 0 &amp;&amp; nums[j] == nums[j - 1] &amp;&amp; !used[j - 1]) { continue; } path.addLast(nums[j]); used[j] = true; dfs(nums, level + 1, path, used, res); used[j] = false; path.removeLast(); } }} 分治、回溯 分治代码模板1234567891011private static int divide_conquer(Problem problem, ) { if (problem == NULL) { int res = process_last_result(); return res; } subProblems = split_problem(problem) res0 = divide_conquer(subProblems[0]) res1 = divide_conquer(subProblems[1]) result = process_result(res0, res1); return result;} 50. Pow(x, n)12345678910class Solution { public double myPow(double x, int n) { if(n == 0) return 1; if(n == 1) return x; if(n == -1) return 1/x; double helf = myPow(x,n/2); double rest = myPow(x,n%2); return rest*helf*helf; }} 78. 子集123456789101112131415class Solution { public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); subsets(nums,0,new ArrayList(),result); return result; } public void subsets(int[] nums,int index ,List&lt;Integer&gt; list,List&lt;List&lt;Integer&gt;&gt; result){ result.add(new ArrayList&lt;&gt;(list)); for(int i = index;i&lt;nums.length;i++){ list.add(nums[i]); subsets(nums,i + 1,list,result); list.remove(list.size() - 1); } }} 169. 多数元素 思路：排序 123456class Solution { public int majorityElement(int[] nums) { Arrays.sort(nums); return nums[nums.length/2]; }} 思路：摩尔投票法相同的元素则 票数+1，遇到不同的则 票数-1 因为“多数元素”个数 &gt; n/2 ，则其余元素个数 &lt;= n/2 这样“多数元素”的票数就能抵消掉所有其余元素的票数，最终剩余的就是票数最多的元素。 1234567891011121314151617181920class Solution { public int majorityElement(int[] nums) { // 默认选中第一个元素为候选人，票数默认10 int count = 1; int choose = nums[0]; for (int i = 1; i &lt; nums.length; i++) { if (nums[i] == choose) { count++; } else { count--; } // 当票数为0时，需要更换候选人，票数也重置为1 ，开始重新投票 if (count == 0) { choose = nums[i]; count = 1; } } return choose; }} 17. 电话号码的字母组合 思路：dfs+回溯 123456789101112131415161718192021222324252627class Solution { public List&lt;String&gt; letterCombinations(String digits) { List&lt;String&gt; res = new ArrayList(); if (digits.length() == 0) return res; Map&lt;Character, String&gt; keyboard = new HashMap&lt;&gt;(); keyboard.put('2', &quot;abc&quot;); keyboard.put('3', &quot;def&quot;); keyboard.put('4', &quot;ghi&quot;); keyboard.put('5', &quot;jkl&quot;); keyboard.put('6', &quot;mno&quot;); keyboard.put('7', &quot;pqrs&quot;); keyboard.put('8', &quot;tuv&quot;); keyboard.put('9', &quot;wxyz&quot;); search(digits, 0, &quot;&quot;, res, keyboard); return res; } public void search(String digits, int level, String s, List&lt;String&gt; res, Map&lt;Character, String&gt; keyboard) { if (level == digits.length()) { res.add(s); return; } String letter = keyboard.get(digits.charAt(level)); for (int i = 0; i &lt; letter.length(); i++) { search(digits, level + 1, s + letter.charAt(i), res, keyboard); } }} 51. N 皇后12345678910111213141516171819202122232425262728```3. 深度优先搜索、广度优先搜索* DFS代码模板中序遍历```java//Javapublic List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; allResults = new ArrayList&lt;&gt;(); if(root==null){ return allResults; } travel(root,0,allResults); return allResults;}public void travel(TreeNode root,int level,List&lt;List&lt;Integer&gt;&gt; results){ if(results.size()==level){ results.add(new ArrayList&lt;&gt;()); } results.get(level).add(root.val); if(root.left!=null){ travel(root.left,level+1,results); } if(root.right!=null){ travel(root.right,level+1,results); }} BFS代码模板 层序遍历 123456789101112131415161718192021222324public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; allResults = new ArrayList&lt;&gt;(); if (root == null) { return allResults; } Queue&lt;TreeNode&gt; nodes = new LinkedList&lt;&gt;(); nodes.add(root); while (!nodes.isEmpty()) { int size = nodes.size(); List&lt;Integer&gt; results = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; size; i++) { TreeNode node = nodes.poll(); results.add(node.val); if (node.left != null) { nodes.add(node.left); } if (node.right != null) { nodes.add(node.right); } } allResults.add(results); } return allResults;} 102. 二叉树的层序遍历1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty()){ int size = queue.size(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i = 0 ; i &lt; size; i++){ TreeNode node = queue.poll(); list.add(node.val); if(node.left != null) queue.add(node.left); if(node.right != null) queue.add(node.right); } res.add(list); } return res; }} 515. 在每个树行中找最大值1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public List&lt;Integer&gt; largestValues(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty()){ int size = queue.size(); int max = Integer.MIN_VALUE; for(int i = 0;i &lt; size;i++){ TreeNode node = queue.poll(); max = Math.max(max,node.val); if(node.left != null) queue.add(node.left); if(node.right != null) queue.add(node.right); } res.add(max); } return res; }} 589. N叉树的前序遍历123456789101112131415161718192021222324252627282930313233/*// Definition for a Node.class Node { public int val; public List&lt;Node&gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&lt;Node&gt; _children) { val = _val; children = _children; }};*/class Solution { public List&lt;Integer&gt; preorder(Node root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; traverse(root,res); return res; } private void traverse(Node node,List&lt;Integer&gt; res){ if(node == null){ return; } res.add(node.val); List&lt;Node&gt; children = node.children; for(int i = 0 ; i &lt; children.size(); i++){ traverse(children.get(i),res); } }} 200. 岛屿数量12345678910111213141516171819202122232425class Solution { public int numIslands(char[][] grid) { if(grid.length == 0 &amp;&amp; grid[0].length == 0) return 0; int count = 0; for(int i = 0 ; i &lt; grid.length; i++){ for(int j = 0; j &lt; grid[i].length;j++){ if(grid[i][j] == '1'){ count++; dfs(grid,i,j); } } } return count; } private void dfs(char[][] grid , int i , int j){ if(i &lt; 0 || i &gt;= grid.length || j &lt; 0 || j &gt;= grid[0].length || grid[i][j] == '0'){ return; } grid[i][j] = '0'; dfs(grid,i+1,j);// rigth dfs(grid,i-1,j);// left dfs(grid,i,j+1);// top dfs(grid,i,j-1);// bottom }} 529. 扫雷游戏123456789101112131415161718192021222324252627282930313233```4. 贪心算法贪心算法是一种在每一步选择中都采取在当下状态下最好或最优（最有利）的选择，从而希望导致结果是全局最好或最优的算法。关于贪心算法推荐博客[贪心算法](https://mp.weixin.qq.com/s/O935TaoHE9Eexwe_vSbRAg)适用场景：问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。这种子问题最优解称为最优子结构。[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)贪心策略：每次兑换都从最大的零钱开始兑换，找最少硬币兑换个数，直至兑换完毕。```javaclass Solution { private int res = Integer.MAX_VALUE; public int coinChange(int[] coins, int amount) { if(amount == 0) return 0; Arrays.sort(coins); change(coins,amount,coins.length - 1,0); return res == Integer.MAX_VALUE ? -1 : res; } public void change(int[] coins, int amount , int coinIndex ,int count){ if(amount == 0){ res = Math.min(res,count); return; } if(coinIndex &lt; 0) return; for(int k = amount/coins[coinIndex];k&gt;=0 &amp;&amp; k + count&lt; res ; k--){ change(coins,amount-(k*coins[coinIndex]),coinIndex - 1,count + k); } }} 122. 买卖股票的最佳时机 II 贪心策略：低买高卖，所有上涨日都买卖，下跌日都不进行买卖，这样的收益是最大的 123456789101112class Solution { public int maxProfit(int[] prices) { int profit = 0; for (int i = 1; i &lt; prices.length; i++) { int temp = prices[i] - prices[i - 1]; if (temp &gt; 0) { profit += temp; } } return profit; }} 二分查找 33. 搜索旋转排序数组1234567891011121314151617181920212223class Solution { public int search(int[] nums, int target) { int left = 0,right = nums.length - 1,mid = 0; while(left &lt;= right){ mid = left + (right - left)/2; if(target == nums[mid]) return mid; if(nums[left] &lt;= nums[mid]){ if(target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) { right = mid - 1; }else { left = mid + 1; } }else { if(target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]){ left = mid + 1; }else { right = mid - 1; } } } return -1; } } 69. x 的平方根1234567891011121314151617class Solution { public int mySqrt(int x) { if (x == 0) { return x; } long left = 1, right = x/2, mid = 1; while(left &lt; right){ mid = (left + right + 1) &gt;&gt;&gt; 1; if(mid*mid &gt; x){ right = mid - 1; }else{ left = mid; } } return (int)left; }} 74. 搜索二维矩阵 思路：二分法 将二维数组转换为虚拟一维数组，长度= m*n，每次找中间值 matrix[mid / n][mid % n] 与 target 对比； 12345678910111213141516171819202122class Solution { public boolean searchMatrix(int[][] matrix, int target) { if (matrix.length == 0) return false; int m = matrix.length; int n = matrix[0].length; int left = 0, right = m * n - 1; int mid = 0, num = 0; while (left &lt;= right) { mid = left + (right - left) / 2; num = matrix[mid / n][mid % n]; if (target == num) { return true; } if (target &gt; num) { left = mid + 1; } else { right = mid - 1; } } return false; }} 动态规划 关键点：动态规划和递归或者分治没有根本上的区别（关键看有无最优的子结构） 共性：都是找到重复子问题 差异性：最优子结构、中途可以淘汰次优解 经典案例：剑指 Offer 10- I. 斐波那契数列 1）、常规递归法：12345class Solution { public int fib(int n) { return n &lt;= 1 ? n : fib(n-1) + fib(n-2); }} 2）、保存中间值递归法：123456789101112131415class Solution { private int[] num; public int fib(int n) { num = new int[n+1]; return fibonacci(n); } public int fibonacci(int n){ if(n &lt;= 1) return n; if(num[n] == 0){ num[n] = fibonacci(n-1) + fibonacci(n-2); num[n] %= 1000000007; } return num[n]; }} 3）、自底向上递推12345678910111213class Solution { public int fib(int n) { if(n &lt;= 1) return n; int[] num = new int[n+1]; num[0] = 0; num[1] = 1; for(int i = 2; i &lt;= n; i++){ num[i] = num[i-1] + num[i-2]; num[i] %= 1000000007; } return num[n]; }} 4）、动态规划123456789101112class Solution { public int fib(int n) { if(n &lt;= 1) return n; int f0 = 0,f1 = 1,f2 = 0; for(int i = 2; i &lt;= n; i++){ f2 = (f0 + f1) %1000000007; f0 = f1; f1 = f2; } return f2; }} 62. 不同路径 思路：使用二维数组表示机器人行走区域，（0，0）表示起点start，dp[i][j]表示机器人行走到（i，j）坐标的路径条数，那么最终答案就是求机器人行走至终点（m-1,n-1）对应的dp[m-1][n-1]的值；已知机器人只能向下或向右行走，那么当机器人行走至第一行或第一列任意位置的路径条数都为 1，也就是dp[0][j] == 1，dp[i][0] == 1；同样也可推导出机器人行走至（i，j）位置只能从（i-1，j）点或（i，j-1）点走过来，那么dp[i][j] == dp[i-1][j] + dp[i][j-1]; 1234567891011121314class Solution { public int uniquePaths(int m, int n) { if(m == 0 || n == 0) return 0; int[][] dp = new int[m][n]; for(int i = 0; i &lt; m; i++) dp[i][0] = 1; for(int j = 0; j &lt; n; j++) dp[0][j] = 1; for(int i = 1; i &lt; m;i++){ for(int j = 1; j &lt; n; j++){ dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } return dp[m-1][n-1]; }} 优化版： 12345678910111213141516class Solution { public int uniquePaths(int m, int n) { if(m == 0 || n == 0) return 0; int[][] dp = new int[m][n]; for(int i = 0; i &lt; m;i++){ for(int j = 0; j &lt; n; j++){ if (i == 0 || j == 0){ dp[i][j] = 1; }else{ dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } } return dp[m-1][n-1]; }} 进阶：63. 不同路径 II 思路：不同于62题，机器人在行走过程中会碰到障碍物阻挡。同样的思路我们只需要处理无障碍物的情况； 123456789101112131415class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length , n = obstacleGrid[0].length; int[][] dp = new int[m][n]; for(int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++) dp[i][0] = 1; for(int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; j++) dp[0][j] = 1; for(int i = 1; i &lt; m;i++){ for(int j = 1; j &lt; n; j++){ if(obstacleGrid[i][j] == 0) dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } return dp[m-1][n-1]; }} 内存优化版： 12345678910111213141516class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length , n = obstacleGrid[0].length; int[] dp = new int[n+1]; dp[1] = 1; for(int i = 0; i &lt; m;i++){ for(int j = 1; j &lt;= n; j++){ if(obstacleGrid[i][j-1] == 1) dp[j] = 0; else dp[j] += dp[j-1]; } } return dp[n]; }} 高阶：980. 不同路径 III12345678910111213141516171819202122232425262728293031323334353637class Solution { private int res = 0; public int uniquePathsIII(int[][] grid) { // 初始化起点坐标和总步数,grid[i][j] == 2 也算步数，所以初始化为 1 int startX = 0, startY = 0, stepNum = 1; for(int i = 0; i &lt; grid.length; i++){ for(int j = 0; j &lt; grid[0].length; j++){ if(grid[i][j] == 1){ startX = i; startY = j; continue; } if(grid[i][j] == 0) stepNum++; } } dfs(startX,startY,stepNum,grid); return res; } public void dfs(int startX,int startY,int stepNum,int[][] grid){ // 边界处理 if(startX &lt; 0 || startX &gt;= grid.length || startY &lt; 0 || startY &gt;= grid[0].length || grid[startX][startY] == -1) return; // 结束条件 if(grid[startX][startY] == 2) { if(stepNum == 0)res++; return; }; // 将当前位置标记为已经过，不可重复 grid[startX][startY] = -1; // 依次统计上下左右方向走的步数 dfs(startX,startY-1,stepNum -1,grid); dfs(startX,startY+1,stepNum -1,grid); dfs(startX-1,startY,stepNum -1,grid); dfs(startX+1,startY,stepNum -1,grid); // 结束本次遍历后将当前位置还原为可经过路线，以便下次统计 grid[startX][startY] = 0; }} 1143. 最长公共子序列12345678910111213141516class Solution { public int longestCommonSubsequence(String text1, String text2) { int l1 = text1.length(),l2 = text2.length(); int[][] dp = new int[l1+1][l2+1]; for(int i = 0; i &lt; l1; i++){ for(int j = 0; j &lt; l2; j++){ if(text1.charAt(i) == text2.charAt(j)){ dp[i+1][j+1] = dp[i][j] + 1; }else{ dp[i+1][j+1] = Math.max(dp[i+1][j],dp[i][j+1]); } } } return dp[l1][l2]; }} 70. 爬楼梯 保存中间值： 123456789101112class Solution { public int climbStairs(int n) { if(n&lt;=2) return n; int[] sum = new int[n+1]; sum[1] = 1; sum[2] = 2; for(int i = 3; i &lt;= n;i++){ sum[i] = sum[i-1] + sum[i-2]; } return sum[n]; }} 动态规划：dp方程:f(n) = f(n-1) + f(n-2); 123456789101112class Solution { public int climbStairs(int n) { if(n &lt;= 2) return n; int f1 = 1,f2 = 2,f3 = 0; for(int i = 3;i &lt;= n; i++){ f3= f1 + f2; f1 = f2; f2 = f3; } return f3; }} 120. 三角形最小路径和 思路： 1234567891011class Solution { public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) { int[] path = new int[triangle.size() + 1]; for(int i = triangle.size() -1; i &gt;= 0;--i){ for(int j = 0; j &lt; triangle.get(i).size();++j){ path[j] = Math.min(path[j],path[j+1]) + triangle.get(i).get(j); } } return path[0]; }} 53. 最大子序和123456789101112131415class Solution { public int maxSubArray(int[] nums) { int res = nums[0]; int sum = 0; for(int i = 0; i &lt; nums.length; i++){ if(sum &gt; 0){ sum += nums[i]; }else{ sum = nums[i]; } res = Math.max(res,sum); } return res; }} 152. 乘积最大子数组 思路：当值为负数时，会令最大乘积变为最小乘积或最小乘积变为最大乘积 12345678910111213141516class Solution { public int maxProduct(int[] nums) { int proMin = 1 ,proMax = 1 ,max = Integer.MIN_VALUE; for(int i = 0; i &lt; nums.length; i++){ if(nums[i] &lt; 0){ int temp = proMax; proMax = proMin; proMin = temp; } proMin = Math.min(proMin*nums[i],nums[i]); proMax = Math.max(proMax*nums[i],nums[i]); max = Math.max(max,proMax); } return max; }} 字典树和并查集 字典树的数据结构 字典树，即Trie树，又称单词查找或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。 优点：最大限度地减少无谓的字符串比较，查询效率比哈希表高。 字典树的核心思想 空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。 字典树的基本性质 1、结点本身不存完整单词； 2、从根结点到某结点，路径上经过的字符连接起来，为该结点对应的字符串； 3、每个结点的所有子结点路径代表的字符都不相同。 字典树代码模板： 12345678910111213141516171819202122232425262728293031323334353637383940414243class Trie { private boolean isEnd; private Trie[] next; /** Initialize your data structure here. */ public Trie() { isEnd = false; next = new Trie[26]; } /** Inserts a word into the trie. */ public void insert(String word) { if (word == null || word.length() == 0) return; Trie curr = this; char[] words = word.toCharArray(); for (int i = 0;i &lt; words.length;i++) { int n = words[i] - 'a'; if (curr.next[n] == null) curr.next[n] = new Trie(); curr = curr.next[n]; } curr.isEnd = true; } /** Returns if the word is in the trie. */ public boolean search(String word) { Trie node = searchPrefix(word); return node != null &amp;&amp; node.isEnd; } /** Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) { Trie node = searchPrefix(prefix); return node != null; } private Trie searchPrefix(String word) { Trie node = this; char[] words = word.toCharArray(); for (int i = 0;i &lt; words.length;i++) { node = node.next[words[i] - 'a']; if (node == null) return null; } return node; }} 208. 实现 Trie (前缀树) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Trie { private boolean isEnd; private Trie[] next; /** Initialize your data structure here. */ public Trie() { isEnd = false; next = new Trie[26]; } /** Inserts a word into the trie. */ public void insert(String word) { if(word == null || word.length() == 0) return; Trie curr = this; char[] words = word.toCharArray(); for(int i = 0; i &lt; words.length; i++){ int n = words[i] - 'a'; if(curr.next[n] == null) curr.next[n] = new Trie(); curr = curr.next[n]; } curr.isEnd = true; } /** Returns if the word is in the trie. */ public boolean search(String word) { Trie node = searchPrefix(word); return node != null &amp;&amp; node.isEnd; } /** Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) { Trie node = searchPrefix(prefix); return node != null; } private Trie searchPrefix(String word){ Trie node = this; char[] words = word.toCharArray(); for(int i = 0; i &lt; words.length; i++) { node = node.next[words[i] - 'a']; if(node == null) return null; } return node; }}/** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */ 212. 单词搜索 II经典题型，使用字典树+dfs，逻辑思维简单易懂 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788class Solution { private static final int[] dx = new int[]{0,0,-1,1}; private static final int[] dy = new int[]{-1,1,0,0}; public List&lt;String&gt; findWords(char[][] board, String[] words) { if(words.length == 0) return new ArrayList&lt;&gt;(); // 构建字典树 Trie root = new Trie(); for(String word : words){ root.insert(word); } // 遍历board + dfs递归 向四周扩撒构建字符串，并在字典树中查找是否存在此字符串 Set&lt;String&gt; res = new HashSet&lt;&gt;(); int m = board.length,n = board[0].length; for(int i = 0; i &lt; m; i++){ for(int j = 0; j &lt; n; j++){ dfs(board,root,i,j,&quot;&quot;,res); } } return new ArrayList&lt;String&gt;(res); } public void dfs(char[][] board, Trie root, int i, int j, String currStr, Set res){ // 递归结束条件,边界处理以及访问过的字符不能再次访问 if(i &lt; 0 || j &lt; 0 || i == board.length || j == board[0].length || board[i][j] == '@') return; // 递归结束条件 2 char currChar = board[i][j]; if(root.next[currChar - 'a'] == null) return; // 处理当前层 char temp = currChar; board[i][j] = '@'; // 构建字符串 currStr += currChar; root = root.next[currChar - 'a']; if(root.isEnd){ res.add(currStr); } // 向上下左右递归下探 for(int k = 0; k &lt; dx.length; k++){ dfs(board,root,i + dx[k], j + dy[k],currStr,res); } // 将字符串置为空字符串 currStr = &quot;&quot;; // 恢复当前层字符 board[i][j] = temp; } class Trie { private boolean isEnd; private Trie[] next; /** Initialize your data structure here. */ public Trie() { isEnd = false; next = new Trie[26]; } /** Inserts a word into the trie. */ public void insert(String word) { if(word == null || word.length() == 0) return; Trie curr = this; char[] words = word.toCharArray(); for(int i = 0; i &lt; words.length; i++){ int n = words[i] - 'a'; if(curr.next[n] == null) curr.next[n] = new Trie(); curr = curr.next[n]; } curr.isEnd = true; } /** Returns if the word is in the trie. */ public boolean search(String word) { Trie node = searchPrefix(word); return node != null &amp;&amp; node.isEnd; } /** Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) { Trie node = searchPrefix(prefix); return node != null; } private Trie searchPrefix(String word){ Trie node = this; char[] words = word.toCharArray(); for(int i = 0; i &lt; words.length; i++) { node = node.next[words[i] - 'a']; if(node == null) return null; } return node; }}} 并查集数据结构：跟树有些类似，只不过和树是相反的。在树这个数据结构里面，每个结点会记录它的子结点。在并查集里，每个结点会记录它的父节点； 并查集适用场景：组团、配对问题 基本操作 makeSet(s)：建立一个新的并查集，其中包含s个单元素集合。 unionSet(x,y)：把元素x和元素y所在的集合合并，要求x和y所在的集合不相交，如果相交则不合并。 find(x)：找到元素x所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将他们各自的代表比较一下就可以了。 参考链接 代码模板： 12345678910111213141516171819202122232425class UnionFind { private int count = 0; private int[] parent; public UnionFind(int n) { count = n; parent = new int[n]; for (int i = 0; i &lt; n; i++) { parent[i] = i; } } public int find(int p) { while (p != parent[p]) { parent[p] = parent[parent[p]]; p = parent[p]; } return p; } public void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; parent[rootP] = rootQ; count--; }} 547. 省份数量思路：DFS 深度优先搜索 12345678910111213141516171819202122class Solution { public int findCircleNum(int[][] isConnected) { if(isConnected.length == 0) return 0; boolean[] statistics = new boolean[isConnected.length]; int res = 0; for(int i = 0; i &lt; isConnected.length; i++){ if(!statistics[i]){ dfs(isConnected,statistics,i); res++; } } return res; } public void dfs(int[][] isConnected,boolean[] statistics, int i){ for(int j = 0; j &lt; isConnected.length; j++){ if(isConnected[i][j] == 1 &amp;&amp; !statistics[j]){ statistics[j] = true; dfs(isConnected,statistics,j); } } }} 思路：BFS 广度优先搜索 123456789101112131415161718192021222324class Solution { public int findCircleNum(int[][] isConnected) { if(isConnected.length == 0) return 0; boolean[] statistics = new boolean[isConnected.length]; int res = 0; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for(int i = 0; i &lt; isConnected.length; i++){ if(!statistics[i]){ queue.offer(i); res++; while(!queue.isEmpty()){ int m = queue.poll(); for(int n = 0; n &lt; isConnected.length; n++){ if(isConnected[m][n] == 1 &amp;&amp; !statistics[n]){ queue.offer(n); statistics[n] = true; } } } } } return res; }} 思路：并查集 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution { public int findCircleNum(int[][] isConnected) { if(isConnected.length == 0) return 0; // 初始化并查集 UnionFind union = new UnionFind(isConnected.length); // 遍历isConnected中每个关联关系，有相连的城市合并为相同的省份 for(int i = 0; i &lt; isConnected.length; i++){ for(int j = 0; j &lt; isConnected.length; j++){ if(isConnected[i][j] == 1){ union.union(i,j); } } } return union.count; } class UnionFind { private int count = 0; private int[] parent; public UnionFind(int n) { count = n; parent = new int[n]; for (int i = 0; i &lt; n; i++) { parent[i] = i; } } public int find(int p) { while (p != parent[p]) { parent[p] = parent[parent[p]]; p = parent[p]; } return p; } public void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; parent[rootP] = rootQ; count--; } }} 200. 岛屿数量思路：DFS 深度优先搜索算法 123456789101112131415161718192021222324class Solution { private static int[] dx = new int[]{0,0,-1,1}; private static int[] dy = new int[]{-1,1,0,0}; public int numIslands(char[][] grid) { if (grid.length == 0) return 0; int count = 0; for (int i = 0; i &lt; grid.length; i++) { for (int j = 0; j &lt; grid[0].length; j++) { if (grid[i][j] == '1') { count++; dfs(grid, i, j); } } } return count; } public void dfs(char[][] grid, int i, int j){ if (i &lt; 0 || j &lt; 0 || i &gt;= grid.length || j &gt;= grid[0].length || grid[i][j] == '0') return; grid[i][j] = '0'; for(int k = 0; k &lt; dx.length; k++){ dfs(grid,i+dx[k],j+dy[k]); } }} 思路：BFS 广度优先搜索 12345678910111213141516171819202122232425262728293031class Solution { public int numIslands(char[][] grid) { if (grid.length == 0) return 0; int count = 0; for (int i = 0; i &lt; grid.length; i++) { for (int j = 0; j &lt; grid[0].length; j++) { if (grid[i][j] == '1') { count++; bfs(grid, i, j); } } } return count; } public void bfs(char[][] grid, int i,int j){ Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.offer(new int[]{i,j}); while(!queue.isEmpty()){ int[] curr = queue.poll(); i = curr[0]; j = curr[1]; if(i &gt;= 0 &amp;&amp; i &lt; grid.length &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; grid[0].length &amp;&amp; grid[i][j] == '1'){ grid[i][j] = '0'; queue.offer(new int[]{i,j-1}); queue.offer(new int[]{i,j+1}); queue.offer(new int[]{i-1,j}); queue.offer(new int[]{i+1,j}); } } }} 思路：并查集 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution { private int m,n; public int numIslands(char[][] grid) { if (grid.length == 0) return 0; m = grid.length; n = grid[0].length; UnionFind union = new UnionFind(m*n); int spaces = 0;// 空地的数量 int[][] direction = new int[][]{{1,0},{0,1}}; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (grid[i][j] == '0') { spaces++; }else{ for(int[] dire : direction){ int newx = i + dire[0]; int newy = j + dire[1]; // 判断边界 if(newx &lt; m &amp;&amp; newy &lt; n &amp;&amp; grid[newx][newy] == '1'){ // 合并陆地 union.union(getIndex(i,j),getIndex(newx,newy)); } } } } } return union.getCount() - spaces; } public int getIndex(int i,int j){ return i*n + j; } class UnionFind{ private int count; private int[] parent; UnionFind(int n){ count = n; parent = new int[n]; for(int i = 0; i &lt; n; i++){ parent[i] = i; } } private int find(int p){ while(p != parent[p]){ parent[p] = parent[parent[p]]; p = parent[p]; } return p; } private void union(int p, int q){ int P = find(p); int Q = find(q); if(P == Q) return; parent[P] = Q; count--; } public int getCount(){ return count; } }} 130. 被围绕的区域思路：DFS 深度优先搜索 1、遍历 board ，从边界为‘O’的开始递归，查找相联通的‘O’ 2、将与边界相联通的‘O’转换为‘#’，剩余‘O’就是被‘X’包围的 3、再次遍历 board，将‘#’转换为原来的‘O’，将‘O’转换为‘X’ 123456789101112131415161718192021222324252627282930313233343536class Solution { private static int[] dx = new int[]{0,0,-1,1}; private static int[] dy = new int[]{-1,1,0,0}; public void solve(char[][] board) { if (board.length == 0) return; int m = board.length,n = board[0].length; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { // 首先从边界为‘O’的开始递归下探,将与边界‘O’联通的‘O’都替换为‘#’ boolean isEdge = i == 0 || j == 0 || i == m-1 || j == n-1; if(isEdge &amp;&amp; board[i][j] == 'O'){ dfs(board,i,j); } } } // 将递归后的结果进行转换，‘#’代表和边界联通的，剩余的‘O’代表和边界不连通，需要转换为‘X’ for (int i = 0; i &lt; m; i++){ for(int j = 0; j &lt; n; j++){ if(board[i][j] == '#'){ board[i][j] = 'O'; }else if(board[i][j] == 'O'){ board[i][j] = 'X'; } } } } public void dfs(char[][] board, int i, int j){ // 递归结束条件 if (i &lt; 0 || j &lt; 0 || i &gt;= board.length || j &gt;= board[0].length || board[i][j] == 'X' || board[i][j] == '#') return; board[i][j] = '#'; // 左右上下，递归下探 for (int k = 0; k &lt; dx.length; k++){ dfs(board,i+dx[k],j+dy[k]); } }} 思路：BFS 广度优先搜索 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution { private static int[] dx = new int[]{0,0,-1,1}; private static int[] dy = new int[]{-1,1,0,0}; public void solve(char[][] board) { if (board.length == 0) return; int m = board.length,n = board[0].length; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { // 首先从边界为‘O’的开始递归下探,将与边界‘O’联通的‘O’都替换为‘#’ boolean isEdge = i == 0 || j == 0 || i == m-1 || j == n-1; if(isEdge &amp;&amp; board[i][j] == 'O'){ bfs(board,i,j); } } } // 将递归后的结果进行转换，‘#’代表和边界联通的，剩余的‘O’代表和边界不连通，需要转换为‘X’ for (int i = 0; i &lt; m; i++){ for(int j = 0; j &lt; n; j++){ if(board[i][j] == '#'){ board[i][j] = 'O'; }else if(board[i][j] == 'O'){ board[i][j] = 'X'; } } } } public void bfs(char[][] board, int i,int j){ Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.offer(new int[]{i,j}); while(!queue.isEmpty()){ int[] curr = queue.poll(); i = curr[0]; j = curr[1]; if(i &gt;= 0 &amp;&amp; i &lt; board.length &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].length &amp;&amp; board[i][j] == 'O'){ board[i][j] = '#'; for (int k = 0; k &lt; dx.length; k++){ queue.offer(new int[]{i+dx[k],j+dy[k]}); } } } }} 思路：并查集1、首先创建一个虚拟结点，将所有在边界上为‘O’的点都联通到虚拟结点上； 2、然后再将非边界上的‘O’按是否与边界元素‘O’相连分组； 3、按分组后的情况，将与边界‘O’相连的即就是与虚拟结点相连的都转换为‘O’，不与边界‘O’相连的说明就是被‘X’包围的，转换为‘X’； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution { private int[] dx = new int[]{0,0,-1,1}; private int[] dy = new int[]{-1,1,0,0}; private int rows,clos; public void solve(char[][] board) { rows = board.length; if (rows == 0) return; clos = board[0].length; UnionFind union = new UnionFind(rows*clos+1); int dummyNode = rows*clos; for (int i = 0; i &lt; rows; i++){ for(int j = 0; j &lt; clos; j++){ if (board[i][j] == 'O'){ if (i == 0 || j == 0 || i == rows - 1 || j == clos - 1){ union.union(getIndex(i,j),dummyNode); }else{ for(int k = 0; k &lt; dx.length; k++){ int currI = i + dx[k]; int currJ = j + dy[k]; if (currI &gt;= 0 &amp;&amp; currI &lt; rows &amp;&amp; currJ &gt;= 0 &amp;&amp; currJ &lt; clos &amp;&amp; board[currI][currJ] == 'O'){ union.union(getIndex(i,j),getIndex(currI,currJ)); } } } } } } for (int i = 0; i &lt; rows; i++){ for (int j = 0; j &lt; clos; j++) { if (union.find(getIndex(i,j)) == union.find(dummyNode)){ board[i][j] = 'O'; }else { board[i][j] = 'X'; } } } } public int getIndex (int i, int j){ return i * clos + j; } class UnionFind{ private int count; private int[] parent; UnionFind(int n){ count = n; parent = new int[n]; for (int i = 0; i &lt; n; i++){ parent[i] = i; } } private int find(int p){ while(p != parent[p]){ parent[p] = parent[parent[p]]; p = parent[p]; } return p; } private void union(int p, int q){ int P = find(p); int Q = find(q); if (p == Q) return; parent[P] = Q; count--; } }}","link":"/2021/01/31/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"title":"第一章 影响力的武器 ——武装自己","text":"凡事都应当尽可能地简单，而不是较为简单。——阿尔伯特·爱因斯坦 实验案例：雌火鸡对小火鸡的“叽叽”声很敏感，即使这个声音是实验模拟发出的，它也会机械重复的执行自己作为母亲的职责。 固定行为模式，这些模式的一个基本特点是：每一次，构成模式的所有行为几乎都是按相同的方式、相同的顺序发生的。 人类也有相似的自动反应模式，比如：我们在要别人帮忙的时候，要是能给一个理由，成功的概率会更大，因为人就是单纯地喜欢做事有个理由。 大部分影响力武器具备的相同要素： 这类武器有能力激活一种近似机械化的过程 只要掌握了触发这种过程的能力，人们就能从中渔利 使用者能借助这些自动影响力武器的威力，这种武器就好像一根沉甸甸的大棒，只要用了它，就能让另一个人乖乖就范。 例如：人类认知中的“对比原理”，两样东西一前一后地展示出来，我们怎样看待其间的区别，对比原理是有影响的。简单地说，要是第二样东西跟第一样东西有着相当的不同，那么，我们往往会认为两者的区别比实际上更大。","link":"/2021/01/31/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%BD%B1%E5%93%8D%E5%8A%9B%E7%9A%84%E6%AD%A6%E5%99%A8%20%E2%80%94%E2%80%94%E6%AD%A6%E8%A3%85%E8%87%AA%E5%B7%B1/"},{"title":"第二章 互惠 ——给予，索取，再索取","text":"每一笔债都还得干干净净，就好像上帝他老人家是债主。——拉尔夫·沃尔多·爱默生互惠原理，别人给了我们什么好处，我们理应有义务在将来回报别人的好意、礼物、邀请等。 1、互惠原理如何起作用？ 我们每个人从小听人教导，不能辜负了它，我们每个人也都知道，凡是有人敢违背它，必然要受到社会的制裁和嘲笑。由于普通人大多讨厌一味索取、从不回报的家伙，我们往往会想法设法地避免被别人看成是揩油王、忘恩负义的王八蛋，或是不劳而获的懒虫。 2、互惠原理在人类社会中到处都能运用，而且所向披靡，比如政客间和生意场的请客吃饭送礼，以及经济活动中的应用，，比如超市免费赠送样本体验等。 3、人类可利用互惠原理触发不对等交换，别人最初给予的小小恩惠，能够让当事人产生亏欠感，最终回报以大得多的恩惠。 4、互惠式让步，高阶使用技巧，先提大要求后提小要求。互惠原理和直觉对比原理的结合。 5、如何抵挡使用互惠原理的敌人？ 首先要学会辨别别人的恩惠是真诚的善意还是虚假的策略，如果是善意的就以善意回报，否则就拒绝。","link":"/2021/01/31/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E4%BA%92%E6%83%A0%20%E2%80%94%E2%80%94%E7%BB%99%E4%BA%88%EF%BC%8C%E7%B4%A2%E5%8F%96%EF%BC%8C%E5%86%8D%E7%B4%A2%E5%8F%96/"},{"title":"第三章 承诺和一致——脑子里的怪物","text":"一开始就拒绝，比最后反悔要容易。——达芬奇 人人都有一种言行一致（同时也显得言行一致）的愿望。一旦我们作出了一个选择，或采取了某种立场，我们立刻就会碰到来自内心和外部的压力，迫使我们按照承诺的那样去做。在这样的压力之下，我们会想方设法地以行动证明自己先前的决定是正确的。我们所有人都会一次次地欺骗自己，以便在作出选择之后，坚信自己做得没错。 这就是承诺和一致原则对人的行为的强大指引力量。 言出必行，在大多数环境下，言行一致都是很有价值也很合适的。依照人们的普遍感觉，言行不一是一种不可取的人格特性。信仰、言语和行为前后不一的人，会被看成是脑筋混乱、表里不一，甚至精神有毛病的。另一方面，言行高度一致大多跟个性坚强、智力出众挂钩，他是逻辑性、稳定性和诚实感的核心。 1、为什么我们要努力做到L言行一致？ 因为日常生活的纷繁复杂对我们的精力和能力都提出了苛刻的要求，有了一致性我们就能以相对轻松、高效的便利方式来应对一切了。是我们懒惰的大脑想避免思考的一种处理方式。 2、人们是如何利用承诺和一致原则来达到自己的目的的呢？ 承诺是关键，通过各种直接的或间接的方式诱使人们做出承诺，那么人自然就想要倔强地按照之前的承诺去保持一致从而完成达到自己的目的。而且为一个承诺付出的努力越多，它对承诺者的影响也就越大。 3、如何避免自己受承诺和一致原则的影响？ 尽管保持言行一致是好品质，但是这只适用于大多数情况，在某些地方我们也必须避免愚蠢的死脑筋。因为我们不假思索自动保持一致的反应，正是某些人耍花招利用它在我们身上谋利的策略。","link":"/2021/01/31/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%89%BF%E8%AF%BA%E5%92%8C%E4%B8%80%E8%87%B4%E2%80%94%E2%80%94%E8%84%91%E5%AD%90%E9%87%8C%E7%9A%84%E6%80%AA%E7%89%A9/"},{"title":"第四章 社会认同——我们就是真理","text":"在人人想法都差不多的地方，没人会想得太多——沃尔特·李普曼 社会认同原理：在判断何为正确时，我们会根据别人的意见行事。 我们对社会认同的反应方式完全是无意识的、条件反射式的。 1、什么时候会容易产生社会认同？ 一般来说，在我们自己不确定、情况不明或含糊不清，意外性太大的时候，我们最有可能觉得别人的行为是正确的。但是在审视他人反应，消除不确定性的过程中，我们很容易忽视一点微妙而重要的事实：其他人有可能也在寻找社会证据。尤其是在局面模糊不清的时候，人人都倾向于观察别人在做什么，这会导致一种叫“多元无知”的有趣现象。 2、社会认同原理能发挥出最大的影响力的一条适用条件：相似性。我们会根据他人的行为来判断自己怎么做才合适，尤其是在我们觉得这些人跟自己相似的时候。 3、如何拒绝？ 如果在情况不明或含糊不清时，应该及时关闭社会认同开关，谨防同类的伪造数据和虚假证据。面对明显时伪造的社会证据，我们只要多保持一点警惕感，就能很好地保护自己了。首先，我们似乎持有这样的假设：要是很多人在做相同的事情，他们必然知道一些我们不知道的事情。尤其在我们并不确定的时候，我们很乐意对这种集体智慧投入极大的信任。其次，人群很多时候都是错的，因为群体的成员并不是根据优势信息才采取行动，而只是基于社会认同原理在做反应。","link":"/2021/01/31/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E7%A4%BE%E4%BC%9A%E8%AE%A4%E5%90%8C%E2%80%94%E2%80%94%E6%88%91%E4%BB%AC%E5%B0%B1%E6%98%AF%E7%9C%9F%E7%90%86/"},{"title":"第五章 喜好 ——友好的窃贼","text":"辩护律师的主要任务就是让陪审团喜欢他的客户 —— 克拉伦斯·达罗 我们大多数人总是更容易答应自己认识和喜欢的人所提出的要求。 1、我喜欢你的理由 外表魅力：长的好看的人在社交中占有优势，我们会自动给长得好看的人添加一些正面特点，比如有才华、善良、诚实和聪明等。而且我们在作出这些判断的时候并没有意识到外表魅力在其中发挥的作用。 相似性：我们喜欢与自己相似的人。不管相似之处是在观点、个性、背景还是生活方式上，我们总有这样的倾向。 恭维：我们特别喜欢听人恭维奉承 接触与合作：我们更喜欢自己熟悉的人或者相互之间有合作的人 条件反射和关联：我们总喜欢给自己带来好消息的人，讨厌给自己带来坏消息的人。人们深知关联原理的奥妙，并努力把自己跟积极的事情联系起来，跟消极的事情保持距离。 2、如何拒绝？ 不去压抑好感因素产生的影响力，听凭这些因素发挥力量，然后用这股力量反过来对付那些想从中获利的人。","link":"/2021/01/31/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%96%9C%E5%A5%BD%20%E2%80%94%E2%80%94%E5%8F%8B%E5%A5%BD%E7%9A%84%E7%AA%83%E8%B4%BC/"},{"title":"第六章 权威 —— 教化下的敬重","text":"跟着权威走。—— 维吉尔 1、权威高压的力量 在权威的命令下，成年人几乎愿意干任何事情。政府机构往往都有这样的能力从普通共鸣身上压榨出可怕的百依百顺，对他们而言，这样的结果显然具有更为严肃的引申意义。 2、盲目服从的诱惑和危险 服从权威人物的命令，总能给我们带来一些实际的好处。部分原因是因为他们更有智慧，也有部分原因是他们手里攥着对我们的奖惩。很多情况下，只要有正统的权威说了话，其他本来应该考虑的事情就变得不相关了。 3、内涵不是内容 在没有真正权威的情况下，有几种象征权威的符号能十分有效的触发我们的顺从态度。 头衔：头衔比当事人的本质更能影响他人的行为。头衔除了能让陌生人表现更恭顺，还能让有头衔的那个人在旁人眼里显得更高大。 衣着：一个西装革履的人和一个着装普普通通的人你觉得那个人比较有权威？ 身份标识：开名车戴名表的人和普通人你觉得那个人比较有权威？ 4、如何拒绝 当你认识到权威的力量后，对付以权威或虚假的权威象征符号代表的权威影响力来左右我们的时候，我们的防御策略就是提高警惕。首先质疑权威的资格，以及这些资格是否跟眼前的主题相关，然后再质疑权威说的是真话吗？，因为即使是真正的权威专家也不见得会诚实地把正确的信息告知我们。","link":"/2021/01/31/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%9D%83%E5%A8%81%20%E2%80%94%E2%80%94%20%E6%95%99%E5%8C%96%E4%B8%8B%E7%9A%84%E6%95%AC%E9%87%8D/"},{"title":"第七章 稀缺 —— 数量少的说了算","text":"不管是什么东西，只要你晓得会失去它，自然就会爱上它。—— G.K. 切斯特顿 1、物以稀为贵 稀缺原理：机会越少，价值似乎越高。对失去某种东西的恐惧，似乎要比对获得同一物品的渴望，更能激发人们的行动力。 2、逆反心理 我们基本可以根据获得一样东西的难易程度，迅速准确地判断它的质量。机会越来越少的话，我们的自由也会随之丧失。而我们又痛恨失去本来拥有的自由。保住既得利益的愿望，是心理逆反理论的核心。 3、最佳条件 一开始就知道机会少比开始有机会后来再慢慢减少机会的场景，后者比前者更加有刺激性。 4、如何拒绝 一旦在顺从环境下体验到高涨的情绪，我们就可以提醒自己：说不定有人在玩弄稀缺手法，必须谨慎行事。那么如何判断稀缺的东西是真的对我们有价值呢？那就需要我们清楚的思考，我们想从这样的东西里获得什么？如果带来的价值是我们迫切想要的，而且付出的代价是我们能够承受的，那么就去占有它吧！","link":"/2021/01/31/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E7%A8%80%E7%BC%BA%20%E2%80%94%E2%80%94%20%E6%95%B0%E9%87%8F%E5%B0%91%E7%9A%84%E8%AF%B4%E4%BA%86%E7%AE%97/"},{"title":"高情商的人不会做的四件事","text":"来自 github 上一位博主的分享 4 Things Emotionally Intelligent People Don’t DoGive up these bad habits and your natural emotional intelligengce will shine. Improving your emotional intelligence is often about what you do less of , not more of. 改掉不好的习惯，自然不做作的情商才会使你大放异彩。提高情商往往是少做什么而不是多做。 情商不好的人往往体现在一下几个方面： They blame other people for their problems They trap themselves in cycles of stress and anxiety They self-sabotage as soon as they start to make progress 如果你想提高你的情商，就在生活中学会去努力避免这些不好的习惯，那么是那四件事呢？ 1. Criticizing others 批评别人 Criticizing others is often an unconscious defense mechanism aimed at alleviating our own insecurities. 批评别人往往是一种无意识的防御机制，目的是减轻我们自己的不安全感。为什么呢？ When you point out to yourself that someone else is dumb , you’re also implying that you’re smart . And that feels good. When you criticize someone else for being naive , what you’re really doing is telling yourself that you’re somhisticated . And that feels good. When you silently chuckle to yourself about how terrible someone’s fashion sense is ,you’re telling yourself how refined your own taste is . And that feels good. 许多人都喜欢站在傍观者的角度给别人提意见，说出别人的不好，美其名曰为了别人好。但是 Unhelpful criticism is about making yourself feel better. 所以，我们在不可能完全彻底了解一个人的时候，尽量不要去批评别人，反而多点鼓励和欣赏才是正确的做法。 “Criticism of others is a form of self-commendation(自我表扬). We think we make the picture hang straight on our wall by telling our neighbors that all his pictures are crooked(扭曲的).” ― Fulton J. Sheen 2. Worrying about the future 担心未来 为什么会担心未来？因为未来是充满不确定性，但是我们谁都不喜欢不确定性。 Chronic worriers live under the illusion that thinking is always problem-solving and that planning always leads to greater levels of preparedness. But neither of those are true: 长期担忧者总生活在一种错觉中，认为思考总能解决问题，计划总能让准备更加充分。 Just because you’re thinking about a problem doesn’t mean you’re thinking about it productively. 但是仅仅因为你思考一个问题，不代表你能卓有成效的思考它。 And just because you’re planning - running through countless hypothetical future scenarios - doesn’t mean you’re any better equipped to handle them. Often, you’re just making yourself feel more prepared. 仅仅因为你的计划——贯穿了无数假定的未来场景。但这并不意味着你就能更好地应对他们。通常，你只是让自己感觉准备得更充分。 “Worry does not empty tomorrow of its sorrow, it empties today of its strength.”― Corrie Ten Boom 3. Ruminating on the past 活在过去 If you want to move on with your life instead of staying stuck in the past ,you must accept the past for what it is—including feeling helpless. 如果你想让你的生活继续前行而不是停滞不前，你就必须接受过去——包括无助的感受 莫名的想起前段时间在看《被讨厌的勇气》中提到的阿德勒心理学提倡的“目的论”和弗洛伊德心理学说的“原因论”，关于一个人是否能改变自己，“原因论”认为，是因为过去的某些创伤（比如自己从小胆小怯懦）导致了你做不出改变自己的行动，而“目的论”认为，是因为你不想改变自己，做不到改变自己的行动才找出过去的某些创伤来解释自己为什么做不到，因为相比找一个过去的原因比你去做出改变容易的多。人们总是喜欢做简单的事情。 人们常常会觉得以前我要是努力点就不至于是现在这个样子了，但是往往这样抱怨都是没用的，所以，忘掉过去，从现在开始也不晚。 Don’t give up control over your future by pretending you can control the past. “To think too much is a disease.” ― Fyodor Dostoyevsky 4. Maintaining unrealistic expectations 抱有不切实际的期望 But what does it mean, exactly, to maintain an unrealistic expectation? You probably see your expectations of other people as a good thing: Having high expectations for people encourages them to grow and mature and become their best self! 不要对别人抱有不切实际的期望，因为当他达不到你的期望会让你感到沮丧和失望。我们应该对自己充满信心，不应该期望别人来帮助你。 “He was swimming in a sea of other people’s expectations. Men had drowned in seas like that.” ― Robert Jordan","link":"/2021/01/31/%E9%AB%98%E6%83%85%E5%95%86%E7%9A%84%E4%BA%BA%E4%B8%8D%E4%BC%9A%E5%81%9A%E7%9A%84%E5%9B%9B%E4%BB%B6%E4%BA%8B/"},{"title":"字符串算法","text":"1、字符串基础问题709. 转换成小写字母 ASCII码表： a-z：97-122 A-Z：65-90 0-9：48-57 12345678910111213141516class Solution { public String toLowerCase(String str) { int len = str.length(); StringBuffer sb = new StringBuffer(); for(int i = 0; i &lt; len; i++){ int ascii = (int)str.charAt(i); if(ascii &gt;= 65 &amp;&amp; ascii &lt;= 90){ char c = (char)(ascii+32); sb.append(c); }else{ sb.append(str.charAt(i)); } } return sb.toString(); }} 58. 最后一个单词的长度调用分割函数 1234567class Solution { public int lengthOfLastWord(String s) { if(s == null || s.length() == 0) return 0; String[] arrays = s.split(&quot; &quot;); return arrays.length == 0 ? 0 : arrays[arrays.length - 1].length(); }} 从后往前遍历 1234567891011class Solution { public int lengthOfLastWord(String s) { if(s == null || s.length() == 0) return 0; int end = s.length() - 1; while(end &gt;= 0 &amp;&amp; s.charAt(end) == ' ') end--; if(end &lt; 0) return 0; int start = end; while(start &gt;= 0 &amp;&amp; s.charAt(start) != ' ') start--; return end - start; }} 771. 宝石与石头 123456789101112class Solution { public int numJewelsInStones(String jewels, String stones) { if(jewels.length() == 0 || stones.length() == 0) return 0; int res = 0; for(char jewel : jewels.toCharArray()){ for(char stone : stones.toCharArray()){ if(jewel == stone) res++; } } return res; }} 387. 字符串中的第一个唯一字符 123456789101112131415161718class Solution { public int firstUniqChar(String s) { if(s == null || s.length() == 0) return -1; Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); for(char c : s.toCharArray()){ if(!map.containsKey(c)){ map.put(c,1); }else{ map.put(c,map.get(c)+1); } } for(int i = 0; i &lt; s.length(); i++){ int count = (int)map.get(s.charAt(i)); if(count == 1) return i; } return -1; }} 8. 字符串转换整数 (atoi) 123456789101112131415161718192021222324252627282930313233343536373839class Solution { public int myAtoi(String s) { int res = 0; int len = s.length(); char[] charArray = s.toCharArray(); // 定义一个下标指针 int index = 0; // 循环遍历，去掉前导空格 while(index &lt; len &amp;&amp; charArray[index] == ' '){ index++; } // 处理极端情况 if(index == len) return 0; // 检查是正数还是负数 int sign = 1; char first = charArray[index]; if(first == '+'){ index++; }else if(first == '-'){ index++; sign = -1; } // 循环遍历字符 while(index &lt; len){ char c = charArray[index]; // 检查字符是否是数字字符 if(c &gt; '9' || c &lt; '0') break; // 检查数字是否越界 if(res &gt; Integer.MAX_VALUE/10 || (res == Integer.MAX_VALUE/10 &amp;&amp; (c - '0') &gt; Integer.MAX_VALUE%10)) return Integer.MAX_VALUE; if(res &lt; Integer.MIN_VALUE/10 || (res == Integer.MIN_VALUE/10 &amp;&amp; (c - '0') &gt; - (Integer.MIN_VALUE%10))) return Integer.MIN_VALUE; // 合法情况，转换字符为相应的数字 res = res*10 + sign * (c - '0'); index++; } return res; }} 2、字符串操作问题14. 最长公共前缀 1234567891011121314151617class Solution { public String longestCommonPrefix(String[] strs) { if(strs.length == 0) return &quot;&quot;; String prefix = strs[0]; for(int i = 1; i &lt; strs.length; i++){ String currStr = strs[i]; int j = 0; for(; j &lt; prefix.length() &amp;&amp; j &lt; currStr.length(); j++){ if(currStr.charAt(j) != prefix.charAt(j)) break; } prefix = prefix.substring(0,j); if(prefix.equals(&quot;&quot;)) return &quot;&quot;; } return prefix; }} 344. 反转字符串 1234567891011121314class Solution { public void reverseString(char[] s) { int left = 0 ,right = s.length - 1; while(left &lt; right){ if(s[left] != s[right]){ char temp = s[left]; s[left] = s[right]; s[right] = temp; } left++; right--; } }} 541. 反转字符串 II 1234567891011121314class Solution { public String reverseStr(String s, int k) { char[] charArray = s.toCharArray(); for(int index = 0;index &lt; charArray.length;index +=2*k){ int left = index,right = Math.min(index + k - 1,charArray.length - 1); while(left &lt; right){ char temp = charArray[left]; charArray[left++] = charArray[right]; charArray[right--] = temp; } } return new String(charArray); }} 151. 翻转字符串里的单词 123456789class Solution { public String reverseWords(String s) { // 去除多余空格 s = s.trim(); List&lt;String&gt; strList = Arrays.asList(s.split(&quot;\\s+&quot;)); Collections.reverse(strList); return String.join(&quot; &quot;,strList); }} 557. 反转字符串中的单词 III 12345678910111213141516171819class Solution { public String reverseWords(String s) { String[] strArray = s.split(&quot; &quot;); StringBuffer sb = new StringBuffer(); for(String currStr : strArray){ int right = currStr.length() - 1; int left = 0; char[] charArr = currStr.toCharArray(); while(left &lt; right){ char temp = charArr[left]; charArr[left++] = charArr[right]; charArr[right--] = temp; } sb.append(charArr); sb.append(&quot; &quot;); } return sb.toString().trim(); }} 917. 仅仅反转字母思路：双指针，碰到非字母字符跳过循环 12345678910111213141516171819202122232425262728class Solution { public String reverseOnlyLetters(String S) { int len = S.length(); if(len &lt; 2) return S; // 熟悉的双指针 int left = 0,right = len - 1; char[] charArr = S.toCharArray(); while(left &lt; right){ char leftChar = charArr[left]; char rightChar = charArr[right]; if(!isLetter(leftChar)) { left++; continue; } if(!isLetter(rightChar)) { right--; continue; } char temp = charArr[left]; charArr[left++] = charArr[right]; charArr[right--] = temp; } return new String(charArr); } public boolean isLetter(char c){ return (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= 'a' &amp;&amp; c &lt;= 'z'); }} 3、异位词问题242. 有效的字母异位词 123456789101112131415161718192021class Solution { public boolean isAnagram(String s, String t) { if (s.isEmpty() &amp;&amp; t.isEmpty()) { return true; } if (s.length() != t.length()) { return false; } char[] sChars = s.toCharArray(); char[] tChars = t.toCharArray(); Arrays.sort(sChars); Arrays.sort(tChars); for (int i = 0; i &lt; sChars.length; i++) { if (sChars[i] != tChars[i]) { return false; } } //return Arrays.equals(sChars, tChars); return true; }} 49. 字母异位词分组 123456789101112131415161718 class Solution { public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) { if (strs == null || strs.length == 0) { return new ArrayList&lt;&gt;(); } Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; strs.length; i++) { char[] chars = strs[i].toCharArray(); Arrays.sort(chars); String key = String.valueOf(chars); if (!map.containsKey(key)) { map.put(key, new ArrayList&lt;&gt;()); } map.get(key).add(strs[i]); } return new ArrayList&lt;&gt;(map.values()); }} 438. 找到字符串中所有字母异位词 4、回文串问题125. 验证回文串 思路：先筛选，再反转，再比较 12345678910111213class Solution { public boolean isPalindrome(String s) { if(s.length() == 0) return true; StringBuilder sb = new StringBuilder(); for(char c : s.toCharArray()){ if((c &lt;= 'Z' &amp;&amp; c &gt;= 'A') || (c &lt;= 'z' &amp;&amp; c &gt;= 'a') || (c &lt;= '9' &amp;&amp; c &gt;='0')) sb.append(c); } String origStr = sb.toString(); String reverseStr = sb.reverse().toString(); return reverseStr.equalsIgnoreCase(origStr); }} 思路：双指针判断1、如果 start 指针所指字符不符合[^A-Za-z0-9] start++ ,跳过本次判断； 2、如果 end 指针所指字符不符合[^A-Za-z0-9] end– , 跳过本次判断； 3、如果 start 、end 指针所指字符都不符合，start++,end–; 4、如果 start 、end 指针所指字符忽略大小写情况下不相同，就代表不是回文串，返回 false; 1234567891011121314151617181920212223242526272829class Solution { public boolean isPalindrome(String s) { if(s.length() == 0) return true; // 双指针 int start = 0,end = s.length() - 1; while(start &lt; end){ char startC = s.charAt(start); char endC = s.charAt(end); if(!isMath(startC)) { start++; continue; } if(!isMath(endC)) { end--; continue; } if(Character.toLowerCase(startC) != Character.toLowerCase(endC)) { return false; }else{ start++; end--; } } return true; } public boolean isMath(char c){ return ((c &lt;= 'Z' &amp;&amp; c &gt;= 'A') || (c &lt;= 'z' &amp;&amp; c &gt;= 'a') || (c &lt;= '9' &amp;&amp; c &gt;='0')); }} 680. 验证回文字符串 Ⅱ思路：双指针 1、i 指针从头开始，j 指针从尾开始，依次比较是否相等; 2、charArrsy[i] == charArray[j] , 则将这两字符算在回文串中，并 i++，j–; 3、charArrsy[i] != charArray[j] , 说明这两个字符是构成回文串的“阻碍”，依据题目可以删除其中任意一个字符后再进行比较； 4、比较删除其中任意字符后的字串是否构成回文串，删除左边字符后取(i+1,j)范围内字符比较，删除右边字符取(i,j-1)范围内字符比较； 5、比较字串是否是回文串又是“双指针”的用法； 为什么使用字符数组，这样虽然开辟了多余的内存，但是数组能提升查询效率 1234567891011121314151617class Solution { public boolean validPalindrome(String s) { char[] charArray = s.toCharArray(); for(int i = 0,j = charArray.length -1; i &lt; j; i++,j--){ if(charArray[i] != charArray[j]){ return isPalindrome(charArray,i+1,j) || isPalindrome(charArray,i,j-1); } } return true; } public boolean isPalindrome(char[] charArray , int i,int j){ while(i &lt; j){ if(charArray[i++] != charArray[j--]) return false; } return true; }} 5、最长子串、子序列问题最常规子串、子序列问题： 1143. 最长公共子序列 思路：动态规划 题解：动态规划图文解析（java） key：找到动态方程 1、当前对比的两个字符不相同时，取text1倒退一格和text2倒退一格两者中的最大值，也就是 dp[i + 1][j + 1] = Math.max(dp[i+1][j], dp[i][j+1]); 2、当前对比的两个字符相同时，取text1与text2各退一格的值+1，及 dp[i+1][j+1] = dp[i][j] + 1; 1234567891011121314151617181920class Solution { public int longestCommonSubsequence(String text1, String text2) { int m = text1.length(), n = text2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { // 获取两个串字符 char c1 = text1.charAt(i), c2 = text2.charAt(j); if (c1 == c2) { // 去找它们前面各退一格的值加1即可 dp[i + 1][j + 1] = dp[i][j] + 1; } else { //要么是text1往前退一格，要么是text2往前退一格，两个的最大值 dp[i + 1][j + 1] = Math.max(dp[i + 1][j], dp[i][j + 1]); } } } return dp[m][n]; }} 72. 编辑距离思路：动态规划 dp方程. dp[i][j] 表示 word1 字符串前 i +1个字符组成的字符串转换为 word2 字符串前 j +1个字符组成的字符串的最少操作数，那么 1、当 word1.charAt(i) == word2.charAt(j) ，只有一种操作删除，dp[i][j] = dp[i-1][j-1]; 2、当 word1.charAt(i) != word2.charAt(j) ，有三种操作替换dp[i-1][j-1]，删除dp[i-1][j]，插入dp[i][j-1]，求三者的最小值 min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])； 3、当 word1 为空字符串时，只能通过插入操作来转换 ，也就是 dp[j][0] = dp[j-1][0] + 1； 4、当 word2 为空字符串时，只能通过删除操作来转换 ，也就是 dp[0][i] = dp[0][i-1] + 1； 123456789101112131415161718192021class Solution { public int minDistance(String word1, String word2) { int len1 = word1.length(); int len2 = word2.length(); int[][] dp = new int[len1+1][len2+1]; for(int i = 1; i &lt;= len2; i++) dp[0][i] = dp[0][i-1] + 1; for(int j = 1; j &lt;= len1; j++) dp[j][0] = dp[j-1][0] + 1; for(int i = 1; i &lt;= len1; i++){ for(int j = 1; j &lt;= len2; j++){ char c1 = word1.charAt(i-1); char c2 = word2.charAt(j-1); if(c1 == c2){ dp[i][j] = dp[i-1][j-1]; }else{ dp[i][j] = Math.min(Math.min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1]) + 1; } } } return dp[len1][len2]; }} 5. 最长回文子串思路：暴力+双指针 1234567891011121314151617181920212223class Solution { public String longestPalindrome(String s) { if(s.length() &lt;= 1) return s; int maxLen = 1; int index = 0; char[] charArr = s.toCharArray(); for(int i = 0; i &lt; s.length(); i++){ for(int j = i+1; j &lt; s.length(); j++){ if(j-i+1 &gt; maxLen &amp;&amp; isPalindrime(charArr,i,j)){ maxLen = j-i+1; index = i; } } } return s.substring(index,index + maxLen); } public boolean isPalindrime(char[] charArr,int left ,int right){ while(left &lt; right){ if(charArr[left++] != charArr[right--]) return false; } return true; }} 动态规划： 1234567891011121314151617181920212223242526272829303132333435363738class Solution { public String longestPalindrome(String s) { int len = s.length(); if(len &lt;= 1) return s; char[] charArr = s.toCharArray(); // 记录子串是回文串的长度 int maxLen = 1; // 记录子串是回文串的头坐标 int index = 0; // dp[i][j] 代表[i,j]区间内子串是否式回文串 boolean [][] dp = new boolean[len][len]; // 子串长度为 1，一个字符时肯定是回文串 for(int i = 0;i &lt; len; i++){ dp[i][i] = true; } // 状态转移方程 charArr[i] == charArr[j] 前提下 dp[i][j] = dp[i+1][j-1] ， // 判断当前子串是否是回文串 == 当首尾字符相同的情况下取决于剩余子串是否是回文串 for(int j = 1; j &lt; len; j++){ for(int i = 0; i &lt; j; i++){ if(charArr[i] != charArr[j]){ dp[i][j] = false; }else{ // (i,j) 区间长度小于2的子串都是回文串 if(j-i &lt; 3){ dp[i][j] = true; }else{ dp[i][j] = dp[i+1][j-1]; } } if(j-i+1 &gt; maxLen &amp;&amp; dp[i][j]){ maxLen = j-i+1; index = i; } } } return s.substring(index,index + maxLen); } } 6、字符串+DP问题10. 正则表达式匹配 7、字符串匹配算法","link":"/2021/02/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"},{"title":"除夕夜","text":"来自 微信公众号“为你读诗”除夕 作者：于谦[明] 今宵是除夕，明日又新年。 爆竹惊残梦，寒镫照独眠。 风霜催腊尽，梅柳得春先。 抚景情无限，那能不怅然。 许愿：2021 祝自己万事如意","link":"/2021/02/12/2021%E9%99%A4%E5%A4%95%EF%BC%8C%E4%B8%BA%E4%BD%A0%E8%AF%BB%E8%AF%97/"},{"title":"《百元之恋》观后感","text":"来自 《百元之恋》日常的生活丧吗？这无疑是肯定的。就像电影的结尾，狩野拉着一子去吃饭一样，深情浪漫与惊天动地有的话也只是转瞬即逝，普通人生活的大部分时间，也都是朴实无华。今天即便有再大的挫折，一觉醒来后或许依旧是满满的颓废。不过事在人为，时间会解决一切。这不是一碗甜蜜的鸡汤，而是一管苦涩的藿香正气，喝完之后，日子还是要奔的，工作还是要干的，领导还是要“骂”的，坎坷还是要继续经历的。","link":"/2021/02/12/%E3%80%8A%E7%99%BE%E5%85%83%E4%B9%8B%E6%81%8B%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/"}],"tags":[{"name":"读书","slug":"读书","link":"/tags/%E8%AF%BB%E4%B9%A6/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"编程","slug":"编程","link":"/tags/%E7%BC%96%E7%A8%8B/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"}],"categories":[{"name":"读书","slug":"读书","link":"/categories/%E8%AF%BB%E4%B9%A6/"},{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"},{"name":"生活随笔","slug":"生活随笔","link":"/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"}]}