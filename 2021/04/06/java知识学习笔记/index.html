<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java知识学习笔记 - 君子终日乾乾，夕惕若厉，无咎</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="君子终日乾乾，夕惕若厉，无咎"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="君子终日乾乾，夕惕若厉，无咎"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="1、常见设计模式有哪些？创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。"><meta property="og:type" content="blog"><meta property="og:title" content="Java知识学习笔记"><meta property="og:url" content="https://mry-byte.github.io/2021/04/06/java%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="君子终日乾乾，夕惕若厉，无咎"><meta property="og:description" content="1、常见设计模式有哪些？创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://uploader.shimo.im/f/m9xECnZqKgzsfYvC.png!thumbnail?fileGuid=DjpqxkRGwrxjGwtc"><meta property="og:image" content="https://uploader.shimo.im/f/dI1dTnVmUL9VFiAu.png!thumbnail?fileGuid=DjpqxkRGwrxjGwtc"><meta property="article:published_time" content="2021-04-06T05:39:07.650Z"><meta property="article:modified_time" content="2021-04-06T05:36:28.777Z"><meta property="article:author" content="Mr.y"><meta property="article:tag" content="编程"><meta property="article:tag" content="java"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://uploader.shimo.im/f/m9xECnZqKgzsfYvC.png!thumbnail?fileGuid=DjpqxkRGwrxjGwtc"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://mry-byte.github.io/2021/04/06/java%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},"headline":"君子终日乾乾，夕惕若厉，无咎","image":[],"datePublished":"2021-04-06T05:39:07.650Z","dateModified":"2021-04-06T05:36:28.777Z","author":{"@type":"Person","name":"Mr.y"},"description":"1、常见设计模式有哪些？创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。"}</script><link rel="canonical" href="https://mry-byte.github.io/2021/04/06/java%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">君子终日乾乾，夕惕若厉，无咎</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives/">归档</a><a class="navbar-item" href="/categories/">分类</a><a class="navbar-item" href="/tags/">标签</a><a class="navbar-item" href="/about/">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/Mry-byte/Mry-byte.github.io">GitHub</a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-06T05:39:07.650Z" title="2021/4/6 13:39:07">2021-04-06</time>发表</span><span class="level-item"><time dateTime="2021-04-06T05:36:28.777Z" title="2021/4/6 13:36:28">2021-04-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span><span class="level-item">2 小时读完 (大约14113个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Java知识学习笔记</h1><div class="content"><h4 id="1、常见设计模式有哪些？"><a href="#1、常见设计模式有哪些？" class="headerlink" title="1、常见设计模式有哪些？"></a>1、常见设计模式有哪些？</h4><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
<p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
<p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
<a id="more"></a>
<h4 id="2、设计模式七大原则"><a href="#2、设计模式七大原则" class="headerlink" title="2、设计模式七大原则"></a>2、设计模式七大原则</h4><p>1.开闭原则 （Open Close Principle）</p>
<ul>
<li>对扩展开放，对更改关闭</li>
</ul>
<p>-保证以前代码的准确性，使开发者更专注于新扩展的代码上</p>
<p>2.单一职责原则 （Single Responsibility Principle）</p>
<ul>
<li>一个类只负责一个功能领域的职责</li>
</ul>
<p>-降低类的复杂度，当修改一个功能时，降低对其他功能的影响，提供类的可读性</p>
<p>3.里氏替换原则 （Liskov Substitution Principle）</p>
<p>-任何基类出现的地方，子类一定可以出现</p>
<p>-在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象，开闭原则实现的手段之一</p>
<p>4.依赖倒转原则 （Dependence Inversion Principle）</p>
<p>-针对接口编程，抽象不依赖于细节，细节应依赖于抽象</p>
<p>-多数情况下，开闭原则，里氏替换原则，依赖倒转原则会同时出现，开闭原则是目标，里氏替换原则是基础，依赖倒转是手段。</p>
<p>5.接口隔离原则 （Interface Segregation Principle）</p>
<p>-使用多个专门的接口，不使用单一的总接口</p>
<p>-当一个接口太大时，我们需要把他拆分成更小的接口，但不能违反单一职责原则，每个接口应该承担一种相对独立的角色，不该干的事情不干，该干的事情都要干。</p>
<p>6.迪米特法则 （Law Of Demeter）</p>
<p>-一个实体应当尽量少的与其他实体发生相互作用</p>
<ul>
<li>应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。</li>
</ul>
<p>7.合成复用原则（Composite Reuse Principle）</p>
<p>-尽量使用组合而非继承</p>
<p>-就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，新的对象通过这些对象的委派达到复用已有功能的目的</p>
<h4 id="3、举例实现其中几种设计模式（单例模式）："><a href="#3、举例实现其中几种设计模式（单例模式）：" class="headerlink" title="3、举例实现其中几种设计模式（单例模式）："></a>3、举例实现其中几种设计模式（单例模式）：</h4><p><strong>单例模式：懒汉式（双重校验模式）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 必须使用volatile修饰，保证线程间可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 必须私有化构造方法，保证实例唯一性</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>问题1：说说两次判空的意义是什么？</em></strong><br>第一次判空：假设没有第一次不判空校验，那么每个线程每次获取实例时都会执行一次同步代码块拿到锁对象才能执行下去，如果锁对象被其他线程持有时就需要等待锁被释放才能使用，降低了程序的效率。而有了第一次判空，只需要首次初始化的时候才会执行同步代码块，大大提高了程序的执行效率。</p>
<p>第二次判空：假设没有第二次判空验校，线程A执行到第一次判空验校那里，它判断到instance== null。此时它的资源被线程B抢占了，B执行程序，进入同步代码块创建对象，然后释放同步锁，此时线程A又拿到了资源也拿到了同步锁，然后执行同步代码块，因为之前线程A它判断到instance==null，因此它会直接创建新的对象。所以就违反了我们设计的最终目的。</p>
<p><strong><em>问题2：说说为什么加volatile关键字？</em></strong></p>
<p>volatile关键字的特性：可见性，有序性（禁止指令重排），不具备原子性</p>
<p><strong><em>问题3：volatile如何保证可见性</em></strong></p>
<p>在x86处理器下通过工具获取JIT编译器生成的汇编指令来看看对Volatile进行写操作CPU会做什么事情。</p>
<p>|Java代码：|instance = new Singleton();//instance是volatile变量|<br>|:—-|:—-|:—-|<br>|汇编代码：|0x01a3de1d: movb $0x0,0x1104800(%esi);<br>0x01a3de24: lock  addl $0x0,(%esp);|</p>
<p>有volatile变量修饰的共享变量进行写操作的时候会多第二行汇编代码，通过查IA-32架构软件开发者手册可知，lock前缀的指令在多核处理器下会引发了两件事情。</p>
<p>将当前处理器缓存行的数据会写回到系统内存。</p>
<p>这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。</p>
<p>处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（L1,L2或其他）后再进行操作，但操作完之后不知道何时会写到内存，如果对声明了Volatile变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址的数据被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</p>
<p><img src="https://uploader.shimo.im/f/m9xECnZqKgzsfYvC.png!thumbnail?fileGuid=DjpqxkRGwrxjGwtc" alt="图片"></p>
<p>回答：系统内存中的insatance共享变量,当多个线程并发访问这个对象时,如上图cpu1通过threadA访问instance,cpu2通过threadB访问instance,处理器为了提高处理速度,不直接和内存进行通讯,而是先将系统内存的数据读到cache再进行操作,如果变量instance被volatile关键字修饰,cpu1修改cache中的instance数据会立马通过系统总线写到系统内存,其他处理器通过嗅探总线上传播的数据来检查自己缓存的值是不是过期了,当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</p>
<p><strong><em>问题4：说说volatile禁止指令重排的作用</em></strong></p>
<p>首先了解一个概念：内存屏障，它是一个CPU指令，作用如下：</p>
<p>1、保证特定操作的执行顺序；</p>
<p>2、保证某些变量的内存可见（利用此特性实现volatile的内存可见性）。</p>
<p>由于编译器和处理器都能执行指令重排优化，如果在指令间插入一条Memory Barrier（内存屏障）指令，则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。内存屏障另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。</p>
<p>instance = new Singleton()；// 实例化一个对象的指令执行过程</p>
<p>1、为对象分配内存空间</p>
<p>2、初始化对象</p>
<p>3、将引用指向对象的内存空间地址</p>
<p>但是虚拟机执行的时候不一定是按123的顺序执行的。</p>
<p>假设没有volatile关键字修饰，线程A执行 instance = new Singleton()；虚拟机是按132排序执行，当执行到3的时候single 引用已经不为空。此时若线程B执行到第一次验校处(第一次验校不在同步代码中，因此所有线程随时都可以访问)，它判断 instance == null 得到false,直接返回instance 对象。但是此时instance 对象还没初始化完成，因此很有可能就会发生bug。</p>
<p><strong>抽象工厂模式：制造手机的工厂</strong></p>
<p>首先创建一个手机的公共接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">showPhone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再分别实现Android和iOS系统手机的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidPhone</span> <span class="keyword">implements</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AndroidPhone&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IosPhone</span> <span class="keyword">implements</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IosPhone&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后创建一个公共手机工厂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Phone <span class="title">createPhone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再分别实现两种手机的工厂实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidPhoneFactory</span> <span class="keyword">implements</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AndroidPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IosPhoneFactory</span> <span class="keyword">implements</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IosPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> AndroidPhoneFactory().createPhone().showPhone();</span><br><span class="line"><span class="keyword">new</span> IosPhoneFactory().createPhone().showPhone();</span><br></pre></td></tr></table></figure>
<p><strong>构建者模式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String model;<span class="comment">// 型号</span></span><br><span class="line">    <span class="keyword">private</span> String system;<span class="comment">// 系统</span></span><br><span class="line">    <span class="keyword">private</span> String screen;<span class="comment">// 屏幕</span></span><br><span class="line">    <span class="keyword">private</span> String camera;<span class="comment">// 摄像头</span></span><br><span class="line">    <span class="comment">// 必须使用私有化无参构造方法，防止外部创建实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Phone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String model;<span class="comment">// 型号</span></span><br><span class="line">        <span class="keyword">private</span> String system;<span class="comment">// 系统</span></span><br><span class="line">        <span class="keyword">private</span> String screen;<span class="comment">// 屏幕</span></span><br><span class="line">        <span class="keyword">private</span> String camera;<span class="comment">// 摄像头</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setModel</span><span class="params">(String model)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.model = model;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setSystem</span><span class="params">(String system)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.system = system;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setScreen</span><span class="params">(String screen)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.screen = screen;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setCamera</span><span class="params">(String camera)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.camera = camera;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Phone <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">            phone.model = model;</span><br><span class="line">            phone.system = system;</span><br><span class="line">            phone.screen = screen;</span><br><span class="line">            phone.camera = camera;</span><br><span class="line">            <span class="keyword">return</span> phone;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Phone android = <span class="keyword">new</span> Phone.Builder()</span><br><span class="line">        .setModel(<span class="string">&quot;android10&quot;</span>)</span><br><span class="line">        .setScreen(<span class="string">&quot;三星&quot;</span>)</span><br><span class="line">        .setCamera(<span class="string">&quot;徕卡&quot;</span>)</span><br><span class="line">        .setSystem(<span class="string">&quot;Android&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">Phone ios = <span class="keyword">new</span> Phone.Builder()</span><br><span class="line">        .setModel(<span class="string">&quot;ios10&quot;</span>)</span><br><span class="line">        .setScreen(<span class="string">&quot;三星&quot;</span>)</span><br><span class="line">        .setCamera(<span class="string">&quot;苹果&quot;</span>)</span><br><span class="line">        .setSystem(<span class="string">&quot;ios&quot;</span>)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>
<p>Builder设计模式的好处是我们可以随意组合类相同类型输入的参数，不仅避免了方法重载出错的问题，还不需要写过多的构造器。</p>
<p><strong>观察者模式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="comment">// 被观察</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String model;<span class="comment">// 型号</span></span><br><span class="line">    <span class="keyword">private</span> String system;<span class="comment">// 系统</span></span><br><span class="line">    <span class="keyword">private</span> String screen;<span class="comment">// 屏幕</span></span><br><span class="line">    <span class="keyword">private</span> String camera;<span class="comment">// 摄像头</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setModel</span><span class="params">(String model)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.model = model;</span><br><span class="line">        <span class="comment">// 通知观察者参数发生改变</span></span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSystem</span><span class="params">(String system)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.system = system;</span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCamera</span><span class="params">(String camera)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.camera = camera;</span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScreen</span><span class="params">(String screen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.screen = screen;</span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSystem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> system;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getScreen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> screen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> camera;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"><span class="comment">// 设计师，观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Designer</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable observable, Object o)</span> </span>&#123;</span><br><span class="line">        Phone phone = (Phone) o;</span><br><span class="line">        String camera = phone.getCamera();</span><br><span class="line">        System.out.println(camera);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"><span class="comment">// 生产者，观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable observable, Object o)</span> </span>&#123;</span><br><span class="line">        Phone phone = (Phone) o;</span><br><span class="line">        String camera = phone.getCamera();</span><br><span class="line">        System.out.println(camera);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被观察者</span></span><br><span class="line">Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line"><span class="comment">// 观察者</span></span><br><span class="line">Designer designer = <span class="keyword">new</span> Designer();</span><br><span class="line">Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line"><span class="comment">// 添加观察者</span></span><br><span class="line">phone.addObserver(designer);</span><br><span class="line">phone.addObserver(producer);</span><br><span class="line"><span class="comment">// 发生改变</span></span><br><span class="line">phone.setCamera(<span class="string">&quot;三星&quot;</span>);</span><br><span class="line"><span class="comment">// 删除观察者</span></span><br><span class="line">phone.deleteObserver(designer);</span><br></pre></td></tr></table></figure>
<h4 id="4、JVM内存相关"><a href="#4、JVM内存相关" class="headerlink" title="4、JVM内存相关"></a>4、JVM内存相关</h4><p><strong>jvm运行时数据区划分</strong></p>
<p>方法区：class会被加载到方法区，当JVM使用类加载器定位class文件，并将其载入到内存中，会提取class文件的类型信息，并将这些信息存储到方法区中，同时，放入方法区中的还有该类型中的类静态变量。【类型信息，方法信息，方法表，静态变量】</p>
<p>堆区：Java程序在运行时创建的所有类型对象和数组都存储在堆中/JVM会根据new指令在堆中开辟一个确定类型的对象内存空间。但是堆中开辟对象的空间并没有任何人工指令可以回收，而是通过JVM的垃圾回收器负责回收。</p>
<p>栈区：方法的执行是在虚拟机，Java方法执行存储在栈区，每个Java方法对应一个栈帧。每启动一个线程，JVM都会为它分配一个Java栈，用于存放方法中的局部变量，操作数以及异常数据等。当线程调用某个方法时，JVM会根据方法区中该方法的字节码组建一个栈帧，并将该栈帧压入Java栈中，方法执行完毕时，JVM会弹出该方法栈并释放掉。</p>
<p>本地方法栈(Native 堆)：本地方法栈的功能和特点类似于虚拟机栈，不同的是，本地方法栈服务的对象是JVM执行的native方法，而虚拟机栈服务的是JVM执行的java方法。</p>
<p>程序计数器(PC寄存器)：程序计数器是一个记录着当前线程所执行的字节码的行号指示器。 JAVA代码编译后的字节码在未经过JIT（实时编译器）编译前，其执行方式是通过“字节码解释器”进行解释执行。简单的工作原理为解释器读取装载入内存的字节码，按照顺序读取字节码指令。读取一个指令后，将该指令“翻译”成固定的操作，并根据这些操作进行分支、循环、跳转等流程。</p>
<p><strong>GC 标记算法</strong></p>
<p>引用计数法:每一个对象都有一个引用计数器,当有任何一个对象引用了它,那么引用计数器count+1,当这个引用失效,引用计数器count-1,当一个对象的引用计数器count==0时,说明这个对象不再被使用了,也就标记为垃圾对象了.但是此算法无法消除循环引用的垃圾对象</p>
<p>可达性分析:检索GC Root的引用链,如果一个对象不再任何GC Root的引用链上,说明此对象不再使用,可标记为垃圾对象.</p>
<p><strong>问题1:哪些对象可做为GC Root呢?</strong></p>
<p>1)Java虚拟机栈中引用的对象;</p>
<p>2)方法区中类静态成员引用的对象(static修饰的成员变量);</p>
<p>3)方法区中常量引用的对象(主要是final修饰的变量);</p>
<p>4)本地方法栈中JNI引用的对象.</p>
<p><strong>GC 回收算法</strong></p>
<p>1)标记-清除算法:分两步,先标记后清除.首先遍历所有的根结点,将这些根结点的可达性对象标记为存活对象,不可达对象标记为垃圾对象,然后遍历堆中所有对象,清除垃圾对象,释放内存.此算法缺点:内存容易产生碎片化,利用率不够,而且算法执行效率也不高.</p>
<p>2)标记-复制算法:将内存空间一分为二,当一半空间快要用完时,将还存活的对象复制到另一半空间去,然后清除使用过的这一半内存空间.</p>
<p>缺点:只能利用一半的内存空间,利用率不高,但是解决了内存碎片化的问题</p>
<p>3)标记-压缩算法:需要将存活的对象先转移到内存区域的一端,然后清除区域外的内存.这样能有效的利用内存空间,但是压缩过程比较耗时.</p>
<p><strong>GC 分代收集算法</strong></p>
<p>首先根据对象存活的时间将JVM堆内存空间区分为新生代,老年代和永久代(JDK8后变为元空间)</p>
<p><strong>新生代**</strong>（Young generation）****:**存放一些生命周期较短的对象,会频繁发现大量垃圾,采用”标记-复制”算法.</p>
<p>在新生代中又分为Eden区、SurvivorFrom区、SurvivorTo区,默认比例8:1:1</p>
<p>回收原理：</p>
<p>绝大多数刚刚被创建的对象会存放在Eden区。</p>
<p>在Eden区执行第一次GC（Minor GC）之后，存活的对象被移动到其中一个Survivor空间（如S1，S1为From区域），Eden区会被清空。</p>
<p>再次Eden区执行GC后（Minor GC 是对整个新生代检查，不仅仅是Eden区），如果幸存者空间S1的对象依旧还存活，那么这些存活的对象年龄增加。然后所有还存活的对象会被移动到另一个Survivor空间（如S2，S2是下次Minor GC的From区域）中，Eden空间和Survivor空间S1会被清空。</p>
<p>以上步骤执行N（N = MaxTenuringThreshold（年龄阀值设定，默认15））次之后，依然存活的对象，就会被移动到老年代。</p>
<p>一般来说，新生代对象要经历N次MinorGC之后才会被移动到老年代。<strong>不过也有例外，对于一些比较大的**</strong>对象**<strong>（需要**</strong>分配**<strong>一块比较大的连续内存**</strong>空间**<strong>）**</strong>，**<strong>则直接进**</strong>入**<strong>到**</strong>老年代。**<strong>一般在**</strong>Survivor**<strong>空间不足的情况下发生。</strong></p>
<p><strong>老年代（Old******</strong>gene**<strong>r**</strong>at**<strong>io**</strong>n）**</p>
<p>老年代只有一个区域，但是这块区域很大，默认大小是新生代的2倍，正因如此，发生在老年代的GC（发生在老年代的GC叫Full GC）次数要比新生代少得多，而且做一次Full GC 的时间比Minor GC 要更长（约10倍）。采用”标记-压缩”和”标记-清除”算法.</p>
<p><strong>持久代（Perm**</strong>a**<strong>n**</strong>en**<strong>t gene**</strong>r**<strong>at**</strong>i**<strong>o**</strong>n**<strong>）</strong></p>
<p>也称之为 方法区（Methodarea）：用于保存类常量以及字符串常量。注意，这个区域不是用于存储那些从老年代存活下来的对象，这个区域也可能发生GC。发生在这个区域的GC事件也被算为 Full GC。</p>
<h4 id="5、类加载相关"><a href="#5、类加载相关" class="headerlink" title="5、类加载相关"></a>5、类加载相关</h4><p><strong>1)类加载流程:</strong></p>
<p>加载:根据路径找到相应的class文件然后导入</p>
<p>验证:检查加载的class文件的正确性</p>
<p>准备:给类中的静态变量分配内存空间,并赋予默认值</p>
<p>解析:虚拟机将常量池中的符号引用替换成直接引用的过程,也就是直接指向内存地址;</p>
<p>初始化:对静态变量和静态代码块执行初始化工作.</p>
<p><strong>2)抽象类和接口区别</strong></p>
<p>接口中所有的方法都是抽象方法,而抽象类中可以同时包含抽象方法和非抽象方法</p>
<p>一个类可以实现多个接口,但是只能继承一个抽象类</p>
<p>接口中声明的变量默认都是final的,抽象类中可以包含非final的变量</p>
<p>接口中的方法默认都是public的,抽象类中可以是private,protected和public的</p>
<p>接口和抽象类都不能被实例化</p>
<p>JDK1.8中对接口增加了新的特性：</p>
<p>（1）、默认方法（default method）：JDK 1.8允许给接口添加非抽象的方法实现，但必须使用default关键字修饰；定义了default的方法可以不被实现子类所实现，但只能被实现子类的对象调用；如果子类实现了多个接口，并且这些接口包含一样的默认方法，则子类必须重写默认方法；</p>
<p>（2）、静态方法（static method）：JDK 1.8中允许使用static关键字修饰一个方法，并提供实现，称为接口静态方法。接口静态方法只能通过接口调用（接口名.静态方法名）。</p>
<p><strong>3)泛型理解</strong></p>
<p>泛型:本质是参数化类型</p>
<p>使用:泛型类,泛型接口,泛型方法</p>
<p>特性:只在编译期有效,对编译器可见,jvm不可见.通过泛型擦除机制将泛型处理成普通类\方法\接口</p>
<p>作用:避免了类型转化的消耗,提供了编译期的类型安全保障,兼容了Java1.5之前的版本</p>
<p>泛型擦除规则:</p>
<ul>
<li>如果没指定具体类型<T>或&lt;?&gt;,用Object作为原始类型</li>
<li>如果有上限类型<T extends ParentClass> ,使用 ParentClass作为原始类型,表示参数化的类型可能是所指类型或是此类型的子类</li>
<li>如果有下限<T super ChildClass>,使用Object类型作为原始类型,表示参数化的类型可能是所指定的类型或此类型的父类</li>
</ul>
<p>回答点：泛型类、泛型接口、泛型方法、泛型通配符、泛型擦除</p>
<p>实现机制：泛型本质是将数据类型参数化，它通过擦除的方式来实现。声明了泛型的 .java 源代码，在编译生成 .class 文件之后，泛型相关的信息就消失了。可以认为，源代码中泛型相关的信息，就是提供给编译器用的。泛型信息对 Java 编译器可以见，对 Java 虚拟机不可见。</p>
<p>Java 编译器通过如下方式实现擦除：</p>
<p>·用 Object 或者界定类型替代泛型，产生的字节码中只包含了原始的类，接口和方法；</p>
<p>·在恰当的位置插入强制转换代码来确保类型安全；</p>
<p>·在继承了泛型类或接口的类中插入桥接方法来保留多态性</p>
<p>泛型擦除优点：运行时内存负担小、兼容旧版本、</p>
<p>泛型缺点：基本类型无法作为泛型实参泛型类型无法用作方法重载</p>
<p><strong>Java方法分派</strong></p>
<p>重载：同一个类中方法名相同，参数列表不同，返回类型可相同可不同</p>
<p>重写：子类继承父类的方法，参数列表和返回值类型都必须相同</p>
<p>总结：静态分派—方法重载分派</p>
<p>编译期确定</p>
<p>依据调用者的声明类型和方法参数类型</p>
<p>动态分派—方法重写分派</p>
<p>运行时确定</p>
<p>依据调用者的实际类型分派</p>
<p><strong>匿名内部类理解:</strong></p>
<p>对匿名内部类的构造方法的总结：</p>
<p>A、编译器帮助生成构造方法</p>
<p>B、参数列表包括</p>
<p>l外部对象（定义在非静态域内）</p>
<p>l父类的外部对象（父类非静态）</p>
<p>l父类的构造方法参数（父类有构造方法且参数列表不为空）</p>
<p>l外部捕获的变量（方法体内有引用外部final变量）</p>
<p><strong><em>Java中的自动装箱和拆箱</em></strong></p>
<p>当我们变量声明为对象类型而赋值为基本数据类型时，Java编译器会对我们的基本数据类型进行装箱，而我们的变量声明为基本类型赋值为对象类型时，编译器又会对我们的对象类型进行拆箱处理。valueOf作为装箱方法，基本数据类型加上Value做为拆箱方法如intValue，longValue，booleanValue。</p>
<p><strong><em>为什么要使用包装类？</em></strong></p>
<p>1）对象是对现实世界的模拟，基本类型都有默认值，对象的默认值为null，而且是在堆中开辟空间</p>
<p>2）为泛型提供了支持</p>
<p>3）包装类提供了丰富的属性和API</p>
<h4 id="6、多线程，线程池、锁"><a href="#6、多线程，线程池、锁" class="headerlink" title="6、多线程，线程池、锁"></a>6、多线程，线程池、锁</h4><p><strong>线程的几种状态以及工作流程:</strong></p>
<p>状态:New(新建状态)\Runnable(就绪状态)\Running(运行状态)\Blocked(阻塞状态)\Dead(死亡状态)</p>
<p>New:Thread被创建,还未调用start方法,线程处于新建状态</p>
<p>Runnable:调用start方法后进入就绪状态,等待CPU资源,将Running状态的线程调用yield方法让出CPU资源后处于就绪状态,等待获取CPU资源,调用wait方法处于Blocked状态的线程调用notify/notiyAll唤醒后也处于就绪状态.</p>
<p>Running:运行状态,线程获取到CPU资源执run方法</p>
<p>Blocked:线程未执行完毕,由于I/O操作或调用wait,sleep方法,让出CPU资源,处于阻塞状态</p>
<p>Dead:死亡状态,线程正常执行完毕后自动停止或执行过程中发生异常,处于死亡状态</p>
<p><strong>sleep和wait区别</strong></p>
<p>sleep是Thread的静态方法,wait是Object中的方法</p>
<p>调用sleep后,线程暂停指定的一段时间后去接着执行,期间不会释放锁对象</p>
<p>调用wait后,线程处于阻塞状态,需要调用notify/notifyAll方法后从等待池进入锁池中去竞争锁,才能重新获取CPU执行时间</p>
<p>wait,notify,notifyAll必须是在synchronized函数或代码块中进行调用,并且必须持有相同的锁对象,不然会发生异常.</p>
<p><strong>yield方法:</strong></p>
<p>使当前线程重新回到可执行状态,所以执行yield的线程有可能进入可执行状态后立马被执行</p>
<p>但仅能是同优先级或高优先级的线程有执行机会</p>
<p><strong>join方法:</strong></p>
<p>等待该线程执行完毕</p>
<p><strong>notify/notifyAll区别</strong></p>
<p>notify:会将该锁对象中等待队列中的一个线程加入到锁池中去竞争锁</p>
<p>notifyAll:会将锁对象中等队列中的所有线程加入到锁池中去竞争锁,按线程优先级执行</p>
<p><strong><em>问题1:如何停止一个线程?</em></strong></p>
<p>Stop方法为什么被废弃了？因为线程会持有内存锁对象，线程暂停不释放锁对象可能会导致死锁，如果线程立即停止并释放锁可能会导致内存读写异常。</p>
<p>正确的处理方案：应该是停止任务执行，让线程自动停止</p>
<p>方式一：interrupt</p>
<p>方式二：boolean 标记位 要保证线程间可见性，加volatile关键字修饰</p>
<p>interrupted() 与 isInterrupted()区别</p>
<p>interrupted() 是静态方法，获取当前线程的中断状态，并清空状态，后续调用返回false；</p>
<p>isInterrupted() 是非静态方法，获取当前线程的中断状态，不清空状态，可重复调用，中断清空前一直返回true；</p>
<p><strong><em>问题2:如何写出线程安全的程序?</em></strong></p>
<p>什么是线程安全？多线程执行时，可变资源（内存）线程间共享</p>
<p>如何保证线程安全？不共享资源、共享不可变资源、保证共享资源的可见性、原子性、禁止指令重排优化</p>
<p>1）不共享资源：ThreadLocal，每个线程访问的都是线程自己内部的副本</p>
<p>原理：底层实际是用ThreadLocalMap 和 thread绑定了的，key就是ThreadLocal，value就是你想要传入的值；ThreadLocalMap 对象持有弱引用，线程退出后引用被移除，Hash冲突使用的是开放定址法，Hash计算使用的是神奇数字的倍数，适合对象较少的使用场景。ThreadLoacat使用建议：声明为全局静态final成员、避免存储大量对象、用完后及时移除对象。</p>
<p>2）共享不可变资源</p>
<p>final 关键字修饰成员变量除了初始化后不能修改，还有能禁止指令重排序的作用</p>
<p>3）禁止重排序 volatile，理解原理</p>
<p>4）保证可见性：使用final和volatile关键字，还有加锁的方式，锁释放时会强制将缓存刷新到主内存，并使引用该实例的。</p>
<p>5）保证原子性：a++为什么不是原子性操作，因为中间会生成临时变量；</p>
<p>保证原子性的方法：加锁，保证操作的互斥性；使用CAS指令（如Unsafe.compareAndSwapInt）；使用原子数值类型（如AtomicInteger）；使用原子属性更新器（AtomicReferenceFieldUpdater）</p>
<p><strong><em>问题3:ThreadLocal原理是什么?如何与线程绑定</em></strong></p>
<p><img src="https://uploader.shimo.im/f/dI1dTnVmUL9VFiAu.png!thumbnail?fileGuid=DjpqxkRGwrxjGwtc" alt="图片"></p>
<p>1.每个Thread线程内部都有一个ThreadLocalMap。</p>
<p>2.Map里面存储线程本地对象ThreadLocal（key）和线程的变量副本（value）。3.Thread内部的Map是由ThreadLocal维护，ThreadLocal负责向map获取和设置线程的变量值。</p>
<p>4.一个Thread可以有多个ThreadLocal。</p>
<p><strong><em>问题4:synchronized原理</em></strong></p>
<p>属于独占式的悲观锁,同时也属于可重入锁</p>
<p>Java中的每个对象都有个monitor对象,加锁就是在竞争monitor对象,对代码块加锁是通过在前后分别加上monitorenter和monitorexit指令实现的,对方法是否加锁是通过一个标记位来判断</p>
<p>synchronized的作用范围:</p>
<ul>
<li>synchronized作用于成员变量和非静态方法时，锁住的是对象的实例，即this对象。</li>
<li>synchronized作用于静态方法时，锁住的是Class实例，因为静态方法属于Class而不属于对象。</li>
<li>synchronized作用于一个代码块时，锁住的是所有代码块中配置的对象。</li>
</ul>
<p><strong><em>问题5:volatile原理,如何保证可见性?</em></strong></p>
<p>在x86处理器下通过工具获取JIT编译器生成的汇编指令来看看对Volatile进行写操作CPU会做什么事情。</p>
<p>|Java代码：|instance   = new Singleton();//instance是volatile变量|<br>|:—-|:—-|:—-|<br>|汇编代码：|0x01a3de1d:   movb $0x0,0x1104800(%esi);<br>0x01a3de24: lock addl   $0x0,(%esp);|</p>
<p>有volatile变量修饰的共享变量进行写操作的时候会多第二行汇编代码，通过查IA-32架构软件开发者手册可知，lock前缀的指令在多核处理器下会引发了两件事情。</p>
<ul>
<li>将当前处理器缓存行的数据会写回到系统内存。</li>
<li>这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。</li>
</ul>
<p>处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（L1,L2或其他）后再进行操作，但操作完之后不知道何时会写到内存，如果对声明了Volatile变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</p>
<p><strong><em>问题6:创建线程的几种方法</em></strong></p>
<p>继承Thread类,实现Runnable接口重写run方法,实现有回调的callback接口,采用线程池管理线程的方式</p>
<p><strong><em>线程池原理</em></strong></p>
<p>ThreadPoolExecutor创建基本线程池,构造方法的参数</p>
<p>corePoolSize:核心线程数</p>
<p>maximumPoolSize:最大线程数</p>
<p>keepAliveTime:非核心线程空闲等待时间</p>
<p>unit:keepAliveTime参数单位</p>
<p>workQueue:任务队列 LinkedBlockQueue 阻塞队列(基于单链表实现)</p>
<p>threadFactory:线程工厂,设置线程名称</p>
<p>工作流程:</p>
<p>1.execute一个线程之后，如果线程池中的线程数未达到核心线程数，则会立马启用一个核心线程去执行。</p>
<p>2.execute一个线程之后，如果线程池中的线程数已经达到核心线程数，且workQueue未满，则将新线程放入workQueue中等待执行。</p>
<p>3.execute一个线程之后，如果线程池中的线程数已经达到核心线程数但未超过非核心线程数，且workQueue已满，则开启一个非核心线程来执行任务。</p>
<p>4.execute一个线程之后，如果线程池中的线程数已经超过非核心线程数，则拒绝执行该任务，采取饱和策略，并抛出RejectedExecutionException异常。</p>
<p><strong><em>几种常用线程池</em></strong></p>
<p>FixedThreadPool:可重用固定线程,只有核心线程,无非核心线程,并且阻塞队列无界</p>
<p>CacheThreadPool:缓存线程池,无核心线程,只有非核心线程,空闲等待时间60s,采用SynchronousQueue同步队列</p>
<p>SingleThreadPool:单个线程的线程池</p>
<p>ScheduledThreadPool:定时延时执行线程池</p>
<p>自定义线程池(PriorityThreadPool):按优先级执行任务的线程池,自定义实现Runnable和Comparable接口</p>
<p><strong><em>Java中的锁:</em></strong></p>
<p>**乐观锁:**每次都数据都认为别人不会修改数据,所以不上锁,但是更新数据时会判断在此期间别人有没有更新该数据.乐观锁大部分是通过CAS操作实现的,CAS是一种原子更新操作，在对数据操作之前首先会比较当前值跟传入的值是否一样，如果一样则更新，否则不执行更新操作，直接返回失败状态。</p>
<p>**悲观锁:**在每次读取数据时都认为别人会修改数据，所以每次在读写数据时都会上锁，这样别人想读写这个数据时就会阻塞、等待直到拿到锁。Java中的悲观锁大部分基于AQS（AbstractQueued Synchronized，抽象的队列同步器）架构实现。该框架下的锁会先尝试以CAS乐观锁去获取锁，如果获取不到，则会转为悲观锁（如RetreenLock）。</p>
<p>**自旋锁:**如果持有锁的线程能在很短的时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞、挂起状态，只需等一等（也叫作自旋），在等待持有锁的线程释放锁后即可立即获取锁，这样就避免了用户线程在内核状态的切换上导致的锁时间消耗。减少CPU上下文的切换,但若自旋时间过长将引起CPU的浪费,适合占用锁的时间短或锁竞争不激烈的代码块来说性能大幅度提升.</p>
<p><strong><em>synchronized和ReentrantLock的比较</em></strong></p>
<p>synchronized和ReentrantLock的共同点如下。</p>
<p>◎ 都用于控制多线程对共享对象的访问。</p>
<p>◎ 都是可重入锁。</p>
<p>◎ 都保证了可见性和互斥性。</p>
<p>synchronized和ReentrantLock的不同点如下。</p>
<p>◎ ReentrantLock显式获取和释放锁；synchronized隐式获取和释放锁。为了避免程序出现异常而无法正常释放锁，在使用ReentrantLock时必须在finally控制块中进行解锁操作。</p>
<p>◎ ReentrantLock可响应中断、可轮回，为处理锁提供了更多的灵活性。</p>
<p>◎ ReentrantLock是API级别的，synchronized是JVM级别的。</p>
<p>◎ ReentrantLock可以定义公平锁。</p>
<p>◎ ReentrantLock通过Condition可以绑定多个条件。</p>
<p>◎ 二者的底层实现不一样：synchronized是同步阻塞，采用的是悲观并发策略；Lock是同步非阻塞，采用的是乐观并发策略。</p>
<p>◎ Lock是一个接口，而synchronized是Java中的关键字，synchronized是由内置的语言实现的。</p>
<p>◎ 我们通过Lock可以知道有没有成功获取锁，通过synchronized却无法做到。</p>
<p>◎ Lock可以通过分别定义读写锁提高多个线程读操作的效率。</p>
<p><strong><em>AtomicInteger</em></strong></p>
<p>在多线程程序中，诸如++i或i++等运算不具有原子性，因此不是安全的线程操作。我们可以通过synchronized或ReentrantLock将该操作变成一个原子操作，但是synchronized和ReentrantLock均属于重量级锁。因此JVM为此类原子操作提供了一些原子操作同步类，使得同步操作（线程安全操作）更加方便、高效，它便是AtomicInteger。如果是引用类对象就使用AtomicReference和AtomicReferenceFieldUpdate.</p>
<p><strong><em>多线程死锁的产生条件</em></strong></p>
<p>互斥条件:一个资源每次只能被一个线程占有</p>
<p>不剥夺条件:线程以及获得的资源,在未使用完之前不能强行剥夺</p>
<p>请求和保持条件:线程已经占有了至少一个资源,但又提出新的资源请求,而该资源已被其他线程占有,此时请求线程被阻塞,但对自己以获得的资源保持不放</p>
<p>循环等待条件:若干线程之间形成一种首尾相连的循环等待资源关系</p>
<p><strong><em>如何避免死锁?</em></strong></p>
<p>指定获取锁的顺序,规定只有获得 A 锁的线程才有资格获取 B 锁，按顺序获取锁就可以避免死锁。</p>
<p><strong><em>问题：线程A、B、C依次打印A、B、C，循环10次</em></strong></p>
<p>方法一：使用Thread的join方法，强制执行一个线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">    Thread threadA &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;A&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread threadB &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;B&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread threadC &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;C&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    try &#123;</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadA.join();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadB.join();</span><br><span class="line">        threadC.start();</span><br><span class="line">        threadC.join();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：使用单线程线程池依次执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService &#x3D; Executors.newSingleThreadExecutor();</span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">    executorService.submit(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;A&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.submit(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;B&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.submit(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;C&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>
<p><strong><em>问题2：使用AtomicInteger实现一个Lock锁</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.LockSupport;</span><br><span class="line">public class IConcurrentLock implements Lock &#123;</span><br><span class="line">private AtomicInteger atomicInteger &#x3D; new AtomicInteger(0);</span><br><span class="line">private ConcurrentLinkedQueue&lt;Thread&gt; concurrentLinkedQueue &#x3D; new ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">@Override</span><br><span class="line">public void lock() &#123;</span><br><span class="line">if (atomicInteger.compareAndSet(0, 1)) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 首先将当前线程添加至等待队列</span><br><span class="line">concurrentLinkedQueue.add(Thread.currentThread());</span><br><span class="line">&#x2F;&#x2F; 自旋，等死</span><br><span class="line">while (true) &#123;</span><br><span class="line">if (0 &#x3D;&#x3D; atomicInteger.get()) &#123;</span><br><span class="line">&#x2F;&#x2F; 期望是0，如果是0则返回true，否则加1并返回false</span><br><span class="line">if (atomicInteger.compareAndSet(0, 1)) &#123;</span><br><span class="line">concurrentLinkedQueue.remove(Thread.currentThread());</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; 挂起当前线程</span><br><span class="line">LockSupport.park();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void unlock() &#123;</span><br><span class="line">atomicInteger.set(0);</span><br><span class="line">&#x2F;&#x2F; 唤醒等待队列中的第一个线程</span><br><span class="line">Thread waiterHead &#x3D; concurrentLinkedQueue.peek();</span><br><span class="line">if (null !&#x3D; waiterHead) &#123;</span><br><span class="line">&#x2F;&#x2F; 唤醒线程</span><br><span class="line">LockSupport.unpark(waiterHead);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public boolean tryLock() &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public Condition newCondition() &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>7、各类集合比较</strong><br><strong><em>List、Set和Map区别</em></strong></p>
<p>List、Set都继承Collection接口，Map为独立的一个接口</p>
<p>List：</p>
<ul>
<li>允许重复的对象</li>
<li>可插入多个null元素</li>
<li>是有序的容器</li>
<li>常用类型ArrayList、LinkedList和Vector</li>
</ul>
<p>Set:</p>
<ul>
<li>不允许重复对象</li>
<li>只允许插入一个null元素</li>
<li>无序容器</li>
<li>常用类型HashSet、LinkedHashSet和TreeSet</li>
</ul>
<p>Map：</p>
<ul>
<li>Map的每个Entry都持有一个key和value，key必须是唯一的</li>
<li>Map可存储多个null值，但最多只能有一个null键</li>
<li>常用类型HashMap、LinkedHashMap、HashTable和TreeMap</li>
</ul>
<p><strong><em>HashMap,ArrayMap,SparseMap比较</em></strong></p>
<p>HashMap:数组+链表+红黑树实现,查询\插入接近O(1) ,2倍的扩容,无缩容机制,有额外的Entry对象,适用于大量(1000)的增删频繁的操作</p>
<p>ArrayMap:两个数组,一个用来存放key,一个用来存放value,查询\插入O(logN),1.5倍扩容,0.5倍缩容,适合增删不频繁的操作</p>
<p>SparseMap:两个数组实现,key必须是整型,避免了装箱操作</p>
<p><strong><em>ArrayList与LinkedList比较</em></strong></p>
<p>ArrayList是动态数组的数据结构,LinkedList是链表的数据结构</p>
<p>ArrayList查询效率高,增删效率低</p>
<p>LinkedList查询慢,增删快</p>
<p><strong><em>HashMap,HashTable</em></strong></p>
<p>HashMap:线程不安全,数组+链表+红黑树,默认大小16,扩容:capacity<em>2,加载因子:0.75,临界值:16</em>0.75,大小都是2的N次幂;</p>
<p>Hash Table:方法添加了synchronized关键字,是线程安全的,数组+链表,默认大小11,扩容:capacity*2+1</p>
<p><strong>为什么HashMap大小都是2的N次幂?</strong></p>
<p>index = h &amp; (length - 1);</p>
<p>为了减少Hash碰撞,尽量使Hash算法的结果均匀分布</p>
<h4 id="8、HTTPS相关"><a href="#8、HTTPS相关" class="headerlink" title="8、HTTPS相关"></a><strong>8、HTTPS相关</strong></h4><p><strong><em>说一下一次完整的Http请求流程</em></strong></p>
<p>1)DNS域名解析:先在DNS缓存中查找-&gt;系统host文件中查找-&gt;DNS服务查找-&gt;IP地址</p>
<p>2)建立TCP/IP连接,客户端与服务端通过socket三次握手,成功建立连接</p>
<p>3)客户端向服务端发送http请求</p>
<p>4)客户端发送请求头信息,请求内容,最后会发送一行空白行,表示客户端请求完毕</p>
<p>5)服务端做出应答,表示对客户端请求的应答,例如:HTTP/1.1 200 OK</p>
<p>6)服务端向客户端发送应答头信息</p>
<p>7)服务端向客户端发送应答头消息后,也会发送一行空白行,表示应答头信息发送完毕,接着就以Content-type要求的数据格式发送数据给客户端</p>
<p>8)服务器关闭TCP/IP连接</p>
<p><strong><em>Https和http的主要区别</em></strong></p>
<p>1)https协议需要到CA申请证书</p>
<p>2)http是超文本传输协议,信息的明文传输,https则是具有安全性的ssl/tls加密传输协议</p>
<p>3)http和https使用的是完全不同的连接方式,用的端口也不一样,前者是80,后者是443.</p>
<p>4)http的连接很简单是无状态的,HTTPS协议是由SSL/TLS + HTTP协构建的可进行加密传输,身份认证的网络协议,比http协议安全</p>
<p><strong><em>TCP连接三次握手与四次挥手</em></strong></p>
<p><strong><em>三次握手：</em></strong></p>
<p>（1）首先客户端向服务器端发送一段TCP报文，其中：</p>
<ul>
<li>标记位为SYN，表示“请求建立新连接”;</li>
<li>序号为Seq=X（X一般为1）；</li>
<li>随后客户端进入SYN-SENT阶段。</li>
</ul>
<p>（2）服务器端接收到来自客户端的TCP报文之后，结束LISTEN阶段。并返回一段TCP报文，其中：</p>
<ul>
<li>标志位为SYN和ACK，表示“确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接”（即告诉客户端，服务器收到了你的数据）；</li>
<li>序号为Seq=y；</li>
<li>确认号为Ack=x+1，表示收到客户端的序号Seq并将其值加1作为自己确认号Ack的值；随后服务器端进入SYN-RCVD阶段。</li>
</ul>
<p>（3）客户端接收到来自服务器端的确认收到数据的TCP报文之后，明确了从客户端到服务器的数据传输是正常的，结束SYN-SENT阶段。并返回最后一段TCP报文。其中：</p>
<ul>
<li>标志位为ACK，表示“确认收到服务器端同意连接的信号”（即告诉服务器，我知道你收到我发的数据了）；</li>
<li>序号为Seq=x+1，表示收到服务器端的确认号Ack，并将其值作为自己的序号值；</li>
<li>确认号为Ack=y+1，表示收到服务器端序号Seq，并将其值加1作为自己的确认号Ack的值；</li>
<li>随后客户端进入ESTABLISHED阶段。</li>
</ul>
<p>服务器收到来自客户端的“确认收到服务器数据”的TCP报文之后，明确了从服务器到客户端的数据传输是正常的。结束SYN-SENT阶段，进入ESTABLISHED阶段。</p>
<p>在客户端与服务器端传输的TCP报文中，双方的确认号Ack和序号Seq的值，都是在彼此Ack和Seq值的基础上进行计算的，这样做保证了TCP报文传输的连贯性。一旦出现某一方发出的TCP报文丢失，便无法继续”握手”，以此确保了”三次握手”的顺利完成。此后客户端和服务器端进行正常的数据传输。这就是“三次握手”的过程。</p>
<p><strong><em>四次挥手：</em></strong></p>
<p>（1）首先客户端想要释放连接，向服务器端发送一段TCP报文，其中：</p>
<ul>
<li>标记位为FIN，表示“请求释放连接“；</li>
<li>序号为Seq=U；</li>
<li>随后客户端进入FIN-WAIT-1阶段，即半关闭阶段。并且停止在客户端到服务器端方向上发送数据，但是客户端仍然能接收从服务器端传输过来的数据。</li>
</ul>
<p>（2）服务器端接收到从客户端发出的TCP报文之后，确认了客户端想要释放连接，随后服务器端结束ESTABLISHED阶段，进入CLOSE-WAIT阶段（半关闭状态）并返回一段TCP报文，其中：</p>
<ul>
<li>标记位为ACK，表示“接收到客户端发送的释放连接的请求”；</li>
<li>序号为Seq=V；</li>
<li>确认号为Ack=U+1，表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值；</li>
<li>随后服务器端开始准备释放服务器端到客户端方向上的连接。</li>
</ul>
<p>客户端收到从服务器端发出的TCP报文之后，确认了服务器收到了客户端发出的释放连接请求，随后客户端结束FIN-WAIT-1阶段，进入FIN-WAIT-2阶段</p>
<p>前”两次挥手”既让服务器端知道了客户端想要释放连接，也让客户端知道了服务器端了解了自己想要释放连接的请求。于是，可以确认关闭客户端到服务器端方向上的连接了</p>
<p>（3）服务器端自从发出ACK确认报文之后，经过CLOSED-WAIT阶段，做好了释放服务器端到客户端方向上的连接准备，再次向客户端发出一段TCP报文，其中：</p>
<ul>
<li>标记位为FIN，ACK，表示“已经准备好释放连接了”。注意：这里的ACK并不是确认收到服务器端报文的确认报文。</li>
<li>序号为Seq=W；</li>
<li>确认号为Ack=U+1；表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值。</li>
</ul>
<p>随后服务器端结束CLOSE-WAIT阶段，进入LAST-ACK阶段。并且停止在服务器端到客户端的方向上发送数据，但是服务器端仍然能够接收从客户端传输过来的数据。</p>
<p>（4）客户端收到从服务器端发出的TCP报文，确认了服务器端已做好释放连接的准备，结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，并向服务器端发送一段报文，其中：</p>
<ul>
<li>标记位为ACK，表示“接收到服务器准备好释放连接的信号”。</li>
<li>序号为Seq=U+1；表示是在收到了服务器端报文的基础上，将其确认号Ack值作为本段报文序号的值。</li>
<li>确认号为Ack=W+1；表示是在收到了服务器端报文的基础上，将其序号Seq值作为本段报文确认号的值。</li>
</ul>
<p>随后客户端开始在TIME-WAIT阶段等待2MSL</p>
<p>服务器端收到从客户端发出的TCP报文之后结束LAST-ACK阶段，进入CLOSED阶段。由此正式确认关闭服务器端到客户端方向上的连接。</p>
<p>客户端等待完2MSL之后，结束TIME-WAIT阶段，进入CLOSED阶段，由此完成“四次挥手”。</p>
<p>与“三次握手”一样，在客户端与服务器端传输的TCP报文中，双方的确认号Ack和序号Seq的值，都是在彼此Ack和Seq值的基础上进行计算的，这样做保证了TCP报文传输的连贯性，一旦出现某一方发出的TCP报文丢失，便无法继续”挥手”，以此确保了”四次挥手”的顺利完成。</p>
<p><strong><em>问题1：**<strong><strong>为什么客户端在**</strong></strong>TIME-WAIT阶段要等2MSL?</em></strong></p>
<p>为的是确认服务器端是否收到客户端发出的ACK确认报文</p>
<p>当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。</p>
<p>服务器端在1MSL内没有收到客户端发出的ACK确认报文，就会再次向客户端发出FIN报文；</p>
<p>如果客户端在2MSL内，再次收到了来自服务器端的FIN报文，说明服务器端由于各种原因没有接收到客户端发出的ACK确认报文。客户端再次向服务器端发出ACK确认报文，计时器重置，重新开始2MSL的计时；</p>
<p>否则客户端在2MSL内没有再次收到来自服务器端的FIN报文，说明服务器端正常接收了ACK确认报文，客户端可以进入CLOSED阶段，完成“四次挥手”。</p>
<p>所以，客户端要经历时长为2SML的TIME-WAIT阶段；这也是为什么客户端比服务器端晚进入CLOSED阶段的原因</p>
<p><strong><em>Https的加密机制-混合密钥</em></strong></p>
<p>HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。公开密钥加密很安全。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。</p>
<p>所以应充分利用共享密钥加密和公开密钥加密各自的优势，将共享密钥加密和公开密钥加密组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。</p>
<p><strong><em>证书的基本原理</em></strong></p>
<ul>
<li>首先，客户端向服务器发出加密请求</li>
<li>服务器将自己的证书发送给请求的客户端，这个证书中包含服务器的公钥，而这个证书本身被颁发证书的可信机构的私钥加密。并且可信机构的公钥一般会存储于请求的客户端电脑上。</li>
<li>请求的客户端利用存储于本电脑上的可信机构的公钥，来验证该证书是否正确，这样就验证了服务器身份，同时得到了服务器的公钥</li>
<li>客户端利用服务器的公钥加密共享秘钥,服务器收到客户端的共享秘钥后，二者就可以通过共享秘钥完成接下来的加密通信</li>
</ul>
<p>参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/43789231?fileGuid=DjpqxkRGwrxjGwtc">Https加密原理</a></p>
<h4 id="9、Java的数据类型"><a href="#9、Java的数据类型" class="headerlink" title="9、Java的数据类型"></a><strong>9、Java的数据类型</strong></h4><p>byte 1个字节，8位表示 范围[-128,127]</p>
<p>short 2个字节，16位表示 范围[-2^15,2^15-1]</p>
<p>int 4个字节，32位表示 范围[-2^31,2^31-1]</p>
<p>long 8个字节，64位表示 范围[-2^64,2^63-1]</p>
<p>char 2个字节，16位表示 范围[0,65535]，默认值’\u0000’</p>
<p>float 4个字节，32位表示 单精度浮点数</p>
<p>double 8个字节，64位表示 双精度浮点数</p>
<p>boolean 默认值 false</p>
<p><strong><em>String、StringBuilder、StringBuffer区别</em></strong></p>
<p>String为字符串常量，不可变，StringBuilder与StringBuffer都是可变字符串，StringBuffer是线程安全的</p>
<p>执行效率比较：StringBuilder&gt;StringBuffer&gt;String</p>
<p>StringBuffer线程安全是因为大部分方法是synchronized关键字修饰的</p>
<p>String适用于少量的字符串操作，StringBuilder适用于单线程字符串缓冲区进行大量操作，StringBuffer适用于多线程字符串缓冲区进行大量操作</p>
<p><strong><em>==与equals区别</em></strong></p>
<p>“==”比较两个引用是否指向堆内存里的同一个地址，一般用于基本类型的比较</p>
<p>equals是Object中的一个方法，该方法返回结果依赖自身的实现，适用于引用对象比较</p>
<p>Object中的equals实现，比较的是两个对象的内存地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String中的equals实现，首先判断地址是否相等，然后再判断每个字符是否相同，不同则返回false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断地址值是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//判断对象类型是否为String</span></span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String anotherString = (String)anObject;</span><br><span class="line">            <span class="keyword">int</span> n = value.length;</span><br><span class="line">			<span class="comment">//判断长度是否相等</span></span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                <span class="keyword">char</span> v1[] = value;</span><br><span class="line">                <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">//每一个字符都必须相同</span></span><br><span class="line">                    <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<h4 id="10、Java反射机制"><a href="#10、Java反射机制" class="headerlink" title="10、Java反射机制"></a><strong><em>10、Java反射机制</em></strong></h4><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；</p>
<p>Java中的Class三种获取方式</p>
<ul>
<li>利用对象调用getClass()方法获取该对象的Class实例</li>
<li>使用Class类的静态方法forName()，用类的名称获取一个Class实例</li>
<li>利用Java类自己的.class的方式来获取Class实例</li>
</ul>
<p>一些常用重要方法：</p>
<p>Annotation[] getAnnotations()，获取类中所有注解</p>
<p>getClassLoader 获取加载这个类的类加载器</p>
<p>getDeclaredMethods() 获取这个类中的所有方法</p>
<p>getReturnType() 获取方法的返回类型</p>
<p>getParameterTypes() 获取方法的传入参数类型</p>
<p>isAnnotation() 测试这个类是否是一个注解类</p>
<p>getDeclaredConstructors() 获取所有的构造方法</p>
<p>getDeckaredMethod(String name,Class… parameterTypes)获取指定的构造方法</p>
<p>getSupperclass() 获取父类</p>
<p>getInterfaces() 获取此类实现的所有接口</p>
<p>getFields() 获取这个类中所有public的成员变量</p>
<p>getField(String name)获取指定名称的public成员变量</p>
<p>newInstance() 调用默认无参构造创建一个实例对象</p>
<p>获取私有变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Field field = person.getClass().getDeclaredField(fieldName);</span><br><span class="line">        <span class="comment">// 参数值为true，打开禁用访问控制检查</span></span><br><span class="line">        <span class="comment">//setAccessible(true) 并不是将方法的访问权限改成了public，而是取消java的权限控制检查。</span></span><br><span class="line">        <span class="comment">//所以即使是public方法，其accessible 属相默认也是false</span></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> field.get(person);</span><br></pre></td></tr></table></figure>
<h4 id="11、Java的注解"><a href="#11、Java的注解" class="headerlink" title="11、Java的注解"></a><strong><em>11、Java的注解</em></strong></h4></div><div class="article-licensing box"><div class="licensing-title"><p>Java知识学习笔记</p><p><a href="https://mry-byte.github.io/2021/04/06/java知识学习笔记/">https://mry-byte.github.io/2021/04/06/java知识学习笔记/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Mr.y</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-04-06</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-04-06</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E7%BC%96%E7%A8%8B/">编程</a><a class="link-muted mr-2" rel="tag" href="/tags/java/">java</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/04/06/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Android性能优化实践笔记</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/02/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"><span class="level-item">排序算法</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg" alt="Mr.y"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Mr.y</p><p class="is-size-6 is-block">慎终如始，则无败事</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>北京</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">21</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">9</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Mry-byte/Mry-byte.github.io" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Mry-byte"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://google.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Google</span></span><span class="level-right"><span class="level-item tag">google.com</span></span></a></li><li><a class="level is-mobile" href="https://baidu.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Baidu</span></span><span class="level-right"><span class="level-item tag">baidu.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E6%84%9F%E6%83%85%E9%9A%8F%E7%AC%94/"><span class="level-start"><span class="level-item">感情随笔</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"><span class="level-start"><span class="level-item">生活随笔</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">编程</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6/"><span class="level-start"><span class="level-item">读书</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-24T18:07:17.194Z">2021-04-25</time></p><p class="title"><a href="/2021/04/25/Kotlin%E7%B1%BB%E5%9E%8B%E5%88%9D%E6%AD%A5/">Kotlin类型初步</a></p><p class="categories"><a href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-19T17:33:04.836Z">2021-04-20</time></p><p class="title"><a href="/2021/04/20/Kotlin%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B/">Kotlin内置类型</a></p><p class="categories"><a href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-11T13:08:45.106Z">2021-04-11</time></p><p class="title"><a href="/2021/04/11/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/">Git版本控制工具使用</a></p><p class="categories"><a href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-06T07:36:39.883Z">2021-04-06</time></p><p class="title"><a href="/2021/04/06/%E9%81%A5%E8%BF%9C%E7%9A%84%E6%95%91%E4%B8%96%E4%B8%BB%E2%80%94%E2%80%94%E7%88%B1%E6%83%85/">丁与丹的爱情——耶路撒冷之行的寓意是什么？</a></p><p class="categories"><a href="/categories/%E6%84%9F%E6%83%85%E9%9A%8F%E7%AC%94/">感情随笔</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-06T05:39:07.660Z">2021-04-06</time></p><p class="title"><a href="/2021/04/06/Android%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Android知识学习笔记</a></p><p class="categories"><a href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kotlin/"><span class="tag">Kotlin</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%A5%E5%85%B7/"><span class="tag">工具</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AC%94%E8%AE%B0/"><span class="tag">笔记</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B/"><span class="tag">编程</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6/"><span class="tag">读书</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9A%8F%E7%AC%94/"><span class="tag">随笔</span><span class="tag">4</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">君子终日乾乾，夕惕若厉，无咎</a><p class="is-size-7"><span>&copy; 2022 Mr.y</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>